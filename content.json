{"meta":{"title":"阿腾木的小世界","subtitle":"","description":"","author":"牟金腾","url":"https://cnatom.github.io","root":"/"},"pages":[],"posts":[{"title":"【Python爬虫】HTML内容查找方法","slug":"【Python爬虫】HTML内容查找方法","date":"2020-05-03T06:34:39.000Z","updated":"2020-05-03T06:41:55.454Z","comments":true,"path":"2020/05/03/【Python爬虫】HTML内容查找方法/","link":"","permalink":"https://cnatom.github.io/2020/05/03/%E3%80%90Python%E7%88%AC%E8%99%AB%E3%80%91HTML%E5%86%85%E5%AE%B9%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95/","excerpt":"MOOC课程学习笔记课程链接：https://www.bilibili.com/video/BV1ME411E7jE?p=1","text":"MOOC课程学习笔记课程链接：https://www.bilibili.com/video/BV1ME411E7jE?p=1 目标网站的标签结构 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;title&gt;This is a python demo page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=\"title\"&gt;&lt;b&gt;The demo python introduces several python courses.&lt;/b&gt;&lt;/p&gt; &lt;p class=\"course\"&gt;Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: &lt;a href=\"http://www.icourse163.org/course/BIT-268001\" class=\"py1\" id=\"link1\"&gt;Basic Python&lt;/a&gt; and &lt;a href=\"http://www.icourse163.org/course/BIT-1001870001\" class=\"py2\" id=\"link2\"&gt;Advanced Python&lt;/a&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 内容查找方法12345678910111213141516171819202122232425262728import requestsimport refrom bs4 import BeautifulSoupr = requests.get(\"https://python123.io/ws/demo.html\")soup = BeautifulSoup(r.text,'html.parser')#查找HTML中的a标签print(soup.findAll(\"a\")) #查找HTML中的a与b标签print(soup.findAll(['a','b'])) # #findAll参数为True时返回所有标签for tag in soup.findAll(True): print(tag.name)# #利用正则表达式查找以b为开头的标签for tag in soup.findAll(re.compile('b')): print(tag.name)#查找p中包含course属性的标签for tag in soup.findAll('p',attrs='course'): print(tag)#查找属性域中包含link1的标签for tag in soup.findAll(id='link1'): print(tag)#利用正则表达式查找属性域中所有包含link的标签for tag in soup.findAll(id=re.compile('link')): print(tag)#在字符串区域中检索指定字符串print(soup.findAll(string = 'Basic Python'))print(soup.findAll(text=\"Basic Python\"))print(soup.findAll(text=re.compile('python')))","categories":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://cnatom.github.io/categories/Python%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://cnatom.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://cnatom.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"【Python爬虫】定向爬取大学排名","slug":"【Python爬虫】定向爬取大学排名","date":"2020-05-03T06:06:25.000Z","updated":"2020-05-03T06:31:37.087Z","comments":true,"path":"2020/05/03/【Python爬虫】定向爬取大学排名/","link":"","permalink":"https://cnatom.github.io/2020/05/03/%E3%80%90Python%E7%88%AC%E8%99%AB%E3%80%91%E5%AE%9A%E5%90%91%E7%88%AC%E5%8F%96%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D/","excerpt":"MOOC课程学习笔记课程链接：https://www.bilibili.com/video/BV1ME411E7jE?p=1","text":"MOOC课程学习笔记课程链接：https://www.bilibili.com/video/BV1ME411E7jE?p=1 包含的库 库 作用 re 正则表达式 requests 进行网络请求 BeautifulSoup 从HTML中提取数据 123import requestsimport bs4from bs4 import BeautifulSoup 程序的结构设计1234567891011def main(): # 存储大学排名信息 uinfo = [] #目标地址 url = \"http://www.zuihaodaxue.cn/zuihaodaxuepaiming2019.html\" #从网络上获取大学排名内容 html = getHTMLText(url) #将网页信息存储到合适的数据结构中 fillUnivList(uinfo,html) #利用数据结构展示并输出内容 printUnivList(uinfo,20) 各函数的具体实现从网络上获取大学排名内容123456789def getHTMLText(url): '''获取url信息，输出url内容''' try: r = requests.get(url) r.raise_for_status() #如果状态不是200，引发HTTPError异常 r.encoding = r.apparent_encoding #按内容编码 return r.text #返回Response内容 except: return \"产生异常\" 将网页信息存储到合适的数据结构中1234567def fillUnivList(ulist,html): '''将文章页面放在list列表中''' soup = BeautifulSoup(html,\"html.parser\") for tr in soup.find('tbody').children: #遍历tbody标签的子节点(children迭代类型) if isinstance(tr,bs4.element.Tag): #检测tr标签是否为bs4定义的Tag类型 tds = tr('td') #tds以list形式存储td标签 ulist.append([tds[0].string,tds[1].string,tds[2].string]) 利用数据结构展示并输出内容123456def printUnivList(ulist,num): '''打印ulist中num个信息''' print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(\"排名\",\"学校名称\",\"总分\")) for i in range(num): u = ulist[i] print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(u[0],u[1],u[2])) 输出结果123456789101112131415161718192021排名 学校名称 总分 1 清华大学 北京 2 北京大学 北京 3 浙江大学 浙江 4 上海交通大学 上海 5 复旦大学 上海 6 中国科学技术大学 安徽 7 华中科技大学 湖北 7 南京大学 江苏 9 中山大学 广东 10 哈尔滨工业大学 黑龙江 11 北京航空航天大学 北京 12 武汉大学 湖北 13 同济大学 上海 14 西安交通大学 陕西 15 四川大学 四川 16 北京理工大学 北京 17 东南大学 江苏 18 南开大学 天津 19 天津大学 天津 20 华南理工大学 广东","categories":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://cnatom.github.io/categories/Python%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://cnatom.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://cnatom.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"【数据结构】单向链表SinglyLinkedList","slug":"【数据结构】单向链表SinglyLinkedList","date":"2020-04-23T08:19:40.000Z","updated":"2020-04-28T08:27:39.018Z","comments":true,"path":"2020/04/23/【数据结构】单向链表SinglyLinkedList/","link":"","permalink":"https://cnatom.github.io/2020/04/23/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8SinglyLinkedList/","excerpt":"","text":"SinglyLinkedList.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;stdlib.h&gt; #include&lt;iostream&gt;class node&#123; public: int data;//结点的值 node *next;//保存后继结点的地址 node()&#123; data = -1; next = NULL; &#125; //构造方法，方便快速创建结点 node(int data,node *next)&#123; this-&gt;data = data; this-&gt;next = next; &#125;&#125;;class List&#123; private: node* head;//指向表头(表头恒为空) int lenth;//单链表当前最大下标值 bool check(int index);//工具方法，检测index合法性 public: int size()&#123;return lenth+1;&#125;//返回链表长度 List();//构造函数 List(const List&amp; temp);//拷贝构造函数 ~List();//析构函数 void append(const int num);//添加到表尾 void insert(int index,int num);//在index处添加元素num void delnum(int index);//删除index处元素 void clear();//清除操作 void combine(int index,const List&amp; temp);//index后面插入另一个链表 int&amp; operator[](int index);//重载[]运算符 int search(int aim);//搜索aim元素 void show();//显示链表的全部元素&#125;;//检查边界 bool List::check(int index)&#123; if(index&lt;0||index&gt;lenth)&#123; std::cout &lt;&lt; \"INDEX_ERROR\" &lt;&lt; std::endl; return false; &#125; return true;&#125;//构造函数List::List()&#123; head = new node; lenth = -1;&#125;//拷贝构造函数List::List(const List&amp; copy)&#123; node* p1 = head; node* p2 = copy.head-&gt;next; while(p2!=NULL)&#123; p1-&gt;next = new node(p2-&gt;data,NULL); p1 = p1-&gt;next; lenth++; p2 = p2-&gt;next; &#125;&#125; //析构函数 List::~List()&#123; node* p1;//p1在p2的前面，p1负责指向待删除结点，p2负责向后遍历 node* p2 = head; while(p2-&gt;next!=NULL)&#123; p1 = p2; p2 = p2-&gt;next; delete p1; &#125; delete p2;&#125;//附加操作 void List::append(const int num)&#123; node* p = head;//p用来遍历链表 while(p-&gt;next!=NULL) p=p-&gt;next;//向后遍历直到结尾 p-&gt;next = new node(num,NULL);//在结尾创建一个新的结点 lenth++;//最长下标+1&#125;//插入操作 void List::insert(int index,int num)&#123; if(index&lt;0||index&gt;lenth+1)&#123; std::cout &lt;&lt; \"INDEX_ERROR\" &lt;&lt; std::endl; return; &#125; node* p1 = head;//p1负责指向被插入结点的前继(index-1)位置 node* p2 = new node(num,NULL);//p2存储新结点 for(int i=0;i&lt;index;i++) p1 = p1-&gt;next;//p1向后遍历寻找index-1的位置 p2-&gt;next = p1-&gt;next;//新结点(p2)指向p1的后继结点 p1-&gt;next = p2;//p1指向新结点(p2) lenth++;&#125;//删除操作void List::delnum(int index)&#123; if(!check(index)) return; node* p1 = head; node* p2; for(int i=0;i&lt;index;i++) p1 = p1-&gt;next; p2 = p1-&gt;next; p1-&gt;next = p2-&gt;next; delete p2; lenth--;&#125; //清除操作 void List::clear()&#123; node* p1; node* p2 = head-&gt;next; while(p2-&gt;next!=NULL)&#123; p1 = p2; p2 = p2-&gt;next; delete p1; &#125; delete p2; head-&gt;next = NULL; lenth = 0;&#125;//插入另一链表 void List::combine(int index,const List&amp; inserted)&#123; if(!check(index)) return; node* p1 = head; node* p2 = inserted.head-&gt;next; for(int i=0;i&lt;index;i++) p1 = p1-&gt;next; while(p2!=NULL)&#123; node* temp = new node(p2-&gt;data,p1-&gt;next); p1-&gt;next = temp; p2 = p2-&gt;next; lenth++; &#125;&#125;//重载[] int&amp; List::operator[](int index)&#123; if(!check(index)) return this-&gt;head-&gt;data; node* p = this-&gt;head; for(int i=0;i&lt;=index;i++) p=p-&gt;next; return p-&gt;data;&#125;//搜索操作int List::search(int aim)&#123; node* p = head-&gt;next; int ans = 0; while(p!=NULL &amp;&amp; p-&gt;data!=aim)&#123; p = p-&gt;next; ans++; &#125; if(p==NULL) return -1; return ans;&#125; //显示操作 void List::show()&#123; node* p = head-&gt;next; while(p!=NULL)&#123; std::cout &lt;&lt; p-&gt;data &lt;&lt; \" \"; p = p-&gt;next; &#125; std::cout &lt;&lt; std::endl;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://cnatom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cnatom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构】顺序表arrList","slug":"【数据结构】顺序表arrList","date":"2020-04-21T07:31:58.000Z","updated":"2020-04-23T08:20:18.426Z","comments":true,"path":"2020/04/21/【数据结构】顺序表arrList/","link":"","permalink":"https://cnatom.github.io/2020/04/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E9%A1%BA%E5%BA%8F%E8%A1%A8arrList/","excerpt":"","text":"arrList.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;template&lt;class T&gt;class arrList&#123; private: int maxSize; int curLen; //指向最后一个元素 T* aList; //指向动态数组的首地址 //工具方法，判定边界 bool check(int index)&#123; if(curLen&gt;maxSize || index&lt;0 || index&gt;curLen)&#123; std::cout &lt;&lt; \"ERROR\"; return false; &#125; return true; &#125; public: //构造函数 arrList(const int size):maxSize(size)&#123; curLen = 0; aList = new T[maxSize]; //new T[maxSize]返回T数组的首地址 &#125; //析构函数 ~arrList()&#123; delete [] aList; &#125; //显示操作 void show()&#123; int i=0; while(i&lt;this-&gt;curLen)&#123; std::cout &lt;&lt; this-&gt;aList[i++] &lt;&lt; \" \"; &#125; std::cout &lt;&lt; std::endl; &#125; //清空顺序表 void clear()&#123; delete [] aList; curLen = 0; aList = new T[maxSize]; &#125; //返回长度 int lenth()&#123; return curLen; &#125; //附加操作 bool append(const T value)&#123; if(check(0))&#123; aList[curLen++]=value; return true; &#125; return false; &#125; //插入操作 bool insert(int index,const T value)&#123; if(check(index))&#123; for(int i=curLen+1;i&gt;index;i--)&#123; aList[i] = aList[i-1]; &#125; aList[index] = value; curLen++; return true; &#125; return false; &#125; //删除操作 bool del(int index)&#123; if(check(index))&#123; for(int i=index;i&lt;curLen;i++)&#123; aList[i] = aList[i+1]; &#125; curLen--; return true; &#125; return false; &#125; //重载[]运算符 T&amp; operator[](int i)&#123; if(check(i))&#123; return aList[i]; &#125; return aList[0]; &#125; //改变index处的元素值 bool setValue(int index,const T value)&#123; if(check(index))&#123; aList[index] = value; return true; &#125; return false; &#125; //遍历查找元素value,index接收其下标 bool getPos(int&amp; index,const T value)&#123; for(int i=0;i&lt;curLen;i++)&#123; if(aList[i]!=value) continue; index = i; return true; &#125; index = -1; return false; &#125; //并运算，结果存储到arrA中 void arr_union(arrList&amp; arrA,arrList&amp; arrB)&#123; int i = 0,index; bool flag; while(i&lt;arrB.curLen)&#123; //遍历arrB的元素 flag = arrA.getPos(index,arrB[i]); //如果在arrA中找到arrB[i] if(!flag) arrA.append(arrB[i]); i++; //则将arrB[i]添加到arrA后面 &#125; &#125; //交运算,结果存储到arrA中 void arr_intersection(arrList&amp; arrA,arrList&amp; arrB)&#123; int i = curLen-1,index; bool flag; while(i&gt;=0)&#123; //遍历arrA的元素 flag = arrB.getPos(index,arrA[i]); //如果在arrB中没找到arrA[i] if(!flag) arrA.del(i); //则删除arrA[i] i--; &#125; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://cnatom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cnatom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【数据结构】时间复杂度的计算","slug":"【数据结构】时间复杂度的计算","date":"2020-04-21T03:09:00.000Z","updated":"2020-04-21T03:09:31.455Z","comments":true,"path":"2020/04/21/【数据结构】时间复杂度的计算/","link":"","permalink":"https://cnatom.github.io/2020/04/21/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/","excerpt":"作者：raymondCaptain链接：https://www.jianshu.com/p/f4cca5ce055a来源：简书","text":"作者：raymondCaptain链接：https://www.jianshu.com/p/f4cca5ce055a来源：简书 我们假设计算机运行一行基础代码需要执行一次运算。 1234int aFunc(void) &#123; printf(\"Hello, World!\\n\"); // 需要执行 1 次 return 0; // 需要执行 1 次&#125; 那么上面这个方法需要执行 2 次运算 123456int aFunc(int n) &#123; for(int i = 0; i&lt;n; i++) &#123; // 需要执行 (n + 1) 次 printf(\"Hello, World!\\n\"); // 需要执行 n 次 &#125; return 0; // 需要执行 1 次&#125; 这个方法需要 (n + 1 + n + 1) = 2n + 2 次运算。 我们把 算法需要执行的运算次数 用 输入大小n 的函数 表示，即 T(n) 。此时为了 估算算法需要的运行时间 和 简化算法分析，我们引入时间复杂度的概念。 定义：存在常数 c 和函数 f(N)，使得当 N &gt;= c 时 T(N) &lt;= f(N)，表示为 T(n) = O(f(n)) 。如图： 当 N &gt;= 2 的时候，f(n) = n^2 总是大于 T(n) = n + 2 的，于是我们说 f(n) 的增长速度是大于或者等于 T(n) 的，也说 f(n) 是 T(n) 的上界，可以表示为 T(n) = O(f(n))。 因为f(n) 的增长速度是大于或者等于 T(n) 的，即T(n) = O(f(n))，所以我们可以用 f(n) 的增长速度来度量 T(n) 的增长速度，所以我们说这个算法的时间复杂度是 O(f(n))。 算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。 显然如果 T(n) = n^2，那么 T(n) = O(n^2)，T(n) = O(n^3)，T(n) = O(n^4) 都是成立的，但是因为第一个 f(n) 的增长速度与 T(n) 是最接近的，所以第一个是最好的选择，所以我们说这个算法的复杂度是 O(n^2) 。 那么当我们拿到算法的执行次数函数 T(n) 之后怎么得到算法的时间复杂度呢？ 我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c 为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n) 不等于一个常数项时，直接将常数项省略。 比如第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。T(n) = n + 29，此时时间复杂度为 O(n)。 我们知道高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。 比如T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。 因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。 比如T(n) = 3n^3，此时时间复杂度为 O(n^3)。 综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。 由此可见，由执行次数 T(n) 得到时间复杂度并不困难，很多时候困难的是从算法通过分析和数学运算得到 T(n)。对此，提供下列四个便利的法则，这些法则都是可以简单推导出来的，总结出来以便提高效率。 对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。 12345void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n printf(\"Hello, World!\\n\"); // 循环体时间复杂度为 O(1) &#125;&#125; 此时时间复杂度为 O(n × 1)，即 O(n)。2. 对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c…，则这个循环的时间复杂度为 O(n×a×b×c…)。分析的时候应该由里向外分析这些循环。 1234567void aFunc(int n) &#123; for(int i = 0; i &lt; n; i++) &#123; // 循环次数为 n for(int j = 0; j &lt; n; j++) &#123; // 循环次数为 n printf(\"Hello, World!\\n\"); // 循环体时间复杂度为 O(1) &#125; &#125;&#125; 此时时间复杂度为 O(n × n × 1)，即 O(n^2)。 对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。 123456789101112void aFunc(int n) &#123; // 第一部分时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf(\"Hello, World!\\n\"); &#125; &#125; // 第二部分时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf(\"Hello, World!\\n\"); &#125;&#125; 此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。 对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。 123456789101112131415void aFunc(int n) &#123; if (n &gt;= 0) &#123; // 第一条路径时间复杂度为 O(n^2) for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; printf(\"输入数据大于等于零\\n\"); &#125; &#125; &#125; else &#123; // 第二条路径时间复杂度为 O(n) for(int j = 0; j &lt; n; j++) &#123; printf(\"输入数据小于零\\n\"); &#125; &#125;&#125; 此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。 时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。 最后，我们来练习一下 一. 基础题求该方法的时间复杂度 1234567void aFunc(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; printf(\"Hello World\\n\"); &#125; &#125;&#125; 参考答案：当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。 二. 进阶题求该方法的时间复杂度 123456void aFunc(int n) &#123; for (int i = 2; i &lt; n; i++) &#123; i *= 2; printf(\"%i\\n\", i); &#125;&#125; 参考答案：假设循环次数为 t，则循环条件满足 2^t &lt; n。可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。 三. 再次进阶求该方法的时间复杂度 1234567long aFunc(int n) &#123; if (n &lt;= 1) &#123; return 1; &#125; else &#123; return aFunc(n - 1) + aFunc(n - 2); &#125;&#125; 参考答案：显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n &gt;= 1 时 T(n) &lt; (5/3)^n，同时当 n &gt; 4 时 T(n) &gt;= (3/2)^n。所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。 作者：raymondCaptain链接：https://www.jianshu.com/p/f4cca5ce055a来源：简书 补充： 求以下程序的时间复杂度： 1234for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 题解：https://blog.csdn.net/liulangcheshou/article/details/53243789","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://cnatom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cnatom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"用Python爬取豆瓣热门剧名及其评分信息","slug":"Python-Reptile-douban","date":"2020-03-04T12:38:23.000Z","updated":"2020-03-04T13:20:14.481Z","comments":true,"path":"2020/03/04/Python-Reptile-douban/","link":"","permalink":"https://cnatom.github.io/2020/03/04/Python-Reptile-douban/","excerpt":"","text":"爬取目标 用chrome Devtools寻找信息 URL和请求方式 Params和User-Agent 当点击“加载更多”的时候，page_start参数会自增20，因此定义Params的时候要用一个循环 用Postman预览Json字符串 这里我们只需要获得rate和name信息 用Python抓取1234567891011121314151617181920212223import requestsimport jsonurl = 'https://movie.douban.com/j/search_subjects'headers = &#123; 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36'&#125;for i in range(0,100,20): params = &#123; 'type': 'tv', 'tag': '热门', 'sort': 'recommend', 'page_limit': 20, 'page_start': i &#125; res = requests.get( url = url, params = params, headers = headers ) html = res.text data = json.loads(html) for data_temp in data['subjects']: print(data_temp['title'],data_temp['rate'])","categories":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://cnatom.github.io/categories/Python%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://cnatom.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://cnatom.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python网络请求模块Requests的使用","slug":"【Python爬虫】Requests","date":"2020-03-04T08:19:17.000Z","updated":"2020-03-04T08:42:48.931Z","comments":true,"path":"2020/03/04/【Python爬虫】Requests/","link":"","permalink":"https://cnatom.github.io/2020/03/04/%E3%80%90Python%E7%88%AC%E8%99%AB%E3%80%91Requests/","excerpt":"","text":"网络请求模块requests介绍 requests 模块是可以模仿浏览器发送请求获取响应requests 模块在python2,与python3中通用requests模块能够自动帮助我们解压网页内容 requests模块的安装 pip install requests 如果你本地有python2,和python3两个环境，你想装在python3中，建议使用下面这种方式安装 pip3 install requests requests模块的使用基本使用 使用方式 12345678# 导入模块import requests# 定义请求地址url = 'http://www.baidu.com'# 发送 GET 请求获取响应response = requests.get(url)# 获取响应的 html 内容html = response.text 代码讲解 response 常用属性 response.text 返回响应内容，响应内容为 str 类型 respones.content 返回响应内容,响应内容为 bytes 类型 response.status_code 返回响应状态码 response.request.headers 返回请求头 response.headers 返回响应头 response.cookies 返回响应的 RequestsCookieJar 对象 response.content 转换 str 类型 1234# 获取字节数据content = response.content# 转换成字符串类型html = content.decode('utf-8') response.cookies 操作 12345678# 返回 RequestsCookieJar 对象cookies = response.cookies# RequestsCookieJar 转 dictrequests.utils.dict_from_cookiejar(cookies)# dict 转 RequestsCookieJarrequests.utils.cookiejar_from_dict()# 对cookie进行操作,把一个字典添加到cookiejar中requests.utils.add_dict_to_cookiejar() 自定义请求头 使用方式 123456789101112# 导入模块import requests# 定义请求地址url = 'http://www.baidu.com'# 定义自定义请求头headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"&#125;# 发送自定义请求头response = requests.get(url,headers=headers)# 获取响应的 html 内容html = response.text 代码讲解 发送请求时添加 headers 参数作为自定义请求头 发送 GET 请求 使用方式 12345678910111213141516# 导入模块import requests# 定义请求地址url = 'http://www.baidu.com/s'# 定义自定义请求头headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"&#125;# 定义 GET 请求参数params = &#123; \"kw\":\"hello\"&#125;# 使用 GET 请求参数发送请求response = requests.get(url,headers=headers,params=params)# 获取响应的 html 内容html = response.text 代码讲解 发送请求时 params 参数作为 GET 请求参数 发送 POST 请求 使用方式 1234567891011121314151617# 导入模块import requests# 定义请求地址url = 'http://www.baidu.com'# 定义自定义请求头headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"&#125;# 定义post请求参数data = &#123; \"kw\":\"hello\"&#125;# 使用 POST 请求参数发送请求response = requests.post(url,headers=headers,data=data)# 获取响应的 html 内容html = response.text 代码讲解 发送请求时 data 参数作为 POST 请求参数 保存图片 使用方式 123456789# 导入模块import requests# 下载图片地址url = \"http://docs.python-requests.org/zh_CN/latest/_static/requests-sidebar.png\"# 发送请求获取响应response = requests.get(url)# 保存图片with open('image.png','wb') as f: f.write(response.content) 代码讲解 保存图片时后缀名和请求的后缀名一致 保存必须使用 response.content 进行保存文件 使用代理服务器 作用 让服务器以为不是同一个客户端在请求 防止我们的真实地址被泄露，防止被追究 使用代理的过程 代理分类 透明代理(Transparent Proxy)：透明代理虽然可以直接“隐藏”你的IP地址，但是还是可以查到你是谁。 匿名代理(Anonymous Proxy)：匿名代理比透明代理进步了一点：别人只能知道你用了代理，无法知道你是谁。 混淆代理(Distorting Proxies)：与匿名代理相同，如果使用了混淆代理，别人还是能知道你在用代理，但是会得到一个假的IP地址，伪装的更逼真 高匿代理(Elite proxy或High Anonymity Proxy)：可以看出来，高匿代理让别人根本无法发现你是在用代理，所以是最好的选择。 在使用的使用，毫无疑问使用高匿代理效果最好 从使用的协议：代理ip可以分为http代理，https代理，socket代理等，使用的时候需要根据抓取网站的协议来选择 使用方式 1234567891011121314151617# 导入模块import requests# 定义请求地址url = 'http://www.baidu.com'# 定义自定义请求头headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"&#125;# 定义 代理服务器proxies = &#123; \"http\":\"http://IP地址:端口号\", \"https\":\"https://IP地址:端口号\"&#125;# 使用 POST 请求参数发送请求response = requests.get(url,headers=headers,proxies=proxies)# 获取响应的 html 内容html = response.text 代码讲解 发送请求时 proxies 参数设置代理 发送请求携带 Cookies 使用方式 直接在自定义请求头中携带 Cookie 通过请求参数携带 Cookie 对象 代码 123456789101112131415161718# 导入模块import requests# 定义请求地址url = 'http://www.baidu.com'# 定义自定义请求头headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\" # 方式一：直接在请求头中携带Cookie内容 \"Cookie\": \"Cookie值\"&#125;# 方式二：定义 cookies 值cookies = &#123; \"xx\":\"yy\"&#125;# 使用 POST 请求参数发送请求response = requests.get(url,headers=headers,cookies=cookies)# 获取响应的 html 内容html = response.text 代码讲解 发送请求时 cookies 参数携带 Cookies 错误证书处理 问题描述 使用方式 123456# 导入模块import requestsurl = \"https://www.12306.cn/mormhweb/\"# 设置忽略证书response = requests.get(url,verify=False) 代码讲解 发送请求时 verify 参数设置为 False 表示不验证CA证书 超时处理 使用方式 123456# 导入模块import requestsurl = \"https://www.baidu.com\"# 设置忽略证书response = requests.get(url,timeout=5) 代码讲解 发送请求时 timeout 参数设置为超时秒数 重试处理 使用方式 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/python3# -*- coding: utf-8 -*-'''可以使用第三方模块 retrying 模块1. pip install retrying'''import requests# 1. 导入模块from retrying import retry# 2. 使用装饰器进行重试设置# stop_max_attempt_number 表示重试次数@retry(stop_max_attempt_number=3)def parse_url(url): print(\"访问url:\",url) headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36\" &#125; proxies = &#123; \"http\":\"http://124.235.135.210:80\" &#125; # 设置超时参数 response = requests.get(url,headers=headers,proxies=proxies,timeout=5) return response.textif __name__ == '__main__': url = \"http://www.baidu.com\" try: html = parse_url(url) print(html) except Exception as e: # 把 url 记录到日志文件中，未来进行手动分析，然后对url进行重新请求 print(e) 代码讲解安装 retrying 模块 retrying 模块可以通过装饰器模式对某个函数进行监控，如果该函数引发异常就会触发重试操作 pip install retrying 对需要重试的函数进行装饰器设置 通过 @retry(stop_max_attempt_number=重试次数) 参数设置重试次数 1234567891011121314151617181920212223242526272829303132333435363738394041# 1. 导入模块from retrying import retry# 2. 装饰器设置重试函数@retry(stop_max_attempt_number=3)def exec_func(): pass``` ## urllib&gt; python3 中使用urllib网络库```python#!/usr/bin/python3# -*- coding: utf-8 -*-import urllib.request# 2. 发起网络请求# 2.1. 定义请求地址url = \"https://github.com\"# 2.2. 自定义请求头headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\", \"Referer\": \"https://github.com/\", \"Host\": \"github.com\"&#125;# 定义请求对象req = urllib.request.Request( url=url, headers=headers)# 发送请求resp = urllib.request.urlopen(req)# 处理响应with open('github.txt', 'wb') as f: f.write(resp.read()) urllib使用注意事项 如果使用在URL中需要进行转义 12345678910111213141516171819202122232425262728293031 #!/usr/bin/python3 # -*- coding: utf-8 -*- # 1. 导入模块 import urllib.request import urllib.parse # 2. 发起请求获取响应 wd = input(\"请输入查询内容：\") # 2.1 定义请求地址 url = \"https://www.baidu.com/s?wd=\" # 2.2 定义自定义请求头headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36\", \"Referer\": \"https://github.com/\", \"Host\": \"github.com\"&#125; # 2.3 定义请求对象 request = urllib.request.Request( url=url + urllib.parse.quote(wd), headers=headers ) # 2.4 发送请求 response = urllib.request.urlopen(request) # 3. 处理响应 with open('02.html','wb') as f: f.write(response.read())response.read() 返回值是字节串，获取字符串内容需要进行 decode 1html = response.read().decode('utf-8') 转载自https://github.com/Kr1s77/Python-crawler-tutorial-starts-from-zero","categories":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://cnatom.github.io/categories/Python%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://cnatom.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://cnatom.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"【Flutter之旅】壁纸APP(API初试)","slug":"【Flutter之旅】壁纸APP(API初试)","date":"2020-02-10T10:01:56.000Z","updated":"2020-05-03T04:49:59.916Z","comments":true,"path":"2020/02/10/【Flutter之旅】壁纸APP(API初试)/","link":"","permalink":"https://cnatom.github.io/2020/02/10/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91%E5%A3%81%E7%BA%B8APP(API%E5%88%9D%E8%AF%95)/","excerpt":"引用pexels的API | dio网络请求 | Json转实体类","text":"引用pexels的API | dio网络请求 | Json转实体类 效果 源代码：https://github.com/cnatom/wall_paper","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】Json和序列化","slug":"【Flutter之旅】Json和序列化","date":"2020-02-08T14:01:56.000Z","updated":"2020-05-03T04:49:41.630Z","comments":true,"path":"2020/02/08/【Flutter之旅】Json和序列化/","link":"","permalink":"https://cnatom.github.io/2020/02/08/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91Json%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"dart:convert手动序列化JSON | 使用代码生成库序列化JSON","text":"dart:convert手动序列化JSON | 使用代码生成库序列化JSON dart:convert手动序列化JSON 源代码 1234567891011121314151617181920212223242526272829303132import 'dart:convert';//创建一个模型类class Student&#123; String name; int age; Student(this.name,this.age); //用于从一个map构造出一个Student实例 Student.fromJson(Map&lt;String,dynamic&gt; json): name = json['name'], age = json['age']; // 将Student实例转化为一个map. //jsonDecode(jsonStr) 方法中会调用实体类的这个方法。如果实体类中没有这个方法，会报错。 Map&lt;String,dynamic&gt; toJson()&#123; return &#123; \"name\": name, \"age\" : age &#125;; &#125;&#125;void main() &#123; // 创建Json字符串（Json必须用双引号） String jsonfile = '&#123;\"name\":\"MJT\",\"age\" :19&#125;'; //用jsonDecode将Json解码为Map Map&lt;String, dynamic&gt; map = jsonDecode(jsonfile); //从map中构造出Student实例并使用 Student student = Student.fromJson(map); print(student.name); //将实例对象编码为Json String temp = jsonEncode(student); print(temp);&#125; 使用代码生成库序列化JSON在项目中设置json_serializable要包含json_serializable到我们的项目中。pubspec.yaml 123456dependencies: json_annotation: ^3.0.0dev_dependencies: build_runner: ^1.0.0 json_serializable: ^3.2.0 在项目根文件夹中运行 flutter packages get (或者在编辑器中点击 “Packages Get”) 以在项目中使用这些新的依赖项. 查看所需依赖的最新版本：https://github.com/dart-lang/json_serializable/blob/master/example/pubspec.yaml 以json_serializable的方式创建model类12345678910111213import 'package:json_annotation/json_annotation.dart';// student.g.dart 将在我们运行生成命令后自动生成import 'student.g.dart';///这个标注是告诉生成器，这个类是需要生成Model类的@JsonSerializable()//下面的代码不变class Student&#123; ......&#125;void main()&#123; ......&#125; 一次性生成在项目根目录下运行flutter packages pub run build_runner build，可以在需要时为model生成json序列化代码。 但是每次在model类中进行更改都要再手动运行一遍构建命令，太不方便。 持续生成_watcher_会监视项目中文件的变化，并在需要时自动构建必要的文件。只需在根目录下运行flutter packages pub run build_runner watch来启动_watcher_。只需启动一次观察器，然后并让它在后台运行。 使用json_serializable模型使用的话不需要修改以前的代码，生成序列化代码后直接运行就好了。 参考文档:https://flutterchina.club/json/","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】滑动视图","slug":"【Flutter之旅】滑动视图","date":"2020-02-07T14:01:56.000Z","updated":"2020-05-03T04:49:26.869Z","comments":true,"path":"2020/02/07/【Flutter之旅】滑动视图/","link":"","permalink":"https://cnatom.github.io/2020/02/07/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91%E6%BB%91%E5%8A%A8%E8%A7%86%E5%9B%BE/","excerpt":"PageView滑动视图|PageController调整页面的显示","text":"PageView滑动视图|PageController调整页面的显示 效果 源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';void main()=&gt;runApp(MaterialApp( home: MyApp(),));//创建一个PageController，方便使用底部导航栏改变PageView的内容PageController _pageController = new PageController();int _curIndex = 0;//当前索引//纯色页面，用Page类构造函数批量生成var pages = &lt;Widget&gt;[ Page(Colors.orange), Page(Colors.purple), Page(Colors.green)];class Page extends StatelessWidget &#123; Color c; Page(this.c); @override Widget build(BuildContext context) &#123; return Scaffold( body: Container(color: c,), ); &#125;&#125;class MyApp extends StatefulWidget &#123; @override _MyAppState createState() =&gt; _MyAppState();&#125;class _MyAppState extends State&lt;MyApp&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"滑动\"), ), //PageView滑动界面 [https://www.jianshu.com/p/036c3b865820] body: PageView.builder( controller: _pageController, itemBuilder: (context,index) =&gt; pages[index], itemCount: pages.length, //当滑动的时候改变当前索引,并刷新界面 onPageChanged: (index)&#123; setState(() &#123; _curIndex = index; &#125;); &#125;, ), //创建底部导航栏 bottomNavigationBar: BottomNavigationBar( items: [ BottomNavigationBarItem( title: Text(\"Orange\"), icon:Icon(Icons.star) ), BottomNavigationBarItem( title: Text(\"Purple\"), icon:Icon(Icons.star) ), BottomNavigationBarItem( title: Text(\"Green\"), icon:Icon(Icons.star) ) ], currentIndex: _curIndex, //在导航栏中利用Controller改变PageView onTap: (index)&#123; _pageController.jumpToPage(index); &#125; ), ); &#125;&#125;","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】启动页","slug":"【Flutter之旅】启动页","date":"2020-02-06T14:01:56.000Z","updated":"2020-05-03T04:49:02.804Z","comments":true,"path":"2020/02/06/【Flutter之旅】启动页/","link":"","permalink":"https://cnatom.github.io/2020/02/06/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91%E5%90%AF%E5%8A%A8%E9%A1%B5/","excerpt":"设置状态栏|启动页的布局方式","text":"设置状态栏|启动页的布局方式 项目来源：https://github.com/LiveLikeCounter/Flutter-Todolist 效果 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import 'package:flutter/material.dart';import 'package:flutter/services.dart';void main()&#123; //设置状态栏 SystemChrome.setSystemUIOverlayStyle( SystemUiOverlayStyle( statusBarColor: Colors.transparent//隐藏顶部状态栏 ) ); runApp(MaterialApp( debugShowCheckedModeBanner: false,//不显示debug横幅 home:MyApp() ));&#125;class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( body: Center(//整体居中 child: Container(//Container用来调整宽度 //根据不同的屏幕大小调整Container的宽度 width: MediaQuery.of(context).size.width / 1.2, child: Column(//垂直布局 children: &lt;Widget&gt;[ Expanded( flex: 8,//flex调整比例 child: Container( width: MediaQuery.of(context).size.width/2.5, child: Image.network(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/diary.png\"),), ), Expanded( flex: 3, child: Column( children: &lt;Widget&gt;[ Text( '阿腾木的小世界', style: TextStyle( fontSize: 22, fontWeight: FontWeight.w500, color: Color.fromRGBO(85, 78, 143, 1)), ), SizedBox(height: 15),//间距 Text( 'ccatom.com', style: TextStyle( fontSize: 17, fontWeight: FontWeight.w400, color: Color.fromRGBO(130, 160, 183, 1), ), ), ], ), ), Expanded( flex: 1, child: RaisedButton( onPressed: () &#123;&#125;, textColor: Colors.white, padding: const EdgeInsets.all(0.0), shape: RoundedRectangleBorder( borderRadius: BorderRadius.circular(8.0), ), child: Container( width: MediaQuery.of(context).size.width / 1.4, height: 60, decoration: const BoxDecoration( gradient: LinearGradient( colors: &lt;Color&gt;[ Color.fromRGBO(93, 230, 26, 1), Color.fromRGBO(57, 170, 2, 1), ], ), borderRadius: BorderRadius.all( Radius.circular(8.0), ), boxShadow: [ BoxShadow( color: Color.fromRGBO(30, 209, 2, 0.24), blurRadius: 15.0, spreadRadius: 7.0, offset: Offset(0.0, 0.0), ), ], ), padding: const EdgeInsets.fromLTRB(20, 10, 20, 10), child: Center( child: Text( '进入', style: TextStyle( fontSize: 18, fontWeight: FontWeight.w500), ), ), ), ), ), Expanded( flex: 2, child: Container(), ) ], ), ) ), ); &#125;&#125;","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】精简版QQ","slug":"【Flutter之旅】精简版QQ","date":"2020-01-31T14:01:56.000Z","updated":"2020-05-03T04:48:26.906Z","comments":true,"path":"2020/01/31/【Flutter之旅】精简版QQ/","link":"","permalink":"https://cnatom.github.io/2020/01/31/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91%E7%B2%BE%E7%AE%80%E7%89%88QQ/","excerpt":"底部导航栏的制作|非静态页面的使用","text":"底部导航栏的制作|非静态页面的使用 效果 源代码 main.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import 'package:flutter/material.dart';import 'package:flutter_app2/message_page.dart';import 'package:flutter_app2/contact_page.dart';import 'package:flutter_app2/social_page.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( home: MyBottom(), ); &#125;&#125;class MyBottom extends StatefulWidget &#123; @override _MyBottomState createState() =&gt; _MyBottomState();&#125;class _MyBottomState extends State&lt;MyBottom&gt; &#123; int _curindex = 0; //当前页面索引 List&lt;Widget&gt; page = List(); //用List保存大量子页面 //重写State中的initState方法来初始化页面 @override void initState() &#123; //将子页面添加到page列表中 page..add(MessagePage())..add(ContactPage())..add(SocialPage()); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: page[_curindex], //底部导航按钮栏 bottomNavigationBar: BottomNavigationBar( type: BottomNavigationBarType.fixed, items: [ BottomNavigationBarItem(icon: Icon(Icons.mode_comment), title: Text(\"消息\")), BottomNavigationBarItem(icon: Icon(Icons.account_circle), title: Text(\"联系人\"),), BottomNavigationBarItem(icon: Icon(Icons.explore), title: Text(\"动态\")) ], //当前页面索引，按照items排序 //如果没有此属性，依然可以跳转，但是切换时底部导航栏颜色不会改变 currentIndex: _curindex, //当点击底部按钮时，index会做出相应改变 onTap: (int index)&#123; //状态对象调用setState()，告诉框架重绘widget setState(() &#123; _curindex = index; &#125;); &#125;, ), ); &#125;&#125; message_page.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import 'package:flutter/material.dart';//定义拨号的页面class MessagePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( //头像 leading: Container( padding: EdgeInsets.all(10.0), //边距 child: CircleAvatar( backgroundImage: NetworkImage( \"https://cdn.jsdelivr.net/gh/cnatom/images/images/QQ图片20200108211847.jpg\"), ), ), title: Text(\"消息\"), //标题 centerTitle: true, //标题居中 //右侧图标 actions: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(10.0), child: Icon(Icons.camera_alt), //拍照 ), Container( padding: EdgeInsets.all(10.0), child: Icon(Icons.add), //加号 ), ], ), body: Column( children: &lt;Widget&gt;[ _tile(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/head.jpg\", \"张三\", \"好好学习，天天向上\"), _tile( \"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4027(20200125-154058).JPG\", \"李四\", \"新年快乐~\"), _tile( \"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4031(20200125-154126).JPG\", \"王五\", \"愿你遍历山河，依然觉得人生值得\"), _tile( \"https://cdn.jsdelivr.net/gh/cnatom/images/images/1F14065D991-4F4C-A2DB-D2996F183A92(20190930-003.JPG\", \"张伟\", \"去见你想见的人，趁阳光正好，趁微风不噪\") ], ), ); &#125;&#125;//单个聊天标签Widget _tile(String url, String title, String subtitle) &#123; return ListTile( leading: CircleAvatar( backgroundImage: NetworkImage(url), ), title: Text(title), subtitle: Text(subtitle), );&#125; contact_page.dart 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import 'package:flutter/material.dart';//定义联系人的页面class ContactPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( //头像 leading: Container( padding: EdgeInsets.all(10.0), //边距 child: CircleAvatar( backgroundImage: NetworkImage( \"https://cdn.jsdelivr.net/gh/cnatom/images/images/QQ图片20200108211847.jpg\"), ), ), title: Text(\"联系人\"), //标题 centerTitle: true, //标题居中 //右侧图标 actions: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(10.0), child: Icon(Icons.person_add), //加号 ), ], ), body: Column( children: &lt;Widget&gt;[ _tile(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/head.jpg\",\"张三\"), _tile(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4027(20200125-154058).JPG\", \"李四\",), _tile(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4031(20200125-154126).JPG\", \"王五\",), _tile(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/1F14065D991-4F4C-A2DB-D2996F183A92(20190930-003.JPG\", \"张伟\",) ], ), ); &#125;&#125;//单个联系人标签Widget _tile(String url, String title) &#123; return ListTile( leading: CircleAvatar( backgroundImage: NetworkImage(url), ), title: Text(title), );&#125; social.dart 1234567891011121314151617181920212223242526272829303132333435363738394041424344import 'package:flutter/material.dart';//定义动态的页面class SocialPage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( //头像 leading: Container( padding: EdgeInsets.all(10.0), //边距 child: CircleAvatar( backgroundImage: NetworkImage( \"https://cdn.jsdelivr.net/gh/cnatom/images/images/QQ图片20200108211847.jpg\"), ), ), title: Text(\"动态\"), //标题 centerTitle: true, //标题居中 //右侧图标 actions: &lt;Widget&gt;[ Container( padding: EdgeInsets.all(10.0), child: Icon(Icons.settings), //设置 ), ], ), body: Column( children: &lt;Widget&gt;[ _tile(Icon(Icons.star,color: Colors.orange,),\"好友动态\"), _tile(Icon(Icons.edit_location,color: Colors.pink,),\"附近\"), _tile(Icon(Icons.games,color: Colors.blue,),\"游戏\"), _tile(Icon(Icons.music_note,color: Colors.green,),\"音乐\"), ], ), ); &#125;&#125;//单个标签Widget _tile(Widget head,String title) &#123; return ListTile( leading: head, title: Text(title), );&#125;","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】返回页面数据","slug":"【Flutter之旅】返回页面数据","date":"2020-01-28T15:06:56.000Z","updated":"2020-05-03T04:46:43.586Z","comments":true,"path":"2020/01/28/【Flutter之旅】返回页面数据/","link":"","permalink":"https://cnatom.github.io/2020/01/28/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91%E8%BF%94%E5%9B%9E%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE/","excerpt":"返回页面数据","text":"返回页面数据 效果 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import 'package:flutter/material.dart';void main() &#123; runApp(MaterialApp( home: First(), ));&#125;class First extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"异步请求和等待\"), ), body: Center( child: MyButton() ), ); &#125;&#125;//单独声明按钮，否则SnackBar无效果class MyButton extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return RaisedButton( child: Text(\"Go\"), onPressed: ()&#123; _fun(context); &#125;, ); &#125;&#125;_fun(BuildContext context) async &#123;//异步处理 //await与async相伴 final result = await Navigator.push( context, // Create the SelectionScreen in the next step. MaterialPageRoute(builder: (context) =&gt; Second()), ); //移除上一个SnackBar Scaffold.of(context).removeCurrentSnackBar(); //生成一个SnackBar并把接收的信息展示 Scaffold.of(context).showSnackBar(SnackBar(content: Text(\"$result\"),));&#125;class Second extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(\"返回下列数据\"), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Center(child: RaisedButton( child: Text(\"阿腾木的小世界\"), onPressed: ()&#123; Navigator.pop(context,'阿腾木的小世界'); &#125;, )), Center(child: RaisedButton( child: Text(\"ccatom.com\"), onPressed: ()=&gt;Navigator.pop(context,\"ccatom.com\"), ) )], ), ) ); &#125;&#125;","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】导航参数的传递和接收","slug":"【Flutter之旅】导航参数的传递和接收","date":"2020-01-27T15:38:56.000Z","updated":"2020-05-03T04:46:28.739Z","comments":true,"path":"2020/01/27/【Flutter之旅】导航参数的传递和接收/","link":"","permalink":"https://cnatom.github.io/2020/01/27/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91%E5%AF%BC%E8%88%AA%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E5%92%8C%E6%8E%A5%E6%94%B6/","excerpt":"导航参数的传递和接收","text":"导航参数的传递和接收 效果 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import 'package:flutter/material.dart';void main()=&gt;runApp(MaterialApp( title: \"导航参数的传递和接收\", home: First(),));class First extends StatelessWidget&#123; //生成0-19的列表 List&lt;int&gt; i = new List.generate(20, (m)=&gt;m); @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( title: Text(\"导航参数的传递和接收\"), ), //若干列表用builder方法生成 body: ListView.builder( //列表的数量 itemCount: 20, //列表生成（index从0到19） itemBuilder: (context,index)&#123; //每一个列表都是一个ListTile return ListTile( title: Text(\"The square of $&#123;i[index]&#125;\"), //点击ListTile时 onTap: ()&#123; Navigator.push(context, MaterialPageRoute( //用Second类的构造函数传递参数 builder: (context)=&gt; new Second(temp: i[index],) )); &#125;, ); &#125;, ), ); &#125;&#125;class Second extends StatelessWidget&#123; //创建临时int对象接收参数 int temp; //Second用来接收参数的构造函数 Second(&#123;Key key,this.temp&#125;):super(key: key); @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( title: Text(\"The square of $&#123;temp&#125;\"), ), body: Center(child: Text(\"$&#123;temp*temp&#125;\",style: TextStyle(fontSize: 30.0),)), ); &#125;&#125;","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】中看不中用的新手作","slug":"【Flutter之旅】中看不中用的新手作","date":"2020-01-25T11:36:56.000Z","updated":"2020-05-03T04:46:12.002Z","comments":true,"path":"2020/01/25/【Flutter之旅】中看不中用的新手作/","link":"","permalink":"https://cnatom.github.io/2020/01/25/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91%E4%B8%AD%E7%9C%8B%E4%B8%8D%E4%B8%AD%E7%94%A8%E7%9A%84%E6%96%B0%E6%89%8B%E4%BD%9C/","excerpt":"中看不中用的新手作","text":"中看不中用的新手作 效果 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import 'package:flutter/material.dart';//每个壁纸的配置（方便批量处理）Widget netpic(String str)&#123; return Container( //BoxDecoration添加圆角图片 decoration: BoxDecoration( borderRadius: BorderRadius.circular(10.0),//弧度值 image: DecorationImage( image: NetworkImage(str) ) ), );&#125;//用GridView排列壁纸排列class MyGridView extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3,//三列 mainAxisSpacing: 10.0,//主轴间距 crossAxisSpacing: 10.0,//幅轴间距 childAspectRatio: 0.56//长宽比 ), children: &lt;Widget&gt;[ netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/20200125154145.JPG\"), netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4031(20200125-154126).JPG\"), netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4025(20200125-154040).JPG\"), netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/1F14065D991-4F4C-A2DB-D2996F183A92(20190930-003.JPG\"), netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/BC058F5D-0A-4764-8276-59F809F3A8FF(20190805-043.JPG\"), netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4030(2020012554121).JPG\"), netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4023(202154029).JPG\"), netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/E231DF43-98AB-1407A29E3A1B(20190218-090.JPG\"), netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_4027(20200125-154058).JPG\") ], ); &#125;&#125;//首页class First extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( title: Text(\"我的壁纸\"), backgroundColor: Colors.pinkAccent,//应用栏背景页 ), //右下角悬浮按钮 floatingActionButton: FloatingActionButton( backgroundColor: Colors.pinkAccent, child: Icon(Icons.favorite), //Navigator.push跳转 onPressed: ()&#123; Navigator.push(context, new MaterialPageRoute( builder: (context)=&gt;new Favourite() )); &#125;, ), //导入壁纸排列 body: new MyGridView(), ); &#125;&#125;//第二页class Favourite extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return Scaffold( appBar: AppBar( //应用栏返回按钮 //Navigator.pop返回 leading: IconButton(icon: Icon(Icons.arrow_back), onPressed: ()&#123;Navigator.pop(context);&#125;), title: Text(\"我的最爱\"), backgroundColor: Colors.pinkAccent, ), backgroundColor: Colors.black, body: Center(child: netpic(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/IMG_1932(20200120-1.JPG\"),), ) ; &#125;&#125;//主函数调用void main()&#123; runApp(new MaterialApp( title: \"GridView组件\", home: new First(), ));&#125;","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】Column垂直布局","slug":"【Flutter之旅】Column垂直布局","date":"2020-01-23T11:36:56.000Z","updated":"2020-05-03T04:45:58.115Z","comments":true,"path":"2020/01/23/【Flutter之旅】Column垂直布局/","link":"","permalink":"https://cnatom.github.io/2020/01/23/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91Column%E5%9E%82%E7%9B%B4%E5%B8%83%E5%B1%80/","excerpt":"各种布局形式","text":"各种布局形式 Column垂直布局 效果 源代码1234567891011121314151617181920212223242526272829303132import 'package:flutter/material.dart';void main()=&gt;runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: \"ccatom\", home: Scaffold( //应用栏 appBar: AppBar( title: Text(\"使用Column垂直布局\"), ), body: Column( //主轴对齐方式：居中 //如果用column，那么垂直就是主轴 mainAxisAlignment: MainAxisAlignment.center, //幅轴对齐方式：右对齐 //幅轴与主轴垂直 crossAxisAlignment: CrossAxisAlignment.end, children: &lt;Widget&gt;[ Center(child:Image.network(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/logo.png\",fit: BoxFit.fitWidth,)), //使用Expanded灵活布局 Expanded(child:Image.network(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/logo.png\",fit: BoxFit.fitWidth,)), Center(child:Image.network(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/logo.png\",fit: BoxFit.fitWidth,)),// Center(child:Text('I love coding')) ], ), ), ); &#125;&#125; Row水平布局 效果 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243import 'package:flutter/material.dart';void main()=&gt;runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: \"ccatom\", home: Scaffold( //应用栏 appBar: AppBar( title: Text(\"使用Row水平布局\"), ), body: Row( mainAxisAlignment: MainAxisAlignment.spaceAround, crossAxisAlignment: CrossAxisAlignment.end, children: &lt;Widget&gt;[ Center( child: RaisedButton( child: Text(\"“漂浮”按钮\"), onPressed: ()&#123;&#125;, ), ), Center( child:RaisedButton( child: Text(\"“漂浮”按钮\"), onPressed: ()&#123;&#125;, ) ), Center( child: RaisedButton( child: Text(\"“漂浮”按钮\"), onPressed: ()&#123;&#125;, ), ) ], ), ), ); &#125;&#125; Stack层叠布局 效果 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import 'package:flutter/material.dart';void main()=&gt;runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: \"ccatom\", home: Scaffold( //应用栏 appBar: AppBar( title: Text(\"Stack层叠布局\"), ), body: Stack( //居中对齐 alignment: Alignment.center, //添加层叠部件 children: &lt;Widget&gt;[ //最底层的部件 //创建一个圆角头像 Center( child: new CircleAvatar( radius: 150.0, backgroundImage: NetworkImage(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/QQ图片20200108211847.jpg\"), ), ), //在圆角头像上面添加容器 Container( child: Text( \"阿腾木的小世界\", style: TextStyle( color: Colors.white, fontSize: 30, //字间距 letterSpacing: 10, //添加阴影 shadows: [Shadow(color: Colors.blue,blurRadius: 10)] ), ), ), //使用Positioned组件进行多组件布局 Positioned( //距离层叠组件下边的距离：240 bottom: 240, child: Text( \"ccatom.com\", style: TextStyle( color: Colors.white, fontSize: 20, shadows: [Shadow(color: Colors.blue,blurRadius: 10)] ), ), ) ], ), ), ); &#125;&#125; Card卡片组件布局 效果 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context)&#123; //单独声明Card组件 Card card = new Card( //添加垂直布局 child: Column( children: &lt;Widget&gt;[ //用ListTile实现内部列表 ListTile( //添加首部图片 leading: CircleAvatar( backgroundImage: NetworkImage(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/head.jpg\"), ), //主标题 title: Text(\"张三\"), //副标题 subtitle: Text(\"这就是flutter吗，i了i了\"), ), //添加分隔线 Divider(thickness: 0.5), ListTile( leading: CircleAvatar( backgroundImage: NetworkImage(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/QQ图片20200108211847.jpg\"), ), title: Text(\"李四\"), subtitle: Text(\"不愧是你\"), ), Divider(), ListTile( leading: CircleAvatar( backgroundImage: NetworkImage(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/20200123235514.jpg\"), ), title: Text(\"王五\"), subtitle: Text(\"珍爱生命，远离瘟疫\"), ), Divider(), ], ), ); return MaterialApp( home: Scaffold( appBar: AppBar( title: Text(\"使用Card卡片布局\"), ), body: Center( child: card, ), ), ); &#125;&#125;","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【Flutter之旅】Container容器组件初试","slug":"【Flutter之旅】Container容器组件初试","date":"2020-01-22T11:36:56.000Z","updated":"2020-05-03T04:45:25.709Z","comments":true,"path":"2020/01/22/【Flutter之旅】Container容器组件初试/","link":"","permalink":"https://cnatom.github.io/2020/01/22/%E3%80%90Flutter%E4%B9%8B%E6%97%85%E3%80%91Container%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%E5%88%9D%E8%AF%95/","excerpt":"Container容器组件初试","text":"Container容器组件初试 效果 源代码12345678910111213141516171819202122232425262728import 'package:flutter/material.dart';void main () =&gt; runApp(MyApp());class MyApp extends StatelessWidget&#123; @override Widget build(BuildContext context )&#123; return MaterialApp( title:'Text widget', home:Scaffold( body:Center( child: Container( child: new Image.network(\"https://cdn.jsdelivr.net/gh/cnatom/images/images/logo.png\"), alignment: Alignment.topLeft, padding: EdgeInsets.fromLTRB(0.0, 100.0, 0.0, 0.0), margin: EdgeInsets.all(10.0), decoration: BoxDecoration( border: Border.all(width: 10,color: Colors.lightBlueAccent), gradient:LinearGradient( colors: [Colors.blue,Color.fromARGB(100,34,153,244)], begin: AlignmentDirectional.bottomEnd, ) ), ), ), ) ); &#125;&#125;","categories":[{"name":"Flutter移动之旅","slug":"Flutter移动之旅","permalink":"https://cnatom.github.io/categories/Flutter%E7%A7%BB%E5%8A%A8%E4%B9%8B%E6%97%85/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://cnatom.github.io/tags/flutter/"}]},{"title":"【java】异常和 try / catch","slug":"【java】异常和-try-catch","date":"2020-01-20T14:00:33.000Z","updated":"2020-01-27T16:29:56.696Z","comments":true,"path":"2020/01/20/【java】异常和-try-catch/","link":"","permalink":"https://cnatom.github.io/2020/01/20/%E3%80%90java%E3%80%91%E5%BC%82%E5%B8%B8%E5%92%8C-try-catch/","excerpt":"","text":"基本语句 12345678910111213public static void main(String[] args) &#123; try &#123; process1(); process2(); process3(); &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"Bad encoding\"); &#125; catch (IOException | NumberFormatException e) &#123; System.out.println(\"IO error\"); &#125; finally &#123; System.out.println(\"END\"); &#125;&#125; 因为处理IOException和NumberFormatException的代码是相同的，所以我们用 | 将他们合并到一起。在try-catch语句内所声明的变量的作用域在语句块内部，外部不可见。finally语句不是必须的，可写可不写；finally总是最后执行。 Java异常类的继承关系图 一个栗子 在这里故意写一个异常语句1/0. 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; String a = \"12\"; String b = \"x9\"; // TODO: 捕获异常并处理 int c = stringToInt(a); int d = stringToInt(b); System.out.println(c * d); &#125; static int stringToInt(String s) &#123; return Integer.parseInt(s); &#125;&#125; 编译正常，运行时抛出异常： 123456Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;x9&quot; at java.base&#x2F;java.lang.NumberFormatException.forInputString(NumberFormatException.java:68) at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:658) at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:776) at Test.stringToInt(Test.java:35) at Test.main(Test.java:30) 可以看出是NumberFormatException异常，这时候就可以用try-catch捕获该异常。 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; String a = \"12\"; String b = \"x9\"; int c = stringToInt(a); int d;//变量声明要在try-catch语句外面 try &#123; d = stringToInt(b); &#125; catch (NumberFormatException e) &#123; b = \"19\"; d = stringToInt(b); &#125; System.out.println(c * d); &#125; static int stringToInt(String s) &#123; return Integer.parseInt(s); &#125;&#125;&#125; 会先执行try语句，抛出NumberFormatException异常后，系统会选择性的执行catch语句。这有点像switch语句。 使用try … catch … finally时： 多个catch语句的匹配顺序非常重要，子类必须放在前面； finally语句保证了有无异常都会执行，它是可选的； 一个catch语句也可以匹配多个非继承关系的异常","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://cnatom.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"https://cnatom.github.io/tags/java/"}]},{"title":"【数据结构】树的存储结构","slug":"【数据结构】树的存储结构","date":"2020-01-20T12:13:46.000Z","updated":"2020-01-27T16:30:21.669Z","comments":true,"path":"2020/01/20/【数据结构】树的存储结构/","link":"","permalink":"https://cnatom.github.io/2020/01/20/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/","excerpt":"图源：鱼C-小甲鱼","text":"图源：鱼C-小甲鱼 孩子表示法方案一 方案二 双亲表示法方案一 方案二 双亲孩子表示法 具体实现12345678910111213141516171819202122#define MAX_TREE_SIZE 100typedef char ElemType;//孩子结点typedef struct CTNode&#123; int child; //孩子结点的下标 struct Node *next; //指向下一个孩子结点的指针&#125;*ChildPtr;//表头结构typedef struct&#123; ElemType data; //存放在树中的结点的数据 int parent; //存放双亲的下标 ChildPtr firstchild; //指向第一个孩子的指针&#125;CTBox;//树结构typedef struct&#123; CTBox nodes[MAX_TREE_SIZE];//结点数组 int r; //根的位置 int n; //结点数&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://cnatom.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cnatom.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"【Java】警告：The constructor Integer(int) is deprecated since version 9","slug":"Java不推荐用包装类构造函数","date":"2020-01-16T06:30:33.000Z","updated":"2020-01-27T16:30:43.591Z","comments":true,"path":"2020/01/16/Java不推荐用包装类构造函数/","link":"","permalink":"https://cnatom.github.io/2020/01/16/Java%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"从jdk1.9开始就不建议用Integer构建包了","text":"从jdk1.9开始就不建议用Integer构建包了 查询文档的解释:官方推荐使用ValueOf方法来构建包。 Integer obj = new Integer(1024);Integer obj = Integer.valueOf(1024);","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://cnatom.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"java","slug":"java","permalink":"https://cnatom.github.io/tags/java/"}]},{"title":"【Java】错误：编码 GBK 的不可映射字符 (0x8C)","slug":"Java输出中文字符的问题","date":"2020-01-15T16:08:00.000Z","updated":"2020-01-27T16:30:49.271Z","comments":true,"path":"2020/01/16/Java输出中文字符的问题/","link":"","permalink":"https://cnatom.github.io/2020/01/16/Java%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"关于Java中输出中文字符的问题","text":"关于Java中输出中文字符的问题 今天在写Java学习笔记的时候发现的问题。 12345public class Test&#123; public static void main(String[] args)&#123; System.out.println(\"阿腾木的小世界\"); &#125;&#125; 我在java中用syso输出中文字符但是在用javac -d命令编译上述源代码总会出现 错误：编码 GBK 的不可映射字符 (0x8C)上网搜了搜网上的解释： 由于JDK是国际版的，我们在用javac编译时，编译程序首先会获得我们操作系统默认采用的编码格式（GBK），然后JDK就把Java源文件从GBK编码格式转换为Java内部默认的Unicode格式放入内存中，然后javac把转换后的Unicode格式的文件编译成class类文件，此时，class文件是Unicode编码的，它暂存在内存中，紧接着，JDK将此以Unicode格式编码的class文件保存到操作系统中形成我们见到的class文件。当我们不加设置就编译时，相当于使用了参数：javac -encoding GBK Test.java，就会出现不兼容的情况。 解决方法：使用-encoding参数指明编码方式：javac -encoding UTF-8 Test.java，就可以了。","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://cnatom.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"java","slug":"java","permalink":"https://cnatom.github.io/tags/java/"}]},{"title":"【Java】学习笔记（语言基础及面向对象）","slug":"【Java】学习笔记（语言基础及面向对象）","date":"2020-01-14T07:06:16.000Z","updated":"2020-04-21T03:03:28.163Z","comments":true,"path":"2020/01/14/【Java】学习笔记（语言基础及面向对象）/","link":"","permalink":"https://cnatom.github.io/2020/01/14/%E3%80%90Java%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%89/","excerpt":"QAQ寒假flag屹立不倒~","text":"QAQ寒假flag屹立不倒~ Java语言概述 Java虚拟机(JVM : Java Virtual Machine)java语言里负责解释执行字节码文件，是运行Java字节码文件的虚拟计算机。当使用Java编译器编译Java程序时，生成的是与平台无关的字节码，这些字节码不面向任何具体平台，只面向JVM。不同平台上的JVM都是不同的，但他们都提供了相同的接口。 Java标准化开发包(JDK : Java SE Development Kit)提供了编译、运行Java程序所需的各种工具和资源（包括Java编译器、Java运行时环境以及常用的Java类库等） Java运行时环境(JRE : Java Runtime Enviroment)JRE与JVM的关系：JRE包含JVM，JVM是运行Java程序的核心虚拟机，而运行Java程序不仅需要核心虚拟机，还需要其他的类的加载器、字节码校验器以及基础类库。JRE除包含JVM之外，还包含运行Java程序的其他环境支持。 计算机如何查找命令？（设置环境变量的原因）Windows根据Path环境变量来查找命令，Path环境变量的值是一系列路径，系统会根据这一系列路径中依次查找命令。如果能找到这个命令，则执行；如果找不到这个命令，就会出现：’xxx’不是内部或外部命令，也不是可运行的程序或批处理文件。 关于CLASSPATH如果使用1.4以前版本的JDK，需要设置CLASSPATH环境变量的值为.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar一旦设置了该环境变量，JRE将会按照该环境变量指定的路径来搜索Java类。点( . )代表当前路径，用以强制Java解释器在当前路径下搜索Java类。 Java源文件的命名规则如果Java源程序的源代码里定义了一个public类，则该源文件的主文件名必须与public类的类名相同。（因此，一个Java源文件内最多只能有一个public类）如果一个源文件内有3个类，则使用javac命令编译会生成3个.class文件，每一个类对应一个.class文件。 提高可读性的建议 一个Java源文件通常只定义一个类，不同的类使用不同的源文件定义。 让Java源文件的主文件名与该源文件中定义的public类同名。 垃圾回收（Garbage Collection , GC）JRE回收无用内存的机制。通常JRE会提供一个后台线程来进行检测和控制，一般都是在CPU空闲或内存不足时自动进行垃圾回收。 Java的堆内存是一个运行时数据区，用以保存类的实例。堆内存中存储着在运行的应用程序所建立的所有对象，这些对象不需要程序通过代码来显式地释放。堆内存的回收由垃圾回收器来负责，所有的JVM实现都有一个由垃圾回收器管理的堆内存。数据类型和运算符自动提升规则 byte -&gt; short&amp;char -&gt; int -&gt; long -&gt; float -&gt; double 所有的byte、short和char类型都将被提升到int类型。123short value = 5;value = value - 2;//这里的value-2被自动提升到int类型，int赋给short可能会报错 整个算数表达式的数据类型自动提升到与表达式中最高等级操作数相同的类型 123456byte b = 40;var c = 'a';var i = 23;var d = .314;double ans = b + c + i * d;System.out.print(ans);//输出7 直接量是指在程序中通过源代码直接给出的值。 123int a = 1; //1是直接量double b = 2.0; //2.0是直接量String name = \"MJT\"; //\"MJT\"是直接量 String类的直接量不能赋给其他类型的变量。null类型的直接量可以直接赋给任何引用类型的变量，包括String类型。boolean类型的直接量只能赋给boolean类型的变量，不能赋给其他任何类型的变量。 常量池指的是在编译器被确定，并保存在已编译的.class文件中的一些数据。包括关于类、方法、接口中的常量，也包括字符串中的直接量。 1234//下面的\"hello\"都在常量池中储存var s1 = \"hello\"; var s2 = \"hello\";var s3 = \"he\" + \"llo\"; Java确保每个字符串常量只有一个，不会产生多个副本。因此，上面那三个”hello”在常量池中是同一块数据。 位运算 运算符 名称 功能 &amp; 按位与 同时为1时返回1 &#124; 按位或 只要有一位为1则返回1 ~ 按位非 单目运算符，用来取反。 ^ 按位异或 当两位相同时返回0，不同时返回1 &lt;&lt; 左移运算符 右侧补0。左侧超出截断 &gt;&gt; 右移运算符 原来是正数，则左边补零;原来是复数，则左边补1。右侧超出截断 &gt;&gt;&gt; 无符号右移运算符 左侧总是补零。右侧超出截断 n&gt;&gt;x相当于n乘以2的x次方。n&lt;&lt;x相当于n除以2的x次方。 数组类型 静态初始化 : 显式指定初始值，系统决定数组长度。12345//第一种方式int[] arr;arr = new int[] &#123;1,2,3&#125;;//第二种方式（推荐）var arr = new int[] &#123;1,2,3&#125;; 动态初始化 : 显式指定长度，系统分配初始值。1234//第一种方式int[] arr = new int[10];//第二种方式（推荐）var arr = new int[10]; 动态初始化分配规则 数组元素类型 自动分配的值 整数类型 0 浮点类型 0.0 字符型(char) ‘\\u0000’ 布尔类型 false 引用类型(类，接口，数组） null foreach循环以遍历数组元素为例 1234var arrs = new int[] &#123;1,2,3&#125;;for (int arr : arrs) &#123; System.out.println(arr);&#125; 使用foreach循环迭代数组元素时，并不能改变数组元素的值，因此不应用foreach的循环变量进行赋值。 深入数组Java中“数组元素”和“数组变量（引用变量）”在内存中是分开存放的。举个栗子： 1int[] p;//定义一个局部变量 这里的p是一个引用变量，作为局部变量被存储在栈内存中。相当于C++中的指针，指向一个int元素的内存。 1p = new int[] &#123;1,2,3&#125;; 实际的数组元素{1,2,3}被存储在被new开辟的一块堆内存中，p = new int[] {1,2,3};则让p引用变量指向该堆内存。 二维数组12345//动态初始化方式int[][] arr;arr = new int[2][];//静态初始化方式int[][] arr = new int[][] &#123;new int[2],new int[]&#123;1,2,3&#125;&#125;; 这个二维数组实际上完全可以看作是一维数组：使用new int[4]初始化一维数组后，相当于定义了4个int类型的变量；类似的，使用new int[4][]初始化这个数组后，相当于定义了4个int[]类型的变量，这些int[]类型的变量都是数组类型，因此必须再次初始化这些数组。 面向对象（上）关于static的问题为什么静态成员（类成员）不能直接访问非静态成员（对象成员）？ 先了解几个书中的基本概念 主调：调用成员变量、方法的对象称为主调。如：主调.方法(); 基本概念（1）：如果调用static修饰的成员时忽略了主调，那么默认使用该类作为主调。 123//在调用static方法时下列两种形式相同。static_fun();ClassName.static_fun(); 基本概念（2）：如果调用没有static修饰的成员时忽略了主调，那么默认使用this作为主调。 123//调用普通成员时下列两种形式相同。fun();this.fun(); 基本概念（3）：this指向本类的实例，而static成员是属于类的，因此static成员内不能使用this。 如果在静态成员中调用普通成员，会发生什么？ 举个栗子： 12345678910111213public class test&#123; public void show() &#123; System.out.println(\"HelloWorld\"); &#125; public static void main(String[] args) &#123; show(); &#125;&#125;===============运行结果=================错误: 无法从静态上下文中引用非静态 方法 show() 这对应基本概念（2），这里调用的是一个普通成员函数show，则默认使用this作为主调。这里相当于this.show();但show()只能通过对象来访问，而static方法是属于类的，在static内的this不知道该指向哪一个实例，因此show()无法在main方法中被调用。 如果确实想在static方法中调用非static方法，可以临时创建一个对象： 123456789101112public class test&#123; public void show() &#123; System.out.println(\"HelloWorld\"); &#125; public static void main(String[] args) &#123; //创建一个临时对象来调用临时对象中的show方法。 new test().show(); &#125;&#125; 方法的参数传递机制Java参数的传递机制只有一种：值传递 对于引用类型的参数传递，一样采用的是值传递方式。但是这里的“值”，是地址值。比如： 1234567891011121314151617181920class Data&#123; int num1=1; int num2=2;&#125;public class Test&#123; public static void swap(Data p) &#123; var temp = p.num1; p.num1 = p.num2; p.num2 = temp; &#125; public static void main(String[] args) &#123; Data a; //定义一个Data类型的引用 a = new Data(); //a引用指向一块用new新开辟的一块Data内存空间。 swap(a); //值传递，p接受a的地址值，使得p与a存储着相同的地址值。 System.out.println(a.num1 + \" \" + a.num2); &#125;&#125; 形参个数可变的方法方法：在最后一个形参类型后加三个点 (Typename… name) 12345678910111213141516public class Test&#123; public static void fun(int num,String... books) &#123; for (String string : books) &#123; System.out.println(string); &#125; &#125; public static void main(String[] args) &#123; //可直接罗列参数 fun(3,\"Java\",\"C++\",\"Python\"); //也可将String...看做String[]，传递一个数组进去。 fun(3,new String[] &#123;\"Java\",\"C++\",\"Python\"&#125;); &#125;&#125; 必须将Typename…形参放在在最后一个位置，否则会报错。 成员变量和局部变量 成员变量：在类内定义的变量。无需显式初始化，系统自动初始化。 局部变量：在方法内定义的变量。需要显式初始化。 成员变量的初始化和内存中的运行机制当系统加载类或创建该类的实例时，系统会自动为成员变量分配内存空间。 举个栗子：比如说我们有一个类 1234class Person&#123; public static int eyeNum; public String name;&#125; 1）如果在主函数中第一次加载这个类： 1new Person(); 会初始化Person类，只初始化静态变量（类变量）↑ 2）然后创建一个Person类型的对象 1var p1 = new Person(); 创建一个Person对象时并不需要为eyeName类变量分配内存系统只为name实例变量分配了内存空间 3）再创建第二个Person类对象 12var p2 = new Person();p2.name = \"张三\"; 系统只为第二个对象的对象成员分配了内存空间 局部变量的初始化和内存中的运行机制12int a; //系统并未分配空间a = 1; //赋值时才分配空间 局部变量不属于任何类或实例，因此它总是保存在其所在方法的栈内存中 因为局部变量只保存基本类型的值或者对象的引用，因此局部变量所占的内存区通常比较小 访问控制符 private default protected public 同一个类中 √ √ √ √ 同一个包中 √ √ √ 子类中 √ √ 全局范围内 √ 局部变量不能用用访问控制符修饰 工具方法 只用于辅助该类的其他方法的方法。也应该用private修饰 package包机制几个知识点 包机制用于解决类的重名冲突，类文件的管理。 按照规范，包名最好小写字母。 应该使用域名的倒写，如com.ccatom包。 package语句必须作为源文件的第一条非注释语句。 一个源文件只能指定一个包 同一个包下的类可以直接访问 通常建议将class文件与java源文件分开放。 特别注意的是：父包内的类使用子包中的类，必须写类的完整包路径加类名。 比如com.ccatom包下有一个类A，com.ccatom.child包下有一个类B。类A使用类B必须要有com.ccatom.child.B，就像以下形式。 1com.ccatom.child.B obj = new com.ccatom.child.B(); 一个使用包机制的示例1234567//定义一个子包的类package com.ccatom.child;public class B&#123; public static void show()&#123; System.out.println(\"Hello Package\"); &#125;&#125; 12父包类要用子包类，因此先编译子包源文件：javac -d . B.java发现在以下目录出现了class文件：当前目录\\com\\ccatom\\child\\B.class 123456789//再定义一个使用子包类的父包类package com.ccatom;public class A&#123; public static void main(String[] args)&#123; //使用完整的名称来使用子类包 com.ccatom.child.B obj = new com.ccatom.child.B(); obj.show(); &#125;&#125; 12编译父包类源文件：javac -d . A.java发现在以下目录出现了class文件：当前目录\\com\\ccatom\\A.class 12运行父类包：java com.ccatom.A输出Hello Package 如果编译Java文件时不使用-d选项，编译器不会为Java源文件生成相应的文件结构。 import关键字import关键字用来简化上述源代码，简化以前： 1234567package com.ccatom;public class A&#123; public static void main(String[] args)&#123; com.ccatom.child.B obj = new com.ccatom.child.B(); obj.show(); &#125;&#125; 使用import直接导入类B，简化之后： 1234567package com.ccatom;import com.ccatom.child.B;//import导入子包类Bpublic class A&#123; public static void main(String[] args)&#123; B obj = new B(); //简化了此处的操作 obj.show(); &#125; 如果想导入某个包下所有的类，则可以这样写： 1import com.ccatom.*; //导入了com.ccatom包下的所有的类 JDK 1.5以后可以进行“静态导入”，用来导入指定类的某个静态成员变量或方法。如，导入com.ccatom包中类A的静态方法fun() ： 1import static com.ccatom.A.fun; 也可以导入类A中所有的静态成员： 1import static com.ccatom.A.*; 1.import语句应该出现在package语句之后、类定义之前。2.Java默认为所有源文件导入java.lang包下所有的类，因此可以直接使用String和System类。使用import可以省略包名；而使用import static则可以连类名都省略。 Java常用包 包 含有 例如 java.lang 核心类（无需导入） String、Math、System、Thread java.util 工具类/接口和集合框架类/接口 Arrays、List、Set java.net 网络编程相关 - java.text 输入输出的类/接口 - java.sql JDBC数据库编程的相关类/接口 - java.awt 抽象窗口工具集，用于构建GUI - java.swing Swing GUI编程的相关类 - Java构造器类似于C++中的构造函数 12345678910111213public class Test&#123; public String name; public int age; //一个简单的构造器，用来初始化name和age public Test(String name,int age)&#123; this.name = name; this.age = age; &#125; public static void main(String[] args)&#123; Test obj = new Test(\"MJT\",20); System.out.println(obj.name+\" \"+obj.age); &#125;&#125; 不能说Java对象完全由构造器负责创建：在调用构造器之前，系统就已经为对象分配内存空间，并为这个对象执行默认初始化，这个对象就已经产生了。只是这个对象不能被外部访问，只能通过内部构造器的this来引用。 同时，上述代码自定义了一个有参的构造器，这时就不能再用new Test();来创建实例，因为类中没有无参构造器。因此需要进行构造器重载（同一个类里具有多个构造器，各构造器的形参列表不同） 123//上述类中重载一个无参的构造器//就可以用new Test();来创建实例了public Test()&#123;&#125; 同一个类的构造器之间的调用 一种方法是在构造器中用new关键字来调用另一个构造器，但会重新创建一个对象，占用资源。因此，对于含有包含关系的构造器来讲，就要用this调用另一个重载的构造器 1234567public Test(String name)&#123; this.name = name;&#125;public Test(String name,int age)&#123; this(name);//用this调用重载的构造器 this.age = age;&#125; 这里需要注意的是： 使用this调用另一个重载的构造器只能在构造器中使用； 必须作为构造器执行体的第一行语句； 类的继承比如B类以public方式继承A类： 1public B extends A&#123;......&#125; 需要注意的一些小知识： Java摒弃了多继承特征，Java类只能有一个直接父类； 为显式指定父类，则默认父类java.lang.Object,java。因此，java.lang.Object类是所有类的父类； 构造器不能被继承； 从子类角度看，子类扩展（extends）了父类； 从父类角度看，父类派生（derive）出了子类； 重写父类的方法方法重写（override）：子类包含父类同名方法的现象。又称方法覆盖 123456789101112131415class A&#123; public void fun()&#123; System.out.println(\"A_fun\"); &#125;&#125;public class B extends A&#123; //重写父类A中的方法fun public void fun()&#123; System.out.println(\"B_fun\"); &#125; public static void main(String[] args)&#123; B obj = new B(); obj.fun();//输出B_fun &#125;&#125; 静态方法与非静态方法不能互相重写 如果父类中有一个private方法，则在子类中定义一个同名方法不构成重写，如： 123456789class A&#123; //父类中的方法定义为private private void fun()&#123;...&#125;&#125;class B extends A&#123; //这里可以用static限定，因为不属于重写。 //所定义的fun是子类的新方法 public static void fun()&#123;...&#125;&#125; super限定如果需要在子类中调用父类中被重写的方法，可以用super限定作为主调来调用被覆盖的方法。比如 12345678910111213141516class A&#123; public int a = 1;&#125;public class B extends A&#123; public int a = 2; public void show_a_in_A()&#123; //在子类方法中用super来调用父类的实例变量a System.out.println(super.a); &#125; public static void main(String[] args)&#123; //尽管父类的a被子类的a覆盖 //但是new B();的时候依然会为父类中的a开辟一块内存 B obj = new B(); obj.show_a_in_A();//输出1 &#125;&#125; 需要注意的小知识： 可以将super与this相似看待，super不能出现在static修饰的方法中； 并不是完全覆盖，系统在创建子类对象时，依然会为父类中定义的、被隐藏的变量分配内存空间； 重载（overload）与重写（override）重载：发生在同一个类的多个同名方法之前。重写：发生在子类和父类的同名方法之间。 也有例外：如果子类中定义一个与父类方法有相同的方法名，但参数列表不同的方法，就会形成父类方法和子类方法的重载。 子类调用父类的构造器同一个类，在一个构造器中调用另一个构造器使用this调用来完成。类似的，在子类构造器中调用父类的构造器用super调用来完成。 1234567891011121314151617class A&#123; private String name; public A(String n)&#123; name = n; &#125;&#125;public class B extends A&#123; private int age; public B(String n,int a)&#123; //使用super限定来调用父类的构造器 super(n) age = a; &#125; public static void main(String[] args)&#123; B obj = new B(\"MJT\",20); &#125;&#125; 需要注意的小知识： super调用父类构造器时也必须出现在构造器执行体的第一行（因此this调用与super调用不会同时出现） 当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行。 super调用不能用在static方法内（构造器不属于类，也不可能用static修饰） 多态 多态：相同类型的变量，调用同一个方法时呈现出多种不同的行为特征的现象。 编译时类型：由声明变量的类型决定，如 String s ,那么String就是编译时类型。 运行时类型：由实际赋给该变量的对象决定，如var s = new String()； ，那么String就是运行时类型。 向上转型（upcasting）：将一个子类对象直接赋给一个父类引用变量 如果编译时类型和运行时类型不一致，就可能出现多态类似的形式： 编译时类型 变量名 = new 运行时类型(); 这种类型的多态分为两种情况： 首先是重写成员的情况：先上结论： 解释一下图表：变量名.重写方法(); 调用的是执行运行时类型的方法，也就相当于变量名.执行运行时类型的方法(); 以代码为例： 123456789101112131415161718192021class Father&#123; //这里的num与show对应图表中的“重写实例变量”与“重写方法” public int num = 1; public void show()&#123; System.out.println(\"Father_show_override\"); &#125;&#125;public class Child extends Father&#123; //子类中重写num实例变量 public int num = 3; //子类中重写show方法 public void show()&#123; System.out.println(\"Child_show_override\"); &#125; public static void main(final String[] args)&#123; final Father obj = new Child(); obj.show();//调用重写的show方法 System.out.println(obj.num);//输出重写的num实例变量 &#125;&#125; 然后是特有成员的情况（子类有，父类没有 或 父类有子类没有）结论：代码为例： 12345678910111213141516171819202122232425class Father&#123; //父类中特有的实例变量 public int father_num = 2; //父类中特有的方法 public void father_fun()&#123; System.out.println(\"Father_fun\"); &#125;&#125;public class Child extends Father&#123; //子类中特有的实例变量 public int child_num = 4; //子类中特有的方法 public void child_fun()&#123; System.out.println(\"Child_fun\"); &#125; public static void main(final String[] args)&#123; final Father obj = new Child(); obj.father_fun();//调用父类中特有的方法 System.out.println(obj.father_num);//输出父类中特有的实例变量 obj.child_fun();//调用子类中特有的方法，报错 System.out.println(obj.child_num);//输出子类中特有的实例变量，报错 &#125;&#125; instanceof运算符 使用：双目运算符。前一个操作数通常是一个引用类型变量，后一个操作数通常是一个类（或接口）。 作用：用来判断前面的对象是否是后面的类或其子类（是返回true，不是则返回false）。 应用：一般用于强制类型转换（向上或向下转型）的情景。 例如：如果试图将一个父类实例强制转换为子类类型，则这个对象必须是子类实例才行（即编译时类型是父类类型，而运行时类型是子类类型）否则将在运行时引发ClassCastException异常。 通常情况下instanceof和(type)运算符搭配使用：通常先用instanceof判断一个对象是否可以强制类型转换，然后再使用(type)运算符进行强制类型转换，从而保证程序不会出现错误。 举个栗子： 12345//如果obj是String类或其子类if(obj instanceof String)&#123; //那么就可以将obj对象类型强制转换为同类或其父类类型 var str = (String)obj;&#125; 使用继承的注意点 尽量隐藏父类的内部数据，用private修饰符。 不要让子类可以随意访问、修改父类的方法。工具方法应该用private修饰；需要被外部类调用，就用public修饰，但又不想子类重写该方法，就再加一个final修饰符；如果希望某个方法被子类重写，又不想被其他类访问，就用protected修饰符。 尽量不要在父类构造器中调用将要被子类重写的方法。 组合 对于继承：子类可以直接获得父类的public方法。 而对于组合：把旧类对象作为新类的成员变量组合起来，用以实现新类的功能。 举个栗子： 1234567891011121314151617181920class A&#123; public void fun_A()&#123; System.out.println(\"Hello_World\"); &#125;&#125;class B&#123; //将旧类A的对象a作为新类B的成员变量组合起来。 //这里用private，是因为我们想让用户看到的只是旧类的方法，而不是旧类对象。 private A a = new A();//组合 public void fun_A_in_B()&#123; //从而可以在新类方法内调用旧类的方法。 a.fun_A(); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; var obj = new B(); obj.fun_A_in_B(); &#125;&#125; 组合的内存花销：继承与组合设计的系统开销不会有本质的差别。继承为父类（旧类）开辟空间，也为子类（新类）开辟空间。组合也一样，只不过比继承多了一个引用变量来引用被嵌入的对象，一般影响不大。 初始化块 格式：1234[修饰符] &#123; &#x2F;&#x2F;初始化块的可执行性代码 ......&#125; 这里的 [修饰符] 如果是static，则称此代码块为类初始化块 没有static修饰，则称为实例初始化块实例初始化块 实例初始化块只在创建Java对象时隐式执行，而且在构造器执行之前自动执行123456789101112131415161718public class Test&#123; &#123; System.out.println(\"第一个运行的实例初始化块\"); &#125; &#123; System.out.println(\"初始化块按顺序执行\"); &#125; public Test()&#123; System.out.println(\"先运行完初始化块后运行Test构造器\"); &#125; public static void main(String[] args)&#123; new Test();//创建对象时隐式执行 &#125;&#125;=============执行结果=============第一个运行的初始化块初始化块按顺序执行先运行完初始化块后运行Test构造器 实例初始化块的“假象”：其实在编译后实例初始化块会消失，被还原到每个构造器的所有代码的前面 类初始化块 类初始化块在类初始化阶段执行，而不是创建对象时才执行。因此类初始化块总是比实例初始化块先执行。 类初始化块只能访问静态成员。 【重点】实例初始化快、类初始化快、构造器的执行顺序12345678910111213141516171819202122232425262728293031class Father&#123; static&#123; System.out.println(\"父类类初始化块\"); &#125; &#123; System.out.println(\"父类实例初始化块\"); &#125; public Father()&#123; System.out.println(\"父类的构造器\"); &#125;&#125;class Child extends Father&#123; static&#123; System.out.println(\"子类类初始化块\"); &#125; &#123; System.out.println(\"子类实例初始化块\"); &#125; public Child()&#123; System.out.println(\"子类的构造器\"); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; //第一次new Child(); new Child(); //第二次new Child(); new Child(); &#125;&#125; 用流程图来简单描述运行流程（贫穷的我只能用试用版亿图图示）： 面向对象（下）包装类Java中的基本类型功能简单，不具备对象的特性，为了使基本类型具备对象的特性，所以出现了包装类，就可以像操作对象一样操作基本类型数据。 12//定义一个包装类Integer的对象Integer int_obj = new Integer(1024); 自动装箱：将一个基本类型变量直接赋给对应的包装类变量，或者赋给Object变量。123//自动装箱int num = 1024;//一个基本类型变量Integer int_obj=num;//直接赋给Integer包装类变量 自动拆箱：与装箱相反，直接把包装类对象赋给一个对应的基本类型变量。123//自动拆箱Integer int_obj = new Integer(1024);//一个包装类对象int num = int_obj;//直接赋给基本类型变量 基本数据类型和包装类的对应关系 基本数据类型 包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 包装类常用方法 打印对象和toString方法在Java中可以直接输出类对象。举个栗子：先定义一个简单的类，用于输出： 123456class Person&#123; private int num; public Person(int num)&#123; this.num = num; &#125;&#125; 在main函数中直接输出Person类对象： 12345678public class Test&#123; public static void main(String[] args)&#123; Person obj = new Person(1024); System.out.println(obj);//直接输出类对象 &#125;&#125;============输出结果=============Person@1f32e575 实际上这里隐式用到了Object类里的一个实例方法toString()而所有的Java类都是Object类的子类，因此所有的Java对象都具有toString()方法下面这两种形式是等价的： 12System.out.println(obj);System.out.println(obj.toString()); Object类提供的toString()方法总是返回该对象实现类的”类名+@+hashCode”值。如果想要输出我们想要的结果，就可以重写toString方法。 12345678910class Person&#123; private int num; public Person(int num)&#123; this.num = num; &#125; //重写这个toString方法（Object类的一个实例方法） public String toString()&#123; return \"[\" + \"num=\" + num + \"]\";//返回我们想要的结果 &#125;&#125; 编译javac -d . Test.java运行java Test走~ [num=12] 还是挺好玩的QAQ ==和equals方法在Java中有两种比较变量的方式：一个是利用==，另一个是利用equals()方法。 先来说说==运算符。这玩意对于基本数据类型可以直接比较，C++中也经常使用。但是如果用来比较引用类型变量的话，则只有两个引用类型变量都指向同一个对象时，==判断才会返回true。举个栗子： 12345var num1 = Integer.valueOf(1024);var num2 = Integer.valueOf(1024);System.out.println(num1 == num2);============输出结果=============false 这里的num1和num2是两个引用类型变量，分别存储着不同的地址，指向不同的位置，==直接判断的是地址，因此输出false 再讲讲equals方法equals()方法是Object类提供的一个实例方法，因此所有的引用变量都可以调用该方法来判断是否与其他引用变量相等。 12345var num1 = Integer.valueOf(1024);var num2 = Integer.valueOf(1024);System.out.println(num1.equals(num2));============输出结果==============true 这里的equals()方法判断的不是地址，而是其指向的值。 自定义equals()方法这个equals()既然是Object类的一个方法，而Object类是所有类的父类。那么我们也可以像自定义toString()方法那样来自定义equals()咯~举个栗子：我们先定义一个”人”类，有名字也有年龄，只要年龄相等，我们就判断这两个是true即p1.equals(p2);应该返回true。 123456789101112131415161718192021class Person&#123; private int age;//年龄 private String name;//姓名 public Person(int age,String name)&#123; this.age = age; this.name = name; &#125; //重写equals方法，只判断年龄就好了。 //重写要求返回值和形参都不能改变。 public boolean equals(Object obj)&#123; return (this.age==obj.age?true:false); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; //两个人名字不同，但年龄相同。 Person p1 = new Person(18, \"Amy\"); Person p2 = new Person(18, \"Tom\"); System.out.println(p1.equals(p2)); &#125;&#125; 编译 运行 走~ Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: age cannot be resolved or is not a field at Person.equals(Test.java:32) at Test.main(Test.java:40)emmm，竟然报错了。报错信息指向这一段 obj.ageobj作为父类，并没有age这个变量。age是Person子类的特有成员！但是想要重写，就必须返回值和形参都不能改变，而形参里面必有Object obj（equals文档说的）那怎么办呢？？强制类型转换也就是需要进行向下转型，((Person)obj).age。同时也要判断obj是不是Person类的对象。 1234567public boolean equals(Object obj)&#123; //判断obj对象是不是Person类对象 if(obj.getClass() == Person.class)&#123; return (this.age==((Person)obj).age?true:false); &#125; return false;&#125; 其他不变 编译 运行 走~~ true 小细节：为什么是((Person)obj).age而不是(Person)obj.age ?这是因为成员运算符（.）的优先级要比括号高。(Person)obj.age就等同于(Person)(obj.age) final成员变量 前置知识：类初始化时，系统会为该类的类变量分配内存，并分配默认值；当创建对象时，系统会为该对象的实例变量分配内存，并分配默认值。 关于final：用final修饰的成员变量，一旦有了初始值，就不能被重新赋值。 Java语法规定：final修饰的成员变量必须由程序员显式地指定初始值。 变量类型 能指定初始值的位置 类变量 静态初始化块、声明时 实例变量 非静态初始化块、声明时、构造器中 123456789101112131415161718192021222324/**********类变量*********///声明时初始化final static int num = 1024;//静态初始化块中初始化final static int num;static&#123; num = 1024;&#125;/**********实例变量*********///声明时初始化final int num = 1024;//非静态初始化块中初始化final int num;&#123; num = 1024;&#125;//构造器中初始化final private int num;public Test(int num)&#123; this.num = num;&#125; 特别注意：如果打算在构造器、初始化块中对final成员变量进行初始化，则不要在初始化之前访问final成员变量。 123456789101112131415final int num;&#123; //还没有初始化num，这样会报错 System.out.println(num); //但是，Java允许通过方法来访问final变量。 //因此，通过这个fun()方法来间接访问num //会导致系统自动为num赋0 fun(); //fun()结束后已经被系统赋初始值了 //这里的num=1024失效 num = 1024;&#125;public void fun()&#123; System.out.println(num);&#125; 关于finalfinal局部变量final局部变量的赋值可以往后稍稍，先声明，过一会再初始化。比如： 123456public static void main(String[] args)&#123; final int num;//先声明 num = 1024;//稍后再进行初始化 System.out.println(num);&#125; final引用类型变量 对于引用类型变量来讲，它保存的仅仅是一个引用，final只保证这个引用类型变量所指向的地址不会改变。 “宏替换”的final变量对于一个final变量来说，只要满足三个条件： 使用final修饰符修饰。 在定义的同时指定了初始值。 该初始值可以在编译时被确定下来。 这个final变量就不再是一个变量，而是相当于一个直接量，被存储在常量池中。 1234567//下面两个都是final“宏变量”final var a = 5+2;final var str1 = \"阿腾木\"+\"的\";final var str2 = \"小世界\"//下面的初始值不能在编译时确定//不被当成宏变量final var num = Integer.valueOf(1024); final方法 final修饰的方法不可被重写 一个“例外”： 12345678910public class A&#123; //这里用了private限定 //对于B类是不可见的 final private fun()&#123;&#125;&#125;class B extends A&#123; //因此这里相当于定义了一个新的方法 //属于B子类 public fun()&#123;&#125;&#125; final类 final修饰的类不可以有子类 不可变类不可变(immutable)类的意思是创建该类的实例后，该实例的实例变量是不可改变的。 12345678910public class Test&#123; //不可变类需要用private和final修饰成员变量 private final String str; //需要提供带参数的构造器 public Test(String str)&#123; this.str = str; &#125; //仅为该类的类成员提供getter方法 //不提供setter方法&#125; 不可变类的实例在整个生命周期中永远处于初始化状态。Java的8个包装类和java.lang.String类都是不可变类 抽象类 抽象类只能被继承，无法使用new进行实例化。 abstract不能修饰变量。 有抽象方法的类只能是抽象类，抽象类可以没有抽象方法。 abstract与private不共存，因为在子类中private方法不可见，则无法重写。 final与abstract不能共存，否则类不能被继承，方法不能被重写。 12345678910111213//Abs里面有一个抽象方法，Abs只能是抽象类public abstract Abs&#123; //abstract不能修饰变量 private String name; //抽象类的构造器不能用于创建实例 //主要用于被其他子类调用 public Abs()&#123;&#125; public Abs(String name)&#123; this.name = name; &#125; //抽象方法不提供具体实现，交给子类实现 public abstract String getName();&#125; 模板模式：如果编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给子类实现。这种设计模式就叫做模板模式。 抽象类就是从多个具体类中抽象出来的父类避免了子类设计的随意性 接口如果说抽象类是从多个类中抽象出来的模板，那么接口抽象的更彻底。接口是从多个相似类中抽象出来的规范,接口不提供任何实现。接口定义了一批类所需要遵守的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，它只规定这批类里必须提供某些方法，提供这些方法的类就可以满足实际需要。 格式： 1234[修饰符] interface 接口名 extends 父接口1,父接口2...&#123; 各种方法和常量&#125; 一些知识点： 修饰符只能是public，要么没有。因为接口是多个类的“公共”规范。 接口不能有初始化块、构造器。 接口成员变量只能是静态常量（int a = 1; 则系统自动加public static final修饰）。 接口的成员变量只能在定义时指定默认值。 接口的方法只能是类方法、抽象方法（普通方法自动加abstract）、默认方法或私有方法。 接口中的普通方法（抽象方法）不能有实现；但类方法、默认方法、私有方法必须有方法实现。 12345678910111213141516171819202122232425262728293031public interface Itf&#123; /**********成员变量**********/ int num = 1024; //系统自动加public static final修饰 //必须在定义时指定默认值 /**********抽象方法**********/ void fun(); //系统自动加abstract /**********默认方法**********/ default void def_fun()&#123; System.out.println(\"默认方法\"); &#125; //使用default修饰，必须有实现 //系统自动加public修饰符 /**********类方法**********/ static void sta_fun()&#123; System.out.println(\"类方法\"); &#125; //系统自动加public修饰符 /**********私有方法**********/ private void pri_fun()&#123; System.out.println(\"私有方法\"); &#125; //可以使用static修饰符修饰 //作为工具方法使用&#125; 一个源文件内只能有一个public接口，主文件名必须与接口名相同。 使用接口使用格式： 1234[修饰符] class 类名 extends 父类 implements 接口1,接口2...&#123; ......&#125; 接口的主要用途： 定义接口类型的变量，也可用于进行强制类型转换 调用接口中定义的常量 接口中的方法被其他类实现 举个栗子，使用上述Itf接口： 12345678910111213141516171819public class Test implements Itf&#123; //实现接口的抽象方法，需要用public //否则会报错：正在尝试分配更低的访问权限; 以前为public public void abs_fun()&#123; System.out.println(\"实现了接口中的抽象方法fun\"); &#125; public static void main(String[] args)&#123; Itf obj = new Test(); System.out.println(obj.num);//调用接口中的常量 obj.abs_fun();//使用接口的对象调用了实现类所实现的抽象方法 obj.def_fun();//可以直接调用接口的默认方法 Itf.sta_fun();//使用接口来调用接口的类方法 &#125;&#125;==========输出结果==========1024实现了接口中的抽象方法fun默认方法类方法 实现接口方法时，必须使用public修饰符，因为接口里的方法都是public的，而子类重写父类方法时访问权限只能是更大或者相等。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://cnatom.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"java","slug":"java","permalink":"https://cnatom.github.io/tags/java/"}]},{"title":"《中国近现代史纲要》知识点汇总","slug":"《中国近现代史纲要》知识点汇总","date":"2019-12-23T07:13:22.000Z","updated":"2020-01-27T16:25:31.752Z","comments":true,"path":"2019/12/23/《中国近现代史纲要》知识点汇总/","link":"","permalink":"https://cnatom.github.io/2019/12/23/%E3%80%8A%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81%E3%80%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"附：中国近现代史大事年表","text":"附：中国近现代史大事年表 第一章 反对外国侵略的斗争第一节 鸦片战争前的中国与世界1、中国经历了二千多年的封建社会，其社会的主要矛盾是地主阶级与农民阶级的矛盾。2、乾隆朝后期，清王朝由盛转衰。3、中国封建社会前后延续了两千多年，中国的封建社会的特点包括（1）经济上封建土地所有制占主导地位（2）政治上实行高度中央集权的封建君主专制制度（3）文化上以儒家思想为核心（4）社会结构上是族权与政权相结合的封建宗法等级制度4、简述中国封建社会由盛转达衰的主要表现。答： （1）政治上， 中央集权进一步强化， 官僚职能扩大， 官僚机构膨胀， 官吏贪污腐败严重， 巧取豪夺，无所不用其极；（2）经济上， 史无前例的人口大增长、 各级官吏和地主大肆兼并土地， 造成人均土地占有量逐年下降，无地或少地的农民日益增多，流民不断增多。地租剥削、赋税征收、苛捐杂税、徭役摊派逐年加重，广大农民生活日渐困苦；（3）思想文化上，厉行专制主度，大兴文字狱，读书人动辄以只言片语获罪，整个社会万马齐喑，一片死寂。（4）军事上，军力衰败，军备废弛，八旗军无所事事，不劳而获，绿营军纪茫然，不堪一击；（5）对外关系上，实行闭关锁国政策，严格限制对外贸易，使中国处于与世隔绝的状态。 第二节 资本——帝国主义对中国的侵略及近代中国的演变1、1842 年，中英间签署《南京条约》 ，割让香港岛给英国。开放广州、厦门、福州、宁波、上海为通商口岸。2、1860 年，英法联军攻占北京，抢劫焚毁了有“万园之园”美誉的皇家园林——圆明园。3、1894 年 11 月，日军制造的连续 4 天大屠杀，造成 30 万中国居民死亡的旅顺大屠杀惨案。4、1900 年，俄国军队侵入中国东北，制造了江东六十四屯惨案。5、1860 年， 《北京条约》开放的通商口岸是天津。6、1860 年， 《北京条约》开放的陆路商埠是伊犁和喀什噶尔。7、1858 年清政府与英、法、美、俄签订《天津条约》 ，允许外国公使常驻北京。8、近代中国司法主权受到破坏，规定外国享有领事裁判权的条约是（1）1843 年中英《五口通商章程》（2）1844 年《望厦条约》9、控列强对中国进行经济掠夺的手段有控制中国通商口岸；剥夺中国关税自主权；对华倾销商品；资本输出。10、外国列强是如何侵略中国的，有什么后果？答： （ 1）军事侵略：资本——帝国主义列强对中国的侵略，首先和主要的是进行军事侵略，迫使中国政府签订不平等条约。通过不平等条约，资本——帝国主义列强侵占了中国领土，勒索巨额赔款，在战争中屠杀中国人民。还公开抢劫中国财富， 肆意破坏中国的文物和古迹， 对中华民族优秀文化造成空前浩劫。（2）政治控制：资本——帝国主义列强还通过军事侵略和不平等条约，控制中国内政和外交，把持中国海关，镇压中国人民的反抗，扶植、收买代理人。（3）经济掠夺：外国列强控制中国通商口岸、剥夺中国关税自主权、对华倾销商品和资本输出，并逐渐操纵中国经济命脉。（4）文化渗透：外国列强利用宗教进行渗透和侵略活动，鼓吹侵略有功论、 “种族优劣论” ，为侵华制造舆论。（5）资本——帝国主义在给中国带来某些新变化的同时，又为了控制和掠夺中国的目的而同中国的封建统治者勾结起来， 共同阻碍中国人民的独立和解放。它们来到中国的主要目的， 并非要把落后的中国变成先进的中国，而是要强迫中国永远成为西方列强的附庸国。第三节 抵御外来侵略争取民族独立的斗争1、中国近代史上中国人民第一次大规模的反侵略武装斗争是三元里人民抗英斗争。2、1841 年战死虎门的广东水师提督是关天培。3、1842 年，在镇江战场战死的满族副都统是海龄。4、中法战争期间，老将冯子材率领清军和民众取得“镇直关大捷” 。5、甲午战争中，战死于平壤的清军将领是左宝贵。6、甲午战争中，英勇牺牲的致远舰管带是邓世昌。7、1839 年，林则徐组织翻译了英国人的《地理大全》 ，编成了《四洲志》成为近代中国开眼看世界的第一人。8、魏源编纂的综述世界各国历史、地理及中国应采取的对外政策的书是《海国图志》 ，提出“师夷长技以制夷”的思想。9、1895 年，严复在《救亡决论》中喊出的响亮口号是救亡。10、提出“物竞开择，适者生存”口号的书是严复翻译的《天演论》 。11、1887 年，葡萄牙胁迫清政府签订的允许葡萄牙“永驻管理澳门”的条约是《中葡友好通商条约》 。12、1895 年中日间签订的中国割让台湾及所有附属岛屿和澎湖列岛给日本的条约是《马关条约》 。13、近代提出“门户开放”政策的国家是美国。14、在威海战斗中殉国的北洋般队将领有刘步蟾、丁汝昌。15、中日甲午战争后，迫使日本将辽东半岛“还给”中国的国家包括俄国、法国、德国。16、19 世纪末，法国在中国划分的势力范围有云南、广东、广西。17、近代中国人民是如何进行反侵略斗争的？答（ 1）人民群众的反侵略斗争：鸦片战争时期，三元里人民抗英运动是中国近代史上中国人民第一次大规模的反侵略武装斗争。太平天国农民战争后期，太平军曾多次重创外国侵略者。1884 年，中法战争时期，香港的中国造船工人和码头工人举行罢工，拒修法国般艇等行为。台湾人民也曾多次反抗侵略者。1900 年，义和团与部分清军与八国联军进行了殊死搏斗，取得廊坊大捷等胜利。（2）爱国官兵的反侵略斗争：鸦片战争期间， 广东水师提督关天培战死虎门，江南提督陈化成在吴淞西炮台以身殉国，副都统海龄在镇江战死疆场。第二次鸦片战争时期，提督史荣椿、乐善战死于天津大沽炮台。中法战争期间，督办台湾事务大臣刘铭传击退敌军。法船炮轰浙江镇海炮台，也被击退。冯子材率领军民取得镇南关大捷。在中日甲午战争中，爱国将士浴血奋战。左宝贵战死平壤，致远舰管带邓世昌、经远般管带林永升在黄海战斗中英勇牺牲，北洋般队统帅丁汝昌、定远般管带刘步蟾在威海战斗中为国捐躯。（3）近代中国人民包括统治阶级的爱国人物在反对外来侵略的斗争中表现出来的爱国主义精神，铸就了中华民族的民族魂。正是由于中国人民前仆后继、英勇斗争，才使我们的国家和民族历尽劫难、屡遭侵略而永不灭亡。 第二章 对国家出路的早期探索第一节 农民群众斗争风暴的起落1、太平天国运动是中国历史上农民战争的最高峰。2、1851 年，洪秀全在广西金田村发动起义。3、太平天国农民战争爆发的根本原因是封建专制政权和地主阶级对农民的政治压迫和经济剥削。4、1853 年 3 月，太平军攻克南京定为首都，改名为天京。5、1956 年上半年，太平天国在军事上达到全盛时期，但也有军事上的失利。失利是指北伐。6、最能体现太平天国社会理想和这次农民战争特点的纲领性文件是《天朝田亩制度》 。7、太平天国后期提出《资政新篇》的是干王洪仁轩。8、太平天国由盛到衰的转折点是天京事变。9、天京事变后，洪秀全为挽救危局提拔的年轻将领是陈玉成和李秀成。10、1864 年太平天国被中外反动势力联合绞杀，太平天国农民运动失败。11、洪秀全撰写的具有相素平等观念，后来成为太平天国农民战争思想基础的书有《原道救世歌》 、 《原道醒世训》、 《原道觉世训》 。12、1851 年 9 月，天平军攻占永安，在永安封王建制，杨秀清被封为东王，节制其他诸王，其他诸葛亮王有西王萧朝贵、南王冯云山、北王韦昌辉、翼王石达开。13、太平天国领导人希望通过《天朝田亩制度》的实施来达到“有田同耕，有饭同食” 、 “有衣同穿、有钱同使”、 “无处不均匀，无人不饱暖”的理想社会。14、 《天朝田亩制度》确立了土地分配的方案，内容有（1）原则是“凡天下田，天下人同耕” （2）田地分为 9 等，好坏搭配（3）按人口平均分配（ 4） 16 岁以上分一整份， 16 岁以下分一半15、对《资政新篇》的评价正确包括（1）带有鲜明的资本主义色彩的改革与建设方案（2）未涉及农民问题和土地问题（3）缺乏实施的阶级基础和社会条件16、天京事变是太平天国统治集团之间的内讧，大大削弱了领导和军事力量，事变中东王杨秀清和北王韦昌辉被杀、翼王石达开迫走。17、 《天朝田亩制度》的内容及其评价。答： （1）主要内容：确立了平均分配土地的方案，根据“凡天下田，天下人同耕”的原则，田地分为 9等，好坏搭配，不论男女老幼按人口平均分配， 16 岁以上分一整份， 16 岁以下分一半。规定了农副业产品的生产与分配，都以农村政权的基层组织“两”来实行管理，每 25 户为一两。分得土地的农民都要参加农副业生产劳动每“两”生产的农副业新产品， “除足其二十五家每人所食可接新谷外，余则归国库。凡麦、豆、苎麻、布帛、鸡、犬各物及银钱亦然” 。支出也由国库统一分配， “所有婚娶弥月喜事，俱用国库，但有限式，不得多用一钱” ， “鳏寡孤独废疾免役，皆颁国库以养” 。（2）评价：第一，《天朝田亩制度》是一个以解决土地问题为中心的比较完整的社会改革方案，代表了农民要求平均分配土地的强烈愿望， 反映了农民反对封建土地所有制的普遍要求。 与以往农民起义提出的“均贫富，等贵贱”和“迎闯王，不纳粮”等相比， 《天朝田亩制度》有更完备的内容和更触及封建社会矛盾核心的深度，应该说这个纲领是比历代农民起义所提出的口号更深刻一些。第二，这个纲领，并没有超出农民小生产者的狭隘眼界。它所追求的理想天国，是小农业与家庭手工业相结合的自然经济， 是一种小自耕农心目中的没有商品流通、 商品交换和绝对平均的理想社会。 所以，这种社会理想是不切实际的空想。它表明，即使是像太平天国这样的农民起义，尽管给腐败的封建制度以严重的冲击，却难以建立起足以替代腐朽制度的新的社会制度。 第二节 地主阶级统治集团“自救”活动的兴衰1、清朝统治集团中倡导洋务的首领是弈欣。2、冯桂芬最早对兴办洋务事业做出比较完整表述。3、1861 年，清政府设立总理各国事务衙门为综理洋务运动的中央机关。4、洋务派开办军事工业的首要目的是镇压太平天国起义。5、洋务派兴办的第一个规模较大的近代意义上的军事兵工厂是江南制造总局。6、由李鸿章管辖属于清政府海军主力的是北洋水师。7、洋务运动的指导思想被概括为“中学为体，西学为用” 。8、北洋水师全军覆没标志着洋务运动的彻底失败。9、举办洋务的重要基地有上海、天津。10、洋务派举办民用企业的目的是解决办军事工业煤铁等原料的需求， 交通运输的需要；企图以民用企业的利润弥补军用工业的亏空。11、到 19 世纪 90 年代，清政府建成福建水师、南洋水师、北洋水师、广东水师四支新式海军。12、洋务运动失败的原因是什么？答： （1）洋务运动具有封建性。洋务运动的指导思想是“中学为体，西学为用” ，即在封建主义思想的指导下，在维护封建的上层建筑、经济基础的条件下学习西文发展一些近代企业， 目的是要维持行将毁灭的清朝封建统治。 然而新的生产力与封建主义的生产关系及其上层建筑是不能相容的， 洋务派只注重西法练兵和办企业， 而不去改变落后的政治制度， 只是在封建制度的母体上，嫁接西方近代生产技术的枝芽，其结果只能是“无可奈何花落去” 。（2）洋务运动对西方列强具有依赖性。在中国近代半殖民地半封建进程日益发展的情况下，洋务派官员越是积极引进西方的“般坚炮利” ，也就越加深了对西方列强的依赖性。西方列强表面上积极扶植洋务派，实际上是要以此为手段，巩固并扩大其在华物权，达到控制和操纵清廷的目的。面对于西方列强的政治、 经济压力， 洋务派多是在 “以夷制夷” 的幌子下妥协退让。 洋务派仰仗西方列强来达到 “求强”、“求富”的目的，无异与虎谋皮。（3）洋务企业的管理具有腐朽性。洋务派所办的新式企业在管理方面仍采取封建衙门式的管理方法，使洋务企业缺乏应有的生机和活力。 洋务派兴办的军事工业完全由官方控制，经营不讲效益， 造出的武器不少质量低劣。官督商团体操民用企业的管理，也是清政府“专派大员，用人理财悉听调度” ，商人没有发言权。企业内部官僚化、贪污中饱、挥霍浪费等现象十分严重。（4）清朝统治集团中的顽固势力又多方阻挠， “一闻修建铁路、电报，痛心疾首，群起阻难” 。 第三节 维新运动的进行和夭折1、举国注目的倡导维新运动的旗手是康有为。2、1895 年康有为联合在京参加会试的举人共同向皇帝上书，史称“公车上书” 。3、严复翻译英国赫胥黎的《进化与伦理》的前两篇，命名为《天演论》 。4、资产阶级思想与封建主义思想在中国的第一次下面交锋是维新派与守旧派的论战。5、戊戌政变后，新政大部被废除，保留下来的是京师大学堂和各地新式学堂。6、从 1898 年 6 月 11 日到 9 月 21 日，光绪帝颁布了一系列变法上谕，史称百日维新。7、维新派维新变法的活动有向皇帝上书、著书立说、介绍外国的变法、办学会、办报纸、设学堂。8、维新派办的影响较大的学会有强学会、南学会、保国会。9、维新派办的影响较大的报纸有上海《时务报》 、天津《国闻报》 、湖南《湘报》 。10、维新派和守旧派之间的论战围绕的问题有（1）要不要变法（ 2）要不要兴民权、设议院，实现君主立宪（3）要不要废除八股、改科举和兴学堂11、1898 年被杀于莱市口的“戊戌六君子”有谭嗣同、刘光第、林旭、杨锐、杨深秀、康广仁。12、 “百日维新”（1）有利于中国资本主义的发展和资产阶级先进文化的传播（2）给开明绅士和民族资产阶级提供了参与政治的机会（3）一定程度上打击了封建官僚制度（4）没有提到“君主立宪” ，改革很不彻底13、论述戊戌维新运动的历史意义和影响。答： （1）戊戌维新运动是一次爱国救亡运动。维新派在国难当头、瓜分危机迫在眉睫的关头挺身而出，掀起了变法图存、维护民族独立和发展资本主义的救世主国运动，反映了时代的要求。（2）戊戌维新运动是一场资产阶级性质的政治改革运动。维新派冲破了洋务派“中体西用”思想的局限，鼓吹民权，提倡设议院，主张用君主立宪制来取代君主专制制度。尽管维新运动未能成功，但在一定程度上冲击了封建制度。（3）戊戌维新运动是一场思想启蒙运动。维新派大力传播西方的社会政治学说，宣传天赋人权、自由平等、社会进化等观念，批判封建君权和封建纲常伦理，有利于民主主义思想在中国的传播。在维新派的推动下，形成广泛的文化革新运动，并对近代教育发展起了积极作用。（4）戊戌维新运动在改革社会风气方面也有不可低估的意义。维新派主张革除吸食鸦片及妇女缠足等陋习，主张“剪辫易服” ，倡导讲文明、重卫生、反跪拜等。 第三章 辛亥革命第一节 举起近代民族民主革命的旗帜1、1905 年成立的中国同盟会是中国历史上第一个资产阶级性质的政党。它的成立，标志着中国资产阶级民主革命进入了一个新阶段。2、 《辛丑条约》的签订标志着以慈禧太后为首的清政府甘心成为“洋人的朝廷” 。3、民族资产阶级是资产阶级革命派的阶级基础。4、1906 年清政府宣布“预备仿行宪政” ，1908 年颁布的一部宪法是《钦定宪法大纲》 。5、1894 年孙中山成立兴中会，它是中国历史上第一个资产阶级革命组织。6、1895 年春，兴中会设总部于香港。7、1904 年，孙中山发表《中国问题的真解决》 ，指出只有推翻清政府，建立“中华民国” ，才能真正解决中国问题。8、同盟人的机关报是《民报》 。9、1905 年，中国同盟会成立于东京。10、中国历史上第一个比较完备的民主主义革命纲领是三民主义学说。11、资产阶级革命派的骨干力量是资产阶级和小资产阶级知识分子。12、中国同盟人的政治纲领是驱除鞑虏，恢复中华，创立民国，平均地权。13、三民主义的内容及其历史意义。答： （ 1）1905 年 11 月，孙中山在 《民报》 发刊词中， 将同盟会纲领概括为民族、 民权、 民生三大主义，后被称为三民主义。民族主义包括“驱除鞑虏，恢复中华”两项内容。一是以革命手段推翻清王朝，改变它一贯推行的民族歧视和压迫政策；二是变“次殖民地”的中国为独立的中国。针对同盟会内部存在的民族复仇主义，孙中山指出民族主义“不是排斥所有的满洲人，而是针对那些阻碍某个的满洲人” ，将民族主义和民族复仇主义区分开来。民权主义的内容是“创立民国” ，即推翻封建君主专制制度，建立资产阶级的民主共和国。孙中山一再阐明民族主义必须和民权主义结合起来， 民族革命和政治革命必须一次完成。他说，革命者打倒满清政府，从驱除满人这一方面来说，是民族革命，从打倒君主专制制度这一方面来说，是政治革命。他还为新生的共和国进行了蓝图设计。民生主我的内容为“平均地权” 。基本方案是：核定地价，按价征税，涨价归分，孙中册指出，在资产阶级革命胜利后，所有的土地所有者无要向国家申报自己的土地数目，由国家核定地价，按地价征税，土地价格上涨之后，收入增加部分应当归国家所有。（2）历史意义：孙中册的三民主义学说，提出了一套在中国历史上不曾有过的资产阶级共和国的建国方案，是一个比较完备的民主主义的革命纲领。它的提出，在社会上产生了积极影响，推动了革命思想的传播和革命运动的发展。 第二节 辛亥革命的胜利与失败1、辛亥革命开始的标志是武昌起义。2、武昌起义后成立湖北军政府推举的都督是黎元洪。3、保路风潮中，运动最强烈的省份是四川。4、在中国延续了两千多年的封建帝制覆灭的标志是 1912 年 2 月 12 日的清帝退位。5、中国历史上第一部具有资产阶级共和国宪法性质的法典是《中华民国临时约法》 。6、1912 年 1 月 1 日中华民国临时政府成立，定都南京。7、北洋军阀政府代表的是大地主和买办资产阶级利益。8、1913 年 3 月，被袁世凯刺杀的是宋教仁。9、袁世凯为得到日本对他复辟帝制的支持，接受日本提出的严重损害中国权益的“二十一条” 。10、标志着旧民主主义革命终结的是第二次护法运动的失败。11、袁世凯复辟帝制，举行登基大典是在 1916 年 1 月 1 目。12、 “二次革命”又被称之为赣宁之役。13、1915 年 12 月 25 日，反对袁世凯称帝，宣布云南独立的是蔡锷。14、中华民国南京临时政府也有局限性，体现在（1）企图用承认列强与清政府签订的不平等条约和外债来换去帝国主义的承认（2）没有提出可以满足农民土地要求的政策和措施（3）以保护私有财产为借口，维护封建土地制度以及官僚、地主所占有的土地和财产15、孙中山为了防止袁世凯专制而提出的条件有奠都南京、新总统到南京就职、遵守临时约法。16、袁世凯就任临时大总统后破坏资产阶级民主制度的活动有（1）强迫国会选举他为正式大总统（2）解散国会，遣散议员（3）炮制《中华民国约法》 ，用总统制取代内阁制（4）修改《总统选举法》以达到无限期连任，并推荐继承人17、 “二次革命”起因是反对袁世凯刺杀宋教仁、反对“善后大借款” 。18、第一次护法运动中，孙中山依靠的军阀主要有陆荣廷、唐继尧。19、资产阶级革命派传播革命思想的著作有《革命军》 、 《驳康有为论革命书》 、 《警世钟》、 《猛回头》。20、1905 年，孙中山在《民报》发刊词中，将同盟会纲领概括为民族主义、民权主义、民生主义三大主义简称“三民主义” 。21、革命派与维新派展开论战的主要舆论阵地是《民报》 、 《新民丛报》。22、 孙中山革命党人为维护资产阶级民主革命成果进行的活动有护国运动、 第一次护法运动、 二次革命、第二次护法运动。23、资产阶级革命派为捍卫民主革命成果而反对北洋军阀又进行了怎样的斗争？答： （1）为反对袁世凯刺杀宋孝仁和“善后大借款” ，发动“二次革命” 。（2）组织中华革命党。二次革命失败后，孙中山逃亡日本。 1914 年 7 月，孙中山在东京正式成立中华革命党。坚持反对袁世凯专制统治的正确方向。（3）为反对袁世凯称帝， 1915 年 12 月 25 日，蔡锷宣布云南独立，护国运动爆发。（4）发动第一次护法运动。袁世凯死后，北洋军阀分裂。皖系段祺瑞掌握了中央政权之后，公然破坏《临时约法》，拒绝恢复国会。 1917 年 7 月中旬，孙中山率领部分国会议员南下广州，发动了第一次护法运动。（5）1919 年 10 月，孙中山重将中华革命党改组为中国国民党。 1920 年 11 月，孙中山重返广东，恢复军政府，领导第二次护法战争。 第四章 开天辟地的大事变第一节 新文化运动与五四运动1、标志着中国新民主主义革命开端的是五四运动。2、新文化运动主要内容是民主与科学。3、新文化运动兴起的标志是陈独秀在上海创办《青年》杂志。4、鲁迅发表的《狂人日记》是新文学运动中第一篇白话文小说。5、李大钊是最先在中国大地率先举起马克思主义旗帜。6、李大钊发表的《我的马克思主义观》比较全面系统介绍了马克思的学说。7、新文化运动的背景是（1）北洋军阀用封建专制思想禁锢民众的头脑（2）尊孔读经的复古逆流甚嚣尘上（3）一部分民主主义知识分子开始从思想文化方面反思辛亥革命8、李大钊讴歌十月革命的著作有《法俄革命之比较观》 、 《庶民的胜利》 、 《Bolshevism 的胜利》。9、五四运动发生的时代条件和历史条件是（1）发生在俄国十月革命所开辟的世界无产阶级社会主义革命的新时代（2）新的社会力量的成长，民族资产阶级和工人阶级力量的进一步壮大（3）新文化掀起的思想解放潮流10、北洋政府迫于五四运动的压力罢免的亲日派官僚是曹汝霖、章宗祥、陆宗舆。11、1919 年 6 月 5 日以后，五四运动发展为全国规模的具有广泛群众性的爱国政治运动，包括知识分子、工人阶级、城市小资产阶级、民族资产阶级。12、五四运动的历史特点和历史意义答：五四运动是在新的时代和新的社会历史条件下发生的， 具有以辛亥革命为代表的旧民主主义革命所不具备的历史意义。（1）五四运动是中国近代史上一次彻底的反帝反封建的革命运动，表现了反学反封建的彻底性。把中国人民反帝反封建的斗争提升到一个新的水平线上。（2）五四运动广泛地动员和组织了群众，是一场真正的群众性的革命运动。青年学生起了先锋作用，是中国工人阶级开始登上政治舞台，在运动后期发挥了主力军作用。（3）五四运动促进了马克思主义在中国的广泛传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立作了思想和干部上的准备。 一方面， 中国先进的知识分子在运动中充分领略了工人阶级的伟大力量， 从而促使他们在行动上探萦马克思主义与工人阶级相结合的方式， 促进工人阶级进一步认识自己的历史使命。 别一方面， 具有初步共产主义思想的知识分子在实际斗争中经受了锻炼， 并自觉进行了自身的改造，逐步转变成为马克思主义者。（4）五四运动是中国新民主主义革命的伟大开端。五四运动发生在俄国十月革命之后，中国革命逐渐成为世界无产阶级社会主义革命的一部分。 五四运动发后， 无产阶级逐渐代替资产阶级成为近代中国民族民主革命的领导者。 第二节 马克思主义传播与中国共产党诞生1、中国共产党成立的标志是中共一大的召开。2、上海共产主义小组是中国第一个地方共产党组织。3、成为中国共产党后备力量的组织是社会主义青年团。4、上海机器工会共产党早期组织领导的第一个产业工会。5、1921 年 7 月 23 日，中国共产党第一次全国代表大会在上海召开。6、党成立以后的中心任务是开展工人运动，以共产主义精神教育工人。7、1922 年 7 月，中国共产党第二次全国代表大会制定了彻底的反帝反封建的民主革命纲领。8、中共二大选举了新的中央领导机构，陈独秀当选中央执行委员会委员长。9、中国工人阶级第一次直接同帝国主义势力进行的有组织较量是香港海员罢工。10、1921 年 8 月，党在上海成立中国劳动组合书记部，作为领导工人运动的专门机关。11、中国二大提出了资产阶级小资产阶级政党从没有采取过的革命方法是群众路线方法。12、沈定一在浙江省萧山县衙前村举办了中国第一个农民协会。13、中共一大选举产生中央局作为党的领导机构，其成员包括陈独秀、张国焘、李达。14、中共二大指出革命的动力是工人、农民、小资产阶级、民族资产阶级。15、在 1923 年“二七惨案”中共产党员林祥谦、施洋被害。16、中国共产党二大的制定的民主革命纲领及其意义？答： （1）党的最低纲领，即党在当前阶段也就是民主革命阶段的纲领是：消除内乱，打倒军阀，建设国内和平；推翻国际帝国主义的压迫，达到中华民族完全独立；统一中国为真正的民主共和国。这是在中国殖民地半封建社会条件下走向社会主义、共产主义的不可超越的一个阶段。（2）中共二大在中国近现代历史上第一次明确提出了反帝反封建的民主革命纲领。历史证明，只有用马克思主义武装起来的中国共产党才能为中国革命指明方向。 “打倒列强、除军阀”逐渐成为广大群众的共同呼声。 第三节 国共合作与国民革命1、1923 年 6 月，中国共产党第三次全国代表大会集中讨论的问题是国共合作，建立革命统一战线的问题。2、以第一次国共合作为基础的革命统一战线正式形成的标志是国民党一大的成功召开。3、成为国共合作的政治基础和革命统一战线的共同纲领是新三民主义。4、黄埔军校同一切旧式军校根本区别在把政治教育提到和军事训练同等重要的地位。5、1925 年 1 月召开的中国共产党第四次全国代表大会的中心议题是如何领导即将到来的革命高潮。6、五卅运动掀起了全国范围的大革命风暴。7、中国工人运动史上前所未有的壮举，对大革命的高潮形成起了重要推动作用的是省港大罢工。8、1927 年 4 月 28 日被奉系军阀张作霖杀害的共产党创始人是李大钊。9、第一次国共合作全面破裂，大革命最疑义失败的标志是“七一五”分共。10、改组后的国民党成为革命聪明的政党，包括的阶级有工人阶级、农民阶级、小资产阶级、民族资产阶级。11、1925 年，中共四大在上海召开，主要内容有（1）提出了无产阶级在民主革命中的领导权（2）提出了工农业联盟的问题（3）制定了开展工农运动的计划（4）决定在全国建立和加强党的组织以适应革命形势的发展12、北伐战争直接打击目标是吴佩孚、孙传芳、张作霖。13、在北伐战争期间，中国人民反帝斗争邓得了重大胜利，收回的租借地是九江、汉口。14、1926 年 3 月、 5 月蒋介石打击共产党员和工农革命群众力量的事件是中山舰事伯、整理党务案。15、到 1927 年春，北伐胜利进军，革命势力从珠江流域推进到长江流域、黄河流域。16、早期共党组织成员与反马克思主义者进行的论战主要有（1）同胡适围绕“问题与主义的论战（2）同张东荪、梁启超关于社会主义的论战（3）同无政府主义者的论战17、国民大革命失败的原因及经验教训是什么？答： （1）国民革命失败的原因是复杂的，多方面的。客观上， 一是帝国主义和中国封建主义势力的联合力量大大超过刚刚兴起的革命联合力量， 敌我力量悬殊；二是革命统一战线内部出现剧烈化，蒋介石、汪精卫先后分裂统一战线，制造反共政变，使革命力量遭到严重损失。主观上， 以陈独秀为着的中共中央领导机关的大革命后期犯了右倾机会主义错误， 放弃了无产阶级对于农民群众、 城市小资产阶级和民族资产阶级的领导权，尤其是武装斗争的领导权。 当时的中国共产党处于幼年时期， 缺乏对中国社会和中国革命基本问题的深刻认识， 缺乏革命经验尤其是处理同资产阶级复杂关系的经验， 还不善于把马克思主义基本原理和中国革命的实践结合起来。 当时的中国共产党作为共产国际的一个支部，直接受共产国际的指导。对酿成陈独秀右倾机会主义错误有直接影响。（2）国民大革命的失败得出的教训是：第一， 共产党要领导人民取得革命的胜利，就必须坚持无产阶级对革命的领导权， 反对右倾投降主义错误。第二，共产党要领导人民取得革命的胜利，还必须建立革命的武装，坚持武装斗争，妥协退让只会断送革命。 第五章 中国革命的新道路第一节 国民党在僵的统治和中间党派的政治主张1、1928 年 12 月 29 日张学良宣布东北易帜，标志着国民党在形式上统一中国，在全国范围内建立了自己统治。2、官僚资本的垄断活动首先和主要的方面是在控制金融业。3、国民党四大银行完成其金融垄断有决定意义的步骤是发行法币。4、20 世纪二三十年代活跃着的中间党派的社会基础主要是民族资产阶级、上层小次产阶级及其知识分子。5、国民党是如何实行一党专政的军事独裁统治的？答： （1）为了镇压人民和消灭异已力量，国民党建立了庞大的军队，还大力加强地方反动武装保安队。广大人民被置于国民党武装的严密控制和监视之下。（2）为了镇压人民和消灭异已力量，国民党还建立了庞大的全国性特务系统——“中统”和“军统” ，主要任务就是对共产党，破坏革命运动，绑架或暗杀革命者和异已分子。（3）为了控制人民，禁止革命活动，国民党还大力推行保甲制度，广大人民被禁锢在保甲制度之内。（4）为了控制舆论，剥人民的言论和出版自由，国民党还厉行文化专制主义。国民党政府主要就是通过这此方法，来维护帝国主义、封建主义、官僚资本主义的利益，巩固自身统治的。 第二节 中国共产党对革命新道路的艰苦探索1、1927 年，中国共产党在汉口秘密召开党的临时会议，史称八七会议，它是大革命失败的土地革命战争兴起的历史转折点。2、成为建设共产党领导的新型人民军队的重要开端是三湾改编。3、毛泽东提出“中国革命斗争的胜利要靠中国同志了解中国情况”的文章是《反对本本主义》 。4、毛泽东提出以农村为中心，初步形成农村包围城市、武装夺取政权的理论的文章是《星星之火，可以燎原》。5、中国共产党历史上第一个土地法是井冈山土地法。6、兴国土地法对井冈山土地法进行的一个原则性改动从而保护了中农利益的是改“没收一切土地”为“没收一切公共土地及地主阶级的土地” 。7、 “八七会议”彻底清算了陈独秀的右倾机会主义错误，确定了土地革命和武装斗争的方针，选出了以瞿秋白为首的中央临时政治局，为挽救中国革命和中国共产党作出了巨大贡献。8、南昌起义的历史意义是打响了武装反抗国民党反动统治的第一枪，成为中国共产党独立领导革命战争、创建人民军队和武装夺取政权的伟大开端，揭开了土地革命的序幕。9、同南昌起义相比，湘赣边界秋收起义的特点在于放弃了“左派“国民党运动的旗号，公开打出了”工农革命军的旗帜，不仅是军队的行动，而且有数量众多的工农武装参加。10、 “三湾改编”的主要内容有（1）将原有的一个师缩为一个团（ 2）在部队中建立共产党各级组织（3）将党的支部建在连上（ 4）成立各级士兵委员会，部队内部实现民主管理11、井冈山革命根据地的创建有深远的意义，表现在（1）点燃了“工农武装割据”的星星之火（ 2）为共产党领导的其他各地的起义武装树立了榜样（3）开辟了在敌我力量悬殊的情况下共产党深入农村保持和发展力量的正确道路。12、科学地回答了红色政权存在和发展的原因和条件的文章是《中国的红色政权为什么能够存在？》 、《井冈山的斗争》 。13、对于红军、游击队和红色区域的建立和发展，毛泽东在《星星之火，可以燎原》中指出（1）这是半殖民地中国在无产阶级领导下的农民斗争的最高形式（2）这是半殖民地农民斗争发展的必然结果（ 3）是促进全国革命高潮的最重要因素14、从 1930 年 10 月到 1931 年 7 月，红军边疆粉碎敌人三次“围剿”的原因是（1）土地革命在根据地的开展 （ 2）贯彻了积极防御的方针（3）实行“诱敌深入” 、 “避敌主力” 、 “打其虚弱”等一整套战术15、新民主主义革命时期开展土地革命的实质就是（1）消灭封建地主的土地所有制（ 2）实现农民的土地所有制16、党在第二次国内革命阶段，领导土地革命的阶级路线是（1）坚定地依靠贫农、雇农（ 2）联合中农、限制定农（ 3）保护中小工商业者（4）消灭地主阶级17、党在土地革命时期的土地分配方法是以乡为单位、按人口平分土地、抽多补少、抽肥补瘦。18、中国的红色政权存在和发展的原因和条件有哪些？答： （1）中国是一个几个帝国主义国家间接统治的政治经济发展极端不平衡的半殖民地半封建的大国。这是红色政权能够存在和发展的根本原因。（2）国民革命的影响。这是红色政权存在和发展的一个客观条件。（3）全国革命形势的继续向前民展。这是红色政权存在和发展的又一个主观条件。（4）相当力量的正式红军的存在。这是红色政权存在和发展的一个主观条件。（5） 共主党组织的坚强有力和各项政策的正确贯彻执行。 这是红色政权存在和发展的又一个主观条件。 第三节 中国革命在探索中曲折前进1、1931 年，中华苏维埃第一次全国代表大会在江西省瑞金召开。2、中华苏维埃第一次全国代表大会选举毛泽东为中央执行委员会主席。3、中化苏维埃政府实行的政治制度是各级工农兵代表大会制度。4、1931 年 11 月赣南会议召开，错误地把毛泽东排除在中央根据地红军领导地位之外。5、临时中央政治局迁到中央根据地后，全面推行“左”倾家荡产冒险主义错误，在福建开展的运动是反对“罗明路线”的斗争。6、第五次反“围剿”失败的最主要原因是“左”倾错误的进一步发展。7、1934 年 10 月中央红军和中共中央机关开始长征。8、率领北上抗日先遣部队的是方志敏。9、长征初期，博古等犯的错误是逃跑主义。10、遵义会议后张闻天代替博古对党负总责。11、195 年 6 月，中央红军和红四方面军于四川懋功胜利会师。12、中央红军和红四方面军会师后，张国焘提出南下四川、西康。13、红军胜利结束长征实现了战略大转移的标志是红军三大主力会合。14、中国共产党在政治上达到成熟的时期是第二次国内革命战争时期。15、遵义会议后组成的负责红军军事行动的三人团包括毛泽东、周恩来、王稼祥。16、1936 年 10 月，红二、四方面军先后同红一方面军胜利会师于甘肃会宁、静宁将台堡。17、合编组成红二方面军的是红二军团、红六军团。18、领导红二方面军的将领是贺龙、任弼时。19、红四方面军中反对张国焘另立中央的有朱德、刘伯承、徐向前、贺龙。20、论述遵义会议的主要内容和历史意义。答 1935 年 1 月 15 日至： 17 日，中共中央政治局在遵义召开扩大会议。会议集中全力解决了当时具有决定意义的军事和组织问题。（1）经过激烈的争论，多数人同意毛泽东为代表的正确意见，批评了博古、李德在第五次反“围剿”中的错误。（2）会议增选毛泽东为中央政治局常委，并委托张闻天起草《中央关于反对敌人五次“围剿”的总结的决议》（即遵义会议决议）（3）会后不久，中共中央政治局常委分工，根据毛泽东的提议，决定由张闻天代替博古负总的责任；博古任红军总政治部代理主任；并成立了由毛泽东、周恩来、王稼祥组成的新的三人团，全权负责红军的军事行动。遵义会议的一系列重大决策，是在中国共产党同共产国际中断联系的情况下，独立自主地作出的。遵义会议召开的历史意义主要体现在：（1）尊义会议在极其危急的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，开始确立了以毛泽东为代表的新的中央的领导， 成为中国共产党历史上一个生死攸关的转折点， 标志着中国共产党在政治上走向成熟。（2）遵义会议的召开证明，作为一个严肃的、对人民负责任的马克思主义政党，中国共产党从来都是正视自己的错误， 并注意从自己所犯的错误中学习并汲取教训的。 在中国共产党领导中国革命全过程的某一个时期内， 党以及党的领导人难免会犯这样那样的错误甚至严重的错误。但是，中国共产党是具有自我净化和自我发展的能力的， 党正是通过总结成功的经验和失误的教训， 不断地把党及党所领导的革命事业不断推向前进的。 第六章 中华民族的抗日战争第一节 日本发动灭亡中国的侵略战争1、中国人民抗日战争是近代以来中国第一次取得反侵略完全胜利的战争。2、明治维新后，日本开始推行大陆政策。3、1927 年日本召开“东方会议” ，制定了《对华政策纲领》 。4、日本开始实施变中国为其独占殖民地的事件是“九一八”事变。5、日本借口中国军队炸毁柳条湖铁路一段，挑起“九一八”事变。6、日本制造“华北事变” ，策动华北五省二市“防共自治“。7、1927 年“东方会议”（1）由田中义一在东京主持（2）制定了《对华政策纲领》（3）提出满蒙与日本利益相关（4）日本可以采取断然措施维护在满蒙利益8、1938 年 10 月后日本侵华政策的调整是（1）实施“以华制华”和“以战养战”的策略（2）对国民党采取政治诱降为主、军事打击为辅的方针（3）在占领共扶植傀儡政权，建立发展汉奸组织（4）逐渐加强对共产党领导的敌后根据地的“扫荡”9、1933 年 11 月，蔡廷锴、蒋光鼐在福州举行抗日反蒋事变，史称“福建事变。10、 《为抗日救国告全国同胞书》（1）中国共产党面临新形势提出的新政策（2）中共驻共产国际代表团以中华苏维埃共和国临时中央政府和中共中央名义发表（3）呼吁停止内战，集中国力为抗日救国的神圣事业而奋斗。 第二节 从局部抗战到全国性抗战1、1934 年 4 月，由共产党提出、宋庆龄等签名发表《中国人民对日作战的基本纲领》 ，号召中国人民自己起来武装驱逐日本侵略者。2、 “一二九运动”标志着中国人民抗日救亡运动新高潮的到来。3、根据国共两党协议，红军主力改编为国民革命军第八路军，朱德、彭德怀任八路军正副总指挥，总参谋长叶剑英，副总参谋长左权。4、中国共产党领导的南方八省游击队改编后，叶挺、项英分别担任新四军正副军长。5、 以国共两党第二次合作为基础的抗日民族统一战线正式建立的标志之一是国民党中央通讯社发表 《中共中央为公布国共合作宣言》 。6、瓦窑堡会议（1）提出了在抗条件下与民族资产阶级重建统一战线的新政策（2）批评了“左”倾冒险主义和关门主义错误倾向（3）为迎接全国抗日新高潮的到来做了理论和政治上的准备7、在北平南苑战斗号，国民党二十九军将领佟麟阁、赵登禹阵亡 第三节 国民党下面战场以及大后方的抗日民主运动1、枣宜会战中，国民党第 33 集团军总司令张自忠将军壮烈殉国。2、人缅作战中，国民党第五军 200 师师长戴安澜将军为国牺牲。3、1942 年初成立的中国距区最高统帅是蒋介石。4、抗战后期，国民党军队大溃败的战役是豫湘桂战役。5、抗战以来，国民党取得第一次重大胜利的战役是台儿庄战役。6、在抗战争进入相持阶段后，国民党的抗战态度趋向消极体现在（1）实行保守的收缩战略以便保存实力（2）打击限制共产党及其领导下的抗日军队（3）国民党五届中全会决定成立“防共委员会”（4）国民党五届五中全会制定了“防共、限共、溶共、反共”的方针7、中国战区成立的背景是（1）日军偷袭珍珠港，太平洋战争爆发（2）美英等国对日宣战（3）国民政府正式对日宣战8、关于中国远征军的表述正确的有（1）1942 年由国民政府组成入缅甸作战的军队（2）在东吁保卫战中歼灭日军 5000 多人（3）第 200 师师长戴安澜在缅北殉国（4）1942 年 4 月，解救出被日军围困的英军 7000 多人9、简述中国抗日战争的两个战场及其关系。答： （1）抗日战争时期中国始终存在着两个战场，即共产党领导的敌后战场和国民党领导的下面战场。（2）国民党领导的下面战场始终是中国抗战的重要战场，在全民族抗战中具有重要地位。全国性抗战开始后，共产党领导的八路军、新四军立即投入抗日斗争。八路军刚开赴前线时，主要是直接在战役上配合国民党军队作战。 1937 年 11 月太原失陷后，按照中共中央的部署，八路军在敌后实施战略展开，发动独立自主的敌后游击战争。（3）正面战场和敌后战场在中国抗日战争中逐渐形成，在战略上相互配合。 第四节 中国共产党成为抗日战争的中流砥柱1、全国性抗战开始后中国军队的第一次重大胜利是平型关战役。2、1940 年八路军在华北发动的大规模破袭进攻战是百团大战。3、太原失陷后，中国共产党领导的是八路军在敌后实施战略展开，最先建立的敌后抗日根据地是晋察冀抗日革命根据地。4、中国共产党在抗民族统一战线中必须坚持独立自主原则的实质是力争中国共产党对抗日战争的领导权以取得抗战的胜利。5、为了度过根据地严重的经济困难，中共中央采取实施的李鼎铭提出的“精兵简政”的建议。6、中国共产党内反复出现“左”右倾错误的思想认识根源是主观主义。7、1945 年，中国共产党第七次全国代表大会将毛泽东思想规定为党的一切工作的指针。8、在联合国制宪会议上中国成为联合国的创始国和五个常任理事国。9、敌后战场为国捐躯的八路军、新四军高级将领有左权、彭雪枫、赵尚志。10、国民党顽固派制造的反共高潮有（1）胡宗南进攻陕甘宁边区（ 2）阎锡山攻击共产党领导的新军和八路军（3）皖南事变 （4）策划发动第三次反共高潮11、中国共产党主张要实行全面抗战必须要做到（1）实行全国军事的总动员（ 2）实行全国人民的总动员（3）必须改革政治机构给人民以充分的民主权利（ 4）适当改善工农大众的生活12、中国共产党强调必须在统一战线中坚持独立自主，为此要采取的措施有（1）党必须保存在思想政治组织上的独立性，发动群众壮大人民力量（2）坚持党对人民军队的绝对领导，努力发展抗日武装和抗日根据地（3）对国民党采取又团结又斗争、以斗争求团结的方针13、抗战初期国民党下面战场组织的重要会战有淞沪会战、忻口会战、徐州会战、武汉会战。14、抗日战争时期中间势力包括民族资产阶级、开明绅士、地方实力派15、大生产运动（1）为了克服严重的经济困难 （2）首先在陕甘宁边区进行（3）口号是“自己动手，丰衣足食” （4）三五九旅履行南泥湾16、各地普遍开展大生产运动的效果是（1）克服了经济困难 （2）解决了部队的粮饷 （3）提高了当地人民的生活水平17、为什么说中国共产党及其领导的人民抗日力量在抗日战争中起了中流砥柱的作用？答： （ 1）以毛泽东同志为杰出代表的中国共产党人，把马克思列宁主义同中国革命具体实际相结合，创立和发展了毛泽东思想的科学理论，对抗日战争发挥了重要的思想和战略指导作用。（2）中国共产党坚持抗战、反对妥协，坚持团结、反对分裂，坚持进步、反对后退，成为引导全民族抗战走向胜利的一面旗帜。（3）中国共产党积极倡导、促成、维护抗日民族统一战线，最大限度地动员了全国军民共同抗战，成为凝聚全民族力量的杰出组织者和鼓舞者。（4）中国共产党坚持全面抗战路线，制定正确的战略策略，实施动员人民、领先人民的路线政策，提出持久战的战略总方针和一整套人民战争的战略战术， 开辟广大的敌后战场， 成为坚持抗战的中坚力量。（5）中国共产党人以自己最富于牺牲精神的爱国主义、不怕流血牺牲的模范行为，支撑起全民族救亡图存的希望，成为夺取抗战胜利的民族先锋。（6）抗日战争的历史生动有力地证明，中国共产党人不仅是坚定的国际主义者，而且首先是最热烈、最忠诚、最彻底的爱国主义者。没有中国共产党人作中流砥柱，抗日战争的坚持和胜利是不可想象的。 第五节 抗日战争的胜利及其意义1、抗日战争胜利取得完全胜利的重要标志是收回了台湾及澎湖列岛。2、关于日本投降、抗日战争胜利的重要事件有（1）8 月 15 日，天皇以广播“终战诏书”的形式宣布接受波茨坦公告（2）9 月 2 日，日本方面的代表在美舰密苏里号上签署投降书（3）9 月 9 日，中国战区受降仪式在南京举行（4）10 月 25 日，中国政府在台湾举行受降仪式3、中国人民抗日战争胜利的主要原因是什么？答： （1）中国共产党在全民族抗战中发挥了中流砥柱的作用。 这是中国人民抗日战争同近代以来历次反侵略战争最大的区别。中国共产党积极倡导、促成、维护抗日民族统一战线，最大限度地动员全国军民共同抗战， 成为凝聚全民族力量的杰出组织者和鼓舞者。 以毛泽东为主要代表的中国共产党人， 把马克思列宁主义基本原理同中国具体实际相结合， 科学阐明了抗日战争的规律和进程， 制定了正确的战略和策略，对抗日战争发挥了重要的指导作用。（2）中国人民巨大的民族觉醒、空前的民族团结和英勇的民族抗争，是中国人民抗日战争胜利的决定性因素。抗日战争唤起了全民族的危机意识和使命意识。 中国共产党以全民抗战的纲领主张、 团结御侮的先锋作用、人民战争的组织力量，最大限度地调动起全国人民的抗日积极性。在抗日战争中，军队和老百姓相结合， 武装斗争与非武装斗争相结合，前方斗争和后方斗争相结合，公开斗争与隐蔽斗争相结合， 使日本侵略者陷入了人民战争的汪洋大海之中。 国民党的爱国官兵也为反对日本的侵略作出了贡献。（3）中国人民抗日战争的胜利，同世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持也是分不开的。苏联、美国、法国、英国等向中国提供了经济和军事援助。许多国家的反法西斯战士直接参加了中国人民的抗日战争，为中国人民的解放事业贡献鲜血和生命。4、中国人民抗日战争胜利的基本经验是什么？答： （ 1）全国各族人民的大团结，是中国人民战胜一切艰难困苦、实现抗战胜利的力量源泉。在抗日战争中，中华民族实现了空前的大团结，形成了真正意义上的全民族抗战。始终坚持以国共合作为基础、以中国共产党为中流砥柱的抗日民族统一战线， 是实现和维护全国各族人民大团结的政治保证。 没有全国各族人民的大团结，没有抗日民族统一战线，就没有抗日战争的伟大胜利。（2）以爱国主义为核心的伟大民族精神是中国人民团结奋进的精神动力。这是抗日战争得以坚持和胜利的重要的思想保证。 抗日战争大大丰富和升华了以爱国主义为核心的中华民族精神。 中国共产党以其精诚团结、坚持抗战、献身民族的实际行动，成为中华民族精神的集中代表者，充分发挥出民族先锋队和阶级先锋队的作用，赢得了全中国人民的拥戴。（3）中国人民热爱和平、反对侵略战争，同时又不惧怕战争。中国人民进行反侵略战争，是为了捍卫中华民族生存和发展的权利，是对世界反法西斯战争和人类进步事业的重大贡献。 第七章 为创建新中国而奋斗第一节 从争取和平民主到进行自卫战1、第二次世界大战后，美国开始在资本主义世界中称雄。2、中共中央在 1945 年 8 月 25 日明确提出“和平民主团结”的口号。3、1945 年 10 月 10 日，国共双方签署了《政府与中共代表会谈纪要》 ，又称《双十协定》 。4、1945 年 9 月 19 日，中共中央针对和谈期间特殊情况，正式确定了“向北发展，向南防御”的战略方针。5、反法西斯战争后，人民民主力量明显增长的主要表现是（1）社会主义的苏联得以较快地恢复和巩固（2）人民民主和社会主义制度在多国建立（3）民族解放运动在亚洲、非洲、拉丁美洲蓬勃兴起（4）在资本主义国家，共产党的影响显著增长，工人运动有了新的发展6、为打退国民党军队在重庆谈判期间发动的军事进攻，解放区军民进行了上党战役、邯郸战役、平绥战役、津浦战役。7、出席 1946 年 1 月政治协商会议的党派，除国民党、共产党外，还有民主同盟、青年党。8、1946 年 1 月的政治协商会议通过的协议包括政府组织、国民大会、和平建国纲领、宪法草案。9、1946 年 2 月 10 日和 6 月 23 日，国民党当局先后在重庆和南京制造了较场口惨案、下关惨案。10、毛泽东指出的必须打败蒋介石，而且能够打败他的原因。答： （ 1）全面内战爆发后，中国共产党清醒地估计了国内外形势，明确而坚定地指出我们不但必须打败蒋介石，而且能够打败他。（2）必须打败蒋介石，是因为蒋介石发动的战争，是一场院在美帝国主义指挥之下的反对中国民族独立和中国人民解放的反革命的战争。 不用革命战争反对反革命战争，中国就将变成黑暗世界， 中华民族的前途就会被断送。（3）能够打败蒋介石，是因为蒋介石军事力量的优势和美国的援助，只是暂时的现象是临时起作用的因素；而蒋介石发动的战争的反人民性质，人心的向背，则是经常起作用的因素。人民解放战争所具有的爱国的正义的革命的性质，必然要获得全国人民的拥护。这就是战胜蒋介石的政治基础。 第二节 国民党处于全民的包围之中1、1947 年 2 月，解放区军民粉碎国民党军队的全面进攻。2、1947 年 6 月，解放区军民粉碎国民党军队的重点进攻。3、中国共产党发布《关于清算、减租及土地问题的指示》 ，决定将减租减息政策改变为实现“耕者有其田”政策。4、学生运动是国统区人民所进行的第二条战线的斗争的发端。5、1947 年 12 月，毛泽东在《目前形势和我们的任务》的报告中提出新民主主义革命三大经济纲领。6、 “一二 ?一”运动的基本口号是“反对内战，争取自由” 。7、1947 年间，全国先后举行罢工的工人达 120 万人。8、1947 年，台湾人民发动反对国民党黑暗统治的“二 ?二八”起义。9、新疆省于 1945 年建立少数民族群众的革命政府。10、1947 年 5 月 1 日，内蒙古自治政府成立，乌兰夫任政府主席。11、1948 年 1 月 1 日，中国国民党革命委员会在香港成立。12、1945 年 12 月中国民主建国会成立，其成员主要是爱国的民族工商业者以及有联系的知识分子。13、中国民党临时行动委员会于 1947 年 2 月改称中国农工民主党。14、1947 年 10 月，国民党当局宣布中国民主民盟“为非法团体” ，明令对该组织及其成员的一切活动“严加取缔”。15、台湾民主自治同盟于 1947 年 11 月在香港成立。16、1948 年 4 月，毛泽东系统地阐明的中国共产党的土地改革总路线是依靠贫农，团结中农，有步骤地、有分别地消灭封建剥削制度，发展农业生产。17、国民党统治区的政治经济危机日益加深的主要原因是（1）抗战胜利后，国民党把接收变成“劫收” ，从而使更多的民众期望破灭（2）国民党统治集团违背全国人民的意愿，实行反人民的内战政策（3）将全国各阶层人民置于饥饿和死亡线上18、抗日战争胜利后正式成立的民主党派有九三学社、中国民主促进会。19、中国各民主党派形成时的社会基础，主要是（1）民族资产阶级及其知识分子（ 2）城市小资产阶级及其知识分子（ 3）其他爱国民主分子20、1948 年 1 月，民盟一届三中全会明确宣告（1）不接受解散民盟的任何决定，并恢复民盟总部（2）民盟坚决不能够在是非曲直之间，有中立的态度（3）今后要与中国共产党携手合作21、抗日战争胜利后，国民党政府陷入全民的包围中并迅速走向崩溃的原因。答：抗日战色胜利后，国民党政府陷入全民的包围中并迅速走向崩溃的原因是：（1）抗战胜利后，国民党把接收变成“劫收” ，大发“胜利财” ，从而使更多的民众期望破灭。（2）国民党统治集团违背全国人民迫切要求休养生息、和平建国的意愿，实行反人民的内战政策。（3）为了支持反人民的内战，国民党政府从多方面加剧对广大人民的疯狂掠夺，将全国各阶层人民置于饥饿和死亡线上，迫使全国各阶层人民团结起来，同国民党政府作你死我活的斗争，除此以外，再无出路。（4）中国共不产党制定和实行了推翻国民党黑暗统治的正确的政策和策略，不仅成功地领导了解放区军民在第一条战线的革命斗争，而且成功地领导了国统区人民在第二条战线的革命斗争。 第三节 人民共和国：中国人民的历史性选择1、毛泽东为新华社写的 1949 年新年献词一文是《将革命进行到底》 。2、人民解放军占领南京是在 1949 年 4 月 23 日。3、 《共同纲领》最基本、最核心的内容是关于新中国的国体和政体的规定。4、自 1948 年 9 月 12 日开始至 1949 年 1 月 31 日结束的三大战役是辽沈战役、淮海战役、平津战役。5、参加淮海战役的人民军队是华东野战军、中原野战军。6、中共七届二中全人的主要内容是（1）规定了全国胜利后中国共产党在政治、经济、外交等方面的基本政策（2）指出了中国由农业国转变为工业国、由新民主主义社会转变为社会主义社会的发展方向（3）在中国共产党自身建设的问题上，提出了“两个务必”的要求7、从 1948 年 8 月起，各民主党派负责人、无党派民主人士接受中共中央邀请，分别从香港、上海、北平及海外，陆续进行东北解放区、华北解放区。8、淮海战役总前委的成员，除刘伯承、邓小平外，还有陈毅、粟裕、谭震林。9、1949 年 4 月 21 日，向中国人民解放军发布《向全国进军的命令》的是毛泽东、朱德。10、 《共同纲领》规定的新中国外交工作的原则（1）保障本国独立、自由和领土主权的完整（2）维护国际的持久和平和各国人民间的友好合作（3）反对帝国主义的侵略政策和战争政策11、中国革命取得胜利的基本经验有答： （1）建立广泛的统一战线（ 2）坚持革命的武装斗争（ 3）加强共产党自身的建设 第八章 社会主义基本制度的全面确立第一节 《共同纲领》的全面实施与新民主主义革命任务的胜利完成1、1949 年中华人民共和国的成立标志着中国现代史的开端。2、在新解放区，人民解放军进行了大规模的剿匪作战，共消灭国民党土匪武装 200 多万。3、1951 年 5 月，西藏和平解放标志着中国人民解放军完成全国大陆的解放。4、1950 年 6 月，中央人民政府颁布了《中华人民共和国土地改革法》 。5、新中国成立初期开展的镇压反革命运动的政策是镇压与宽大相结合。6、新中国建立社会主义国营经济的最主要途径和手段是没收官僚资本。7、1950 年 5 月，第一部《中华人民共和国婚姻法》颁布。8、中共七届三中全会提出争取国家财政经济状况基本好转的任务。9、到 1953 年 3 月，我国建立了县级以上的民族自治区达 47 个。10、1951 年至 1952 年“五反”运动开展的领域是私营工商业。11、新中国的第一个五年计划中，集中主要力量发展的是重工业。12、新中国成立初期，我国主持召开的第一次大型国际会议是亚洲太平洋地区和平会议。13、中国人民志愿军司令员兼政治委员是彭德怀。14、1949 年 10 月 2 日，第一个照会中国政府，决定同中华人民共和国建立外交关系的国家是苏联。15、新民主主义社会的起止时间是 1949 年—— 1956 年。16、20 世纪中国人民在前进道路上经历的第一交历史性巨大变化是新中国的成立和社会主义制度的建立。17、中华人民共和国的成立奈志着新民主主义革命基本胜利； 半殖民地半封建社会结束；中国进入新民主主义社会。18、建国初期进行的运动主要有土地改革运动、镇压反革命运动、三反五反运动、抗美援朝运动。19、建国初期，中国共产党对很高营工商业进行全面调整的原则是公私兼顾、劳资两利。20、党的七届三中全会提出获得国家财政经济状况根本好转的条件是土地改革的完成； 现有工商业的调整；国家机构所需经费的大量节减。21、1951 年至 1952 年开展的“三反”运动的主要内容是反贪污、反浪费、反官僚主义。22、1952 年开展的“五反”运动的主要内容是反行贿和反偷税漏税、反盗窃国家资财、反偷工减料、反盗窃国家经济情报。23、新中国成立前夕，中共中央提出的对外方针是另起炉灶、打扫干净屋子再请客的一边倒方针。24、 新中国建立初期， 新民主主义社会的经济成分， 除了社会主义性质的国营经济外， 还有合作社经济、个体经济、私人资本主义经济、国家资本主义经济。25、中华人民共和国成立开辟了中国历史的新纪元。答： 1949 年 10 月 1 日，中华人民共和国的成立，宣告中国人民当家作主的时代已经到来，中国历史由此开辟了一个新纪元。（1）帝国主义列强压迫中国、奴役中国人民的历史从此结束，中华民族一洗近百年来蒙受的屈辱，开始以崭新的姿态自立于世界的民族之林。占人类总数四分之一的中办从此站立起来了。（2）本国封建主义、官僚资本主义统治的历史从此结束，长期以来受尽可能压迫和欺凌的广大中国人民在政治上翻了身，第一次成为新社会、新国家的主人。一个真正属于人民的共和国建立起来了。（3）军阀割据、战乱频仍、匪患不断的历史从此结束，国家基本统一，民族团结，社会政治局面趋向稳定，各族人民开始过上安居乐业的生活。 人民可以集中力量从事经济文化等方面建设的时期开始到来了。（4） 从根本上改变了中国社会的发展方向， 为实现由新民主主义向社会主义的过渡， 创造了前提条件。（5）中国共产党成为全国范围内的执政党。它可以运用国家政权凝聚和调集全国力量，巩固民族独立和人民解放的成果，解放并发展社会生产力，发造福于各族人民，造福于整个中华民族。总之， 中华人民共和国的成立， 标志着中国人新民主主义革命取得了基本的胜利， 标志着半殖民地半封建社会的结束和新民主主义社会在全国范围内的建立。这是马克思主义同中国实际相结合的伟大胜利。 第二节 制定过渡埋藏总路线1、1953 年，中共中央正式提出过渡时期总路线。2、中国共产党在过渡时期总路线的主体是实现国家的社会主义工业化。3、全国胜利并解决了土地问题以后，新民主主义社会的基本矛盾是新中国同学国主义的矛盾；工人阶级和资产阶级的矛盾。4、 在农业合作化运动中， 党和政府领导农民创造的过渡形式有农业生产互助组、 初级农业生产合作社、高级农业生产合作社。5、1949 年至 1952 年期间，开始向社会主义过渡的实际步骤。答： 1949 年至 1952 年期间，在着重完成民主革命的遗留任务的同时，社会主义革命的任务实际上也开始实行了。这主要表现在以下三个方面：（1）没收官僚资本，确立社会主义性质的国营经济的领导地位。（2）开始将资本主义纳入国家资本主义轨道。（3）引导个体农民在土地改革后逐步走上互助合作的道路。 第三节 开辟中国社会主义改造道路1、在农业社会主义改造中建立的初级农业生产合作社属于半社会主义性质。2、毛泽东系统阐明农业合作化理论的重要文献是《关于农业合作化问题》3、我国对资本主义工商业的社会主义改造所采取的基本政策是统购包销。4、 在对资本主义工商业进行社会主义改造过程中， 当个别企业公私合营后， 企业的利润实行四马分肥。5、社会主义改造的基本完成标志着社会主义制度在中国最终确立。6、 我国对个体农业实行社会主义改造必须遵循的原则和采取的方法有自愿互利、 典型示范、 逐步推广。7、我国对资本主义工商业进行社会主义改造所采取的初级形式国家资本主义有加工订货、统购包销、经销代销、公私联营。8、在社会主义改造过程中，我国实行的高级形式的国家资本主义是个别企业的公私合营、全行业公私合营。9、在资本主义工商业改造中，企业的利润分配实行“四马分肥”的办法，除了国家所得税外，还包括企业公积金、工人福利费、股金红利。10、 “一五”期间中国着重建设的三大钢铁基地有鞍山、包头、武汉。11、由新民主主义向社会主义转变的必要条件是（1）中国共产党的政治领导（2）社会主义国营经济的领导地位（3）马克思主义思想文化领域中的指导地位12、中国共产党开展农业合作化运动的基本原则和方针。答：中国共产党关于农业合作化运动的基本原则和方针是：（1）在中国的条件下，可以走先合作化、后机械化的道路。在土地改革基本完成后，及时将“组织起来”作为农村工作的一件大事来抓。（2）充分利用和发挥土改后农民的两种生产积极性，通过互助组、初级农业生产合作社、高级农业生产合作社这种由低到高的互助合作的组织形式，实行积极发展、稳步前进、逐步过渡的方针。（3）农业互助合作的发展，要坚持自愿和互利的原则，采取典型示范、逐步推广的方法，发展一批，巩固一批。（4）要始终把是否增产作为衡量合作社是否办好的标准。（5）要把社会改造同技术改造相结合。在实现农业合作化以后，国家应努力用先进的技术的装备发展农业经济。 第九章 社会主义建设在探索中曲折发展第一节 良好的开局1、1956 年 1 月，中共中央召开关于知识分子问题会议，动员全党和全国人民“向科学进军” 。2、毛泽东在《论十大关系》中提出的中国社会主义建设的基本方针是调动一切积极因素为社会主义事业服务。3、毛泽东《论十大关系》的重要讲话最先发表于 1956 年 4 月 25 日中央政治局扩大会议。4、毛泽东在《论十大关系》中提出社会主义文化建设的新方针是“百花齐放，百家争鸣” ，共产党和其他民主党派要“长期共存，互相监督” 。5、在中共八大上陈支提出探索适合中国特点的经济体制的“三个主体、三个补充”思想。6、毛泽东指出，在社会主义改造完成后，我国政治生活的主题是正确处理人民内部矛盾。7、中国八大坚持的我国经济方针是既反保守，又反冒进，在综合平衡中稳步前进的方针。8、中共八大提出的党和全国人民当前的主要任务是把我国尽快地从落后的农业国变为先进的工业国。9、1957 年春夏一蔬菜 的整风运动的主题是正确处理人民内部矛盾。10、1964 年中国第一颗原子弹爆炸成功。11、八届九中全会上，中共中央正式通过对国民经济实行“调整、巩固、充实、提高”的方针。12、 毛泽东在国共八届九中全会上号召全党大兴调查研究之风， 搞一个实事求是年， 这一年是 1961 年。13、中国同印度、缅甸等国共同倡导的处理国与国关系公认的国际准则是和平共处五项原则。14、毛泽东提出要正确处理人民内部矛盾，主要是为了团结一切力量建设社会主义新国家。15、社会主义改造基本完成后，我国国内的主要矛盾是（1）人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾。（2）人民对于经济文化迅速民菜的需要同当前经济文化不能满足人民需要的状况之间的矛盾16、中共八大提出的政治建设方针有（1）继续加强我国的人民民主专政（ 2）加强国内各民族的团结（3）继续巩固人民民主统一战线 （4）建立健全法制17、毛泽东提出社会主义的基本矛盾是（1）生产关系和生产力之间的矛盾（ 2）上层建筑和经济基础之间的矛盾18、毛泽东在《关于正确处理人民内部矛盾的问题》的讲话中提出，解决人民内部矛盾的方法有民主的方法、说服教育的方法、 “团结——批评——团结”的方法。19、1957 年的整风运动反对的主要是主观主义、宗派主义、官僚主义。20、 《论十大关系》的基本内容及其意义。答： （1） 《论十大关系》的报告，总结经济建设的初步经验，借鉴苏联建设的经验教训，系统地阐述了十大关系。 它围绕一个基本方针， 即： “一定要努力把党内党外、 国内国外的一切积极的因素， 直接的、间接的积极因素，全部调动起来，把我国建设成为一个强大的社会主义国家” 。（2）初步提出了中国社会主义经济建设的若干新方针。其基本精神是要在着重发展重工业和国防工业的同时，大力发展同国计民生密切相关的轻工业、农业，并且充分发挥中央和地方、沿海与内地两方面的建设积极性。 这实际上涉及了经济体制的改革。 在社会主义政治建设方面，提出共产党和其他民主党派要实行“长期共存，互相监督”的方针，在肃反中坚持“一个不杀、大部不捉”的方针。在讨论报告的过程中， 还提出了社会主义文化建设的新方针—— “双百” （百花齐放、 百家争鸣） 方针。（3）意义： 《论十大关系》 是以毛泽东为主要代表的中国共产党人开始探索中国自己的社会主义建设道路的标志。它在新的历史条件下从经济方面（这是主要的）和政治方面提出了新的指导方针，为中共八大的召开作了理论准备。 第二节 探索中的严重曲折1、人民公社化的基本特点是“一大二公” 。2、1971 年林彪反革命集团策动反革命武装政变终至失败。3、发动和领导“文化大革命”的主要论点，被概括为无产阶级专政下继续革命的理论。4、发动“文化大革命”的导火线是姚文元在《文汇报》上发表《评新编历史剧〈海瑞罢官〉 》 。5、1975 年邓小平开始着手对各方面工作进行整顿。6、毛泽东探索中国社会主义建设道路出现严重失误的原因主要是（1）缺乏社会主义建设的经验（ 2）把本不属于阶级斗争的问题看作是阶级斗争（3）民主集中制和集体领导原则遭到破坏（ 4）对什么是社会主义，如何建设社会主义没有完全搞清楚7、1959 年到 1961 年中国国民经济发生严重困难的主要原因是（1）自然灾害的影响（ 2） “大跃进”和“反右倾”斗争的错误（ 3）苏联政府撕毁合同、撤走专家8、集中体现毛泽东探索中国社会主义建设道路所取得的理论成果的著作有《论十大关系》 、 《关于正确处理人民内部矛盾的问题》 。9、从“一五”时期到 1976 年，涌现出大量英雄模范人物，主要代表有焦裕禄、王进喜、雷锋等。10、毛泽东提出的我国对待古今中外一切文化成果的方针是古为今用、洋为中用。11、 “大跃进”运动中所犯的“左”倾错误的主要示志是高指标、瞎指挥、浮夸风、 “共产风”。12、20 世纪 50 年代被称为“三面红旗”的是总路线、 “大跃进”、人民公社。13、 在粉碎江青反革命集团， 结束“文化大革命” 的斗争中作出了重要贡献的党和国家领导人有华国锋、叶剑英、李先念。14、以毛泽东为主要代表的中国共产党人的在探索中国社会主义建设道路中有哪些失误？答： （1）以毛泽东为主要代表的中国共产党人在探索中国社会主义建设道路中出现的失误主要是：“大跃进”和人民公社化运动的发动： 1957 年开始的“大跃进”运动的开展，使以高指标、瞎指挥、浮夸风和“共产风”为主要标志的“左”倾错误严重地泛滥开来，严重地破坏了国民经济各部门的综合平衡。同时开展的以“一大二公”为特点的农村人民公社化运动，严重地脱离农村的生产力水平，致使“一平二调”之风泛滥，损害了广大的社员和小集体的利益。1959 年 8 月，错误地开展了“反右倾”斗争，使纪“左”进程中断。主要由于“大跃进”和“反右倾”斗争的错误，加上当时的自然灾害和苏联政府背信弃义地撕毁合同、撤走全部专家，中国国民经济在1959 年到 1961 年发生严重困难。1963 年至 1965 年，在多数城乡发起了社会主义教育运动。这场运动，虽然对于解决干部作风和经济管理等方面的问题起了一定作用， 但由于把这此问题都作为阶级斗争或者是阶级斗争在党内的反映来处理，曾使不少基层干部受到不应有的打击。1966 年 5 月至 1976 年 10 月的“文化大革命” ，是一场由领导者错误发动，被反革命集团利用，给党、国家和各族人民带来严重灾难的内乱，是全局性的、长时间的“左”倾严重错误。它使中国共产党、国家和人民遭到新中国成立以来最严重的挫折和损失。 第三节 建设的成就，探索的结果1、1971 年中国在外交领域的重大成就是恢复在联合国的合法席位。2、1972 年，先后同中国建立大使级外交关系的国家有英国、荷兰、希腊、联邦德国。3、20 世纪六、七十年代，我国在核技术、人造卫星和运载火箭等尖端科学技术领域取得的重要成就包括爆炸了第一颗原子弹、 中近程地地导弹发射成功、 爆炸了第一颗氢弹、 第一颗人造地球卫星发射成功。4、同中国共同倡导的和平共处五项原则的国家是印度、缅甸。5、新中国的社会主义建设取得了哪些成就？答： （ 1）基本建立了独立的、比较完整的工业体系和国民经济体系，从根本上解决了工业化中“从无到有”的问题。从“一五”计划开始，国家建成了一批门类比较齐全的基础工业项目，为国民经济的进一步发展打下了坚实的基础，使中国在赢得了政治上的独立之后赢得了经济上的独立。（2）人民生活水平得到提高，文化、医疗、科技事业不断发展。初步满足了占世界 1/4 人口的基本生活需求。文化、教育、医疗、科技事业得到长足的发展。在核技术、人造卫星和运载火箭等尖端科学技术领域，取得了一系列重要的成就， 1964 年 10 月，中国爆炸了第一颗原子弹。 1966 年 10 月，装有核弹头的中近程地导弹发射成功。 1967 年 6 月，爆炸了第一颗氢弹。 1970 年 4 月，第一颗人造地球卫星发射成功。（3）国际地位得到提高，国际环境得到改善。 1950 年至 1953 年的抗美援朝战争，以及随后召开的日内瓦国际会议和万隆会议，极大提高了新中国的国际地位；中国同印度、缅甸等国倡导的平共处五项原则，成为处理国与国关系的公认的国际准则。 1971 年 10 月，中国恢复了在联合国的合法席位。 20 世纪70 年代，中美、中日关系正常化。 1972 年出现了西方国家对华建交热潮，同中国建交的国家，从 1965年的 49 个增加到 1976 年的 111 个。 第十章 改革开放和现代化建设新时期第一节 历史性伟大转折和改革开放的起步1、中共十届三中全会作出了《关于恢复邓小平同志职务的决议》 。2、1978 年 5 月 11 日，开始了关于趔标准问题的讨论。3、中共十一届六中全会对毛泽东和毛泽东思想的历史地位作出了科学的评价。4、1978 年 12 月 13 日，邓小平在中央工作会议闭幕会作了《解放思想，实事求是，团结一致向前看》的重要讲话。5、党的十一届六中全会通过的《关于建国以来党的若干历史问题的决议》中国如何对毛泽东和毛泽东思想进行评价的？答： （1）1981 年 6 月，中共十一届六中全会通过了《关于建国以来党的若干历史问题的决议》 。（2）决议科学地评价了毛泽东和毛泽东思想的历史地位，指出：毛泽东同志是伟大的马克思主义者，是伟大的无产阶级革命家、战略家和理论家。他的功绩是第一位的，错误是第二位的。他为中国共产党和中国人民解放军的创立和发展， 为中国各族人民解放事业的胜利， 为中华人民共和国的缔造和中国社会主义事业的发展，建立了永远不可磨灭的功勋。（3）决议对毛泽东思想的科学体系和活的灵魂 （即实事求是、 群众路线、 独立自主） 作了概括， 指出：毛泽东思想是马克思列宁主义在中国的运用和发展， 是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶。决议强调： “毛泽东思想是我们党的宝贵的精神财富，它将长期指导我们的行动。 ” 第二节 改革开放和现代化建设新局面的展开1、统分结合的农村家庭联产承包责任制的普遍实行促进人民公社体制解体。2、2001 年 12 月中国正式加入世界贸易组织。3、中共十一届三中全会的主要内容有（1）否定了“以阶级斗争为纲”的“左”的错误方针（2）确定了把工作重点转移到社会主义现代化建设上来和实行改革开放的战略决策4、1983 年 10 月，中共中央就农村体制改革问题作出的重大决定是废除人民公社；建立乡（镇）政府作为基层政权；成立村民委员会作为村民自治组织。5、邓小平提出的政治体制改革的基本思路是什么？答： （ 1）1980 年 8 月，邓小平在中共中央政治局扩大会议上发表 《党和国家领导制度的改革》 的讲话，分析了党和国家领导体制中存在的问题和弊端，提出了政治体制改革的基本任务。 1986 年，他又在多次讲话中阐明了政治体制改革的基本思路。（2）政治体制改革要认真解决官僚主义、权力过分集中、党政不分、事实上存在的领导职务终身制等问题， 认真肃清封建主义残余影响和资产阶级思想影响， 发展社会主义民主，调动广大人民群众的积极性。（3）政治体制改革是社会主义制度的自我完善，必须以四荐基本原则为指导，遵循统一领导、循序渐进的原则，在中国共产党的领导下有步骤、有秩序地推进；必须坚持从本国国情出发，总结本国的实践经验，同时借鉴人类政治文明的有益成果。 绝不应照搬西方政治制度的模式， 绝不能搞资产阶级自由化。（4）根据邓小平提出的上述基本思路， 1987 年 10 月，中共十二届七中全会讨论并原则通过中央制定的《政治体制改革总体设想》 。 第三节 改革开放和现代化建设发展的新阶段1、邓小平在《目前的形势和任务》的讲话中提出中国人民长期奋斗的三件大事是维护世界和平、实现祖国统一、加紧现代建设。2、1980 年 5 月，中央决定开辟的沿海经济特区深圳、珠海、汕头、厦门。3、1985 年 2 月，中央决定开辟的沿海经济开放区为珠江三角洲、闽南厦门泉州漳州三角地区、长江三角洲。4、邓小平南方谈话的主要内容和意义是什么？答： （1）1992 年 1 月 18 日至 2 月 21 日，邓小平先后视察武昌、深圳、珠海、上海等地，发表重要谈话，其主要内容是：强调革命是解放生产力，改革也是解放生产力。基本路线要管一百年，动摇不得。判断改革开放程度的标准，应该主要看是否有利于发展社会主义社会的生产力，是否有利于增强社会主义国家的综合国力，是否有利于提高人民的生活水平。强调计划和市场都是经济手段。 计划多一点还是市场多一点， 不是社会主义与资本主义的本质区别。 社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。强调发展才是硬道理。抓住时机，发展自己，关键是发展经济。他指出，科学技术是第一生产力。高科技领域，中国也要在世界占有一席之地。强调要坚持两手抓，一手抓改革开放，一手抓打击各种犯罪活动。这两只手都要硬。在整个改革开放过程中都要反对腐败。强调我国的社会主义还处在初级阶段。巩固和发展社会主义制度 ，还需要一个很长的历史阶段。我们要在建设有中国特色的社会主义道路上继续前进。从现在起到下世纪中叶，将是很要紧的时期 ，我们要埋头苦干。(2)邓小平南方谈话，在重大历史关头，科学地总结了十一届三中全会以来党的基本实践和基本经验，明确回答了长期困扰和束缚人们思想的许多重大认识问题， 对整个社会主义现代化建设事业产生了重大而深远的影响。 第四节 全面建设小康社会1、1997 年 7 月 1 日香港回归祖国。2、中共十二大提出把我国建设成为高度文明、高度民主的社会主义国家的目标。3、 中共十二届三中全会通过 《关于经济体制改革的决定》 ， 标志着经济体制改革以城市为重点全面展开。4、1988 年 4 月海南省正式建立。5、邓小平提出中国社会主义农业的改革和发展会有两个飞跃。6、江泽民在庆祝中国共产党成立 80 周年大会上系统阐述了“三个代表”重要思想。7、试述走和平发展的道路思想的基本内涵和重大意义。答： （1）2004 年 8 月，胡锦涛在纪念邓小平同志诞辰一百周年大会上的讲话中提出，要高举和平、发展、合作的旗帜，坚持走和平发展的道路。 2005 年 11 月，他在英国伦敦金融城发表演讲，系统地阐述了走和平发展道路的基本内涵和重大意义。（2）坚持走和平发展的道路，就是中国既通过争取和平的国际环境来发展自己，又通过自己的发展来促进世界和平， 永远做维护世界和平、促进共同发展的坚定力量。 主要依靠自身力量和改革创新来实现发展， 同时坚持对外开放的基本国策，在平等互利的基础上同世界各国开展交流合作， 努力实现互利共赢。中国同国际社会其他成员携手努力，为实现各国和谐相处、全球经济和谐发展、不同文明和谐进步的美好前景发挥积极作用，共同致力于建设一个持久和平、共同繁荣的和谐世界。 第五节 改革开放和社会主义现代化建设的成就1、科学发展观的核心是以人为本。2、全国范围内取消农业税始自 2006 年。3、胡锦涛在英国伦敦金融城发表演讲，系统地阐述走和平发展道路的基本内涵和重大意义。4、社会主义荣辱观的主要内容是“八荣八耻” 。5、中国共产党正式提出科学发展观的会议是十六届三中全会。6、科学发展观的基本要求是全面协调可持续发展。7、1978 年 12 月中共十一届三中全会以来改革开放新时期的最突出的标志是与时俱进。8、改革开放以来，中国共产党领导中国人民取得一切成绩和进步的根本原因是（1）开辟了中国特色社会主义道路（ 2）形成了中国特色社会主义理论体系9、试述科学发展观的主要内容。答： （1）2007 年 6 月 25 日，胡锦涛在中央党校发表重要讲话，系统阐述了科学发展观的丰富内涵和根本要求。科学发展观，第一要义是发展，核心是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。（2）科学发展观是以胡锦涛为总书记的中共中央坚持以邓小平理论和“三个代表”重要思想为指导，从新世纪新阶段党和国家事业发展全局出发提出的重大战略思想。科学发展观同马克思列宁主义、毛泽东思想、邓小平理论、 “三个代表”重要思想关于发展的思想一脉相承，是对经济社会发展一般规律的认识的进一步深化， 是指导发展的世界观和方法论的集中体现，是推进社会主义经济建设、 政治建设、文化建设、社会建设全面发展的指导方针。 中国近现代史大事年表1839 年 林则徐虎门销烟1840 年 -1842 年 鸦片战争1841 年 5 月 广州三元里人民痛击英国侵略者1842 年 《中英南京条约》签订，鸦片战争结束19 世纪 40-50 年代 中国无产阶级产生1844 年 《中美望厦条约》 、 《中法黄埔条约》签订1851 年 金田起义 太平天国建立1853 年 太平天国定都天京《天朝田亩制度》颁布1856 年 太平天国领导集团内部互相残杀1856-1860 第二次鸦片战争1858 年 清政府分别与英、法、美、俄签定《天津条约》1859 年 洪仁玕向洪秀全进呈《资政新篇》1860 年 清政府分别与英、法、俄签订《北京条约》1861 年 北京政变1861 年 总理衙门成立1862 年 京师同文馆成立1864 年 天京陷落，太平天国运动失败19 世纪 60-70 年代 中国民族资产阶级产生19 世纪 60-90 年代 洋务运动1883-1885 年 中法战争1894-1895 年 甲午中日战争1895 年 中日《马关条约》签定19 世纪 90 年代 帝国主义国家掀起瓜分中国的狂潮1898 年 戊戌变法1900 年 义和团运动高潮1900 年 八国联军侵华战争1901 年《辛丑条约》签定1905 年 中国同盟会成立1911 年 黄花岗起义1911 年 保路运动1911 年 10 月 10 日 武昌起义1912 年（民国元年） 中华民国成立1912 年 清帝退位1913 年 二次革命1915 年 护国运动开始1915 年 新文化运动开始1916 年 袁世凯恢复帝制失败1917 年 张勋复辟失败1917 年 护法运动开始1919 年 5 月 4 日 五四爱国运动爆发1921 年 7 月中国共产党成立1922 年初 香港中国海员大罢工1922 年 7 月 中国共产党第二次全国代表大会召开1923 年 京汉铁路工人大罢工1924 年 中国国民党第一次全国代表大会1924 年 国共两党第一次合作实现1925 年 孙中山逝世1925 年 五卅惨案、五卅反帝爱国运动爆发1926 年 国民革命军出师北伐1927 年 3 月 上海工人第三次武装起义胜利1927 年 4 月 12 日 蒋介石发动“四一二”反革命政变1927 年 7 月 15 日 汪精卫发动“七一五”反革命政变1927 年 7 月 国民革命失败1927 年 4 月 蒋介石在南京建立国民政府1927 年 8 月 1 日 南昌起义1927 年 8 月 7 日 八七会议1927 年 8 月 湘赣边秋收起义1927 年 8 月 秋收起义部队到达井冈山1927 年底 广州起义1928 年 4 月 井冈山会师1928 年 张学良宣布东北易帜1931 年 九一八事变1931 年 中华苏维埃共和国临时中央政府成立1932 年 一. 二八事变、十九陆军抗战1932 年 伪满洲国成立1934 年 10 月 中央红军开始长征1935 年 1 月 遵义会议1935 年 中共中央发表八一宣言1935 年 10 月 红军第一方面军长征到达陕北1935 年 一二 . 九运动1936 年 10 月 红军第二、四方面军长征到达甘肃会宁等地，长征结束1936 年 12 月 12 日 西安事变1937 年 7 月 7 日 卢沟桥事变1937 年 八一三事变1937 年 9 月 凇沪会战1937 年 平型关大捷1937 年秋 中国共产党陕北洛川会议1937 年 12 月 南京大屠杀1938 年春 台儿庄战役1938 年 毛泽东发表《论持久战》1940 年 3 月 汪精卫伪国民政府在南京成立1940 年 百团大战1941 年 皖南事变1942 年 中国共产党开始整风1945 年 中国共产党第七次全国代表大会召开1945 年 8 月 15 日 日本宣布投降1945 年 中共和谈代表毛泽东等飞抵重庆，重庆谈判开始1945 年 双十协定签字1946 年 政治协商会议召开1946 年 6 月 国民党发动全面内战，人民解放战争开始1947 年 6 月 人民解放军开始全国规模的反攻1948 年 9 月 辽沈战役开始1948 年 11 月 淮海战役开始1948 年 11 月 平津战役开始1949 年春 中国共产党七届二中全会召开1949 年 4 月 21 日 毛泽东、朱德发布向全国进军的命令1949 年 4 月 23 日 人民解放军解放南京，国民政府覆亡1949 年 9 月 中国人民政治协商会议第一次全体会议开展1949 年 10 月 1 日 中华人民共和国成立1950 年 10 月 中国人民志愿军赴朝作战1950 年 中苏签定 &lt;&lt;中苏友好同盟互助条约 &gt;&gt;1950 年 中央人民政府颁布 &lt;&lt;中华人民共和国土地改革法 &gt;&gt;1951 年 西藏和平解放1952 年 土地改革基本结束 , 彻底废除我国两千多年的封建剥削制度1953 年 第一个五年计划开始实行1953 年 朝鲜战争结束 , 抗美援朝胜利1954 年 4 月至 7 月 日内瓦会议1955 年 万隆会议1954 年 9 月 第一届全国人民代表大会召开 ,&lt;&lt; 中华人民共和国宪法 &gt;&gt;颁布1956 年 我国对生产资料私有制的社会主义改造基本完成 ( 三大改造完成 )中国共产党第八次全国代表大会召开中国第一个生产载重的工厂——长春第一汽车制造厂生产出第一辆汽车中国第一个飞机制造厂试制成功第一架喷气式飞机中国第一个制造机床的工厂——沈阳第一机床厂建成投产1957 年 武汉长江大桥建成1958 年 党中央提出 “鼓足干劲 , 力争上游 , 多快好省地建设社会主义 “ 的总路线1961 年春 党和政府全面调整国民经济 , 恢复发展生产1964 年 10 月 16 日 我国第一颗原子弹爆炸成功1966 年 “ 文化大革命 “ 开始1967 年 1 月 全国各地掀起夺取党政各级领导权 “ 一月风暴 “1967 年 我国第一颗氢弹爆炸成功1969 年 11 月 12 日 刘少奇逝世1970 年 我国成功发射第一颗人造地球卫星 ——— 东方红 1 号1971 年 粉碎林彪反革命集团1971 年 10 月 25 日 我国在联合国合法席位得到恢复1971 年 7 月 基辛格访华1972 年 田中角荣访华 , 中日建交1972 年 &lt;&lt; 中美联合公报 &gt;&gt;发表1976 年 10 月 粉碎江青反革命集团 ,” 文化大革命 “ 结束1978 年 中国共产党第十一届三中全会召开1979 年 中美建交1980 年 中共中央为刘少奇恢复名誉 , 我国在广东的深圳 , 珠海 , 汕头和福建的厦门建立经济特区1980 年 8 月 12 日 刘少奇追悼会在首都人民大会堂召开1982 年 颁布第四部 &lt;&lt;中华人民共和国宪法 &gt;&gt;颁布 &lt;&lt;中华人民共和国民法通则 &gt;&gt;和&lt;&lt;中华人民共和国刑法 &gt;&gt;1982 年底 大规模平反冤假错案工作基本结束1990 年 中国首次成功举办亚洲运动会 易班题库错题记录第一二章——“三国干涉还辽”中的“三国”指的是：“俄、德、法”三国。——控制中国海关时间最长的外国人是：赫德。——资本一帝国主义列强在中国设立的最早的租界是在：上海。——基督教在中国设立的最大出版机构广学会发行的报刊是：《万国公报》——郑观应在《盛世危言》中提出大力发展民族工商业，同西方国家进行“商战”，设立议院，实行“君民共主”制度等主张——外国教会在中国创办较早的外文期刊是：《中国丛报》——认识中国近代一切社会问题和革命问题的最基本的依据是认识：中国近代社会半殖民地半封建的性质——近代中国面临的两大历史任务是：争取民族独立、人民解放和实现国家繁荣富强、人民富裕——太平天国后期担任军事指挥的青年将领：陈玉成﹑李秀成——太平军破清军江北，江南大营表明太平天国在军事上达到全盛时期——洋务派兴办洋务事业的指导思想是：中学为体，西学为用(中体西用)——认为太平天国﹑捻军等农民起义是“心腹之害”的人的是：奕䜣——19世纪60年代，清朝统治集团中倡导洋务的首领人物是：奕诉——由李鸿章管辖的清政府海军主力是：北洋水师——洋务派兴办的军用工业中，当时国内最大的兵工厂是：上海江南制造总局——近代中国派遣第一批留学生是在：洋务运动时期——张之洞发表的对抗维新变法、反复强调封建的纲常伦理不可变的代表作是：《劝学篇》——谭嗣同在戊戌维新时期撰写的宣传变法维新主张的著作是：《仁学》——戊戌维新时期，梁启超的主要著述是：《变法通议》——在近代中国掀起第一次思想解放的潮流是：戊戌变法运动——康有为创立的宣传维新思想的新式学堂是：万木草堂——洋务运动期间经营洋务事业最多的是：李鸿章——在清政府实行的“清末新政”中，科举制度被最终废除 第三章——章炳麟发表了《驳康有为论革命书》，反对康有为的保皇观点。——邹容写了《革命军》，号召推翻清朝封建专制统治，建立中华共和国。——舆论阵地：革命派-《民报》、改良派-《新民丛报》——资产阶级革命派在辛亥革命前发动了多次武装起义。其中影响最大的是1911年4月的：黄花岗起义——发起武昌起义的两个革命团体：共进会、文学社。——武昌起义的主要力量是：新军——兴中会立誓：驱除鞑虏，恢复中国，创立合众政府。——同盟会的政治纲领：驱除鞑虏，恢复中华，创立民国、平均地权。——“民国元年”是指：1912年（南京国民政府成立）——中国历史上第一部具有资产阶级共和国宪法性质的法典：《中华民国临时约法》——1914年，孙中山在日本组织的政党是：中华革命党——在云南组织“护国军”，发起护国运动的是：蔡锷——1915年5月，袁世凯和日本签订了丧权辱国的：二十一条——中国资产阶级领导的旧民主主义革命终结的标志：护法运动的失败","categories":[{"name":"备忘录","slug":"备忘录","permalink":"https://cnatom.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"}],"tags":[{"name":"近现代史","slug":"近现代史","permalink":"https://cnatom.github.io/tags/%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2/"}]},{"title":"【C++】作业中的一些琐碎知识","slug":"【C-】作业中的一些琐碎知识","date":"2019-12-22T01:04:57.000Z","updated":"2020-01-27T16:29:08.947Z","comments":true,"path":"2019/12/22/【C-】作业中的一些琐碎知识/","link":"","permalink":"https://cnatom.github.io/2019/12/22/%E3%80%90C-%E3%80%91%E4%BD%9C%E4%B8%9A%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/","excerpt":"","text":"函数：判断是否为素数12345678910bool is_prime(int num)&#123; int i; int s=sqrt(num); for(i=2;i&lt;=s;i++) &#123; if(num%i==0) return false; &#125; return true;&#125; 函数：计算num的因子和因子概念：假如整数n除以m，结果是无余数的整数，那么我们称m就是n的因子。反过来说，我们称n为m的倍数 其中因子和为包括1但不包括n本身的所有因子之和 123456789int fac_sum(int num)&#123; int i,ans=0; for(i=1;i&lt;num;i++) &#123; if(num%i==0) ans+=i; &#125; return ans;&#125; 函数：判断回文数的两种写法1234567891011121314151617181920212223//将回文数看作整形数据（在这里010就是10,10不是回文数）bool is_palindromic(int num)&#123; int ans=0,copy=num; while(copy) &#123; ans*=10; ans+=copy%10; copy/=10; &#125; return ans==num?true:false;&#125;//将回文数看作字符串（这样的话010也是回文数）bool is_palindromic(string s)&#123; int l=0,r=s.length()-1; while(l&lt;=r) &#123; if(s[l++]==s[r--]) continue; else return false; &#125; return true;&#125; 过程设计：数组的去重复制将含有nx个元素的数组x中的数据复制到数组y中，重复的数据只存储一次，最后输出y中的数据。（两种思路） 123456789101112131415161718192021222324252627282930313233343536373839404142//思路一：比较笨的，挨个遍历查重int main()&#123; int x[50],y[50],ny=0,nx; bool flag; cin &gt;&gt; nx; for(int i=0;i&lt;nx;i++) cin &gt;&gt; x[i]; for(int i=0;i&lt;nx;i++) &#123; flag = true; for(int j=0;j&lt;ny;j++) if(x[i]==y[j]) flag = false; if(flag) y[ny++]=x[i]; else continue; &#125; for(int i=0;i&lt;ny;i++) cout &lt;&lt; y[i]&lt;&lt; \" \"; return 0;&#125;//思路二：用桶来存储数据的存在性，效率高，但是范围比较小。int main()&#123; const int MAXSIZE = 300000; int x[50],y[50],ny=0,nx; bool flag[MAXSIZE] = &#123;false&#125;; cin &gt;&gt; nx; for(int i=0;i&lt;nx;i++) &#123; cin &gt;&gt; x[i]; flag[x[i]]=true; &#125; for(int i=0;i&lt;nx;i++) &#123; if(flag[x[i]]==true) &#123; y[ny++] = x[i]; flag[x[i]]=false; &#125; else continue; &#125; for(int i=0;i&lt;ny;i++) cout &lt;&lt; y[i] &lt;&lt; \" \"; return 0;&#125; 函数：利用二维的指针遍历二维数组1234567891011121314151617void fun2(int (*p)[4],int n,int m)&#123; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cout &lt;&lt; p[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; &#125;int main()&#123; int a[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;; fun2(a,3,4); return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验课结课考试题解","slug":"C-实验结课考试","date":"2019-12-21T14:03:00.000Z","updated":"2020-01-27T16:30:29.630Z","comments":true,"path":"2019/12/21/C-实验结课考试/","link":"","permalink":"https://cnatom.github.io/2019/12/21/C-%E5%AE%9E%E9%AA%8C%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95/","excerpt":"只记得一道面向过程的题，面向对象的那个忘了。","text":"只记得一道面向过程的题，面向对象的那个忘了。 【题目大概描述】输入一串非数字的字符串，将其“解压”。比如说”3a”解压后为”aaa”,”4d”解压后为”dddd”，如果是一串数字后面加一个空格，比如”2 “，那么就输出两个空格。 【样例输入】 abcd3e4 se11z 【样例输出】 abcdeee sezzzzzzzzzzz 【样例输出说明】 中间的空格字符有４个 【可能的题解】 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;//判断字符c是否为数字 bool is_num(char c)&#123; return (c&gt;='0'&amp;&amp;c&lt;='9')?true:false;&#125;//将字符c打印num遍 void print(char c,int num)&#123; int i; for(i=0;i&lt;num;i++) cout &lt;&lt; c;&#125;int main ()&#123; char s[501]; cin.getline(s,501); for(int i=0;s[i]!='\\0';i++) &#123; if(is_num(s[i]))//如果遇到数字，就将数字保存到temp内 &#123; int temp=0; for(;is_num(s[i]);i++) &#123; temp*=10;//将temp乘10，留出个位数来存数 temp+=s[i]-'0'; &#125; print(s[i],temp); &#125; else cout &lt;&lt; s[i]; &#125; return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【MOOC】易错题汇总","slug":"【mooc】易错题汇总","date":"2019-12-19T02:52:00.000Z","updated":"2020-01-27T16:38:43.269Z","comments":true,"path":"2019/12/19/【mooc】易错题汇总/","link":"","permalink":"https://cnatom.github.io/2019/12/19/%E3%80%90mooc%E3%80%91%E6%98%93%E9%94%99%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"还有哪些错题，欢迎在评论区补充，或者QQ私我。","text":"还有哪些错题，欢迎在评论区补充，或者QQ私我。 派生类构造函数的成员初始化列表中，不能包含的初始化项是（）。 这里所说的“基类的子对象”即基类的数据成员 在C＋＋中，构造函数不能被继承，因此，派生类的构造函数必须通过调用基类的构造函数来初始化基类子对象。在派生类初始化列表直接初始化基类的成员，被称为“越级初始化”，是会报错的。 举个栗子：我们先创建一个基类，里面有一个int型子对象 1234567class A&#123; protected: int n;//基类的子对象 public: A(); A(int temp):n(temp)&#123;&#125;&#125;; 然后创建一个派生类，并用派生类构造函数的初始化列表来进行“越级初始化” 1234class B:public A&#123; public: B(int temp):n(temp)&#123;&#125;//对基类子对象n进行初始化&#125;; 在主函数中调用 12345int main()&#123; B(1); return 0;&#125; 结果报错：[Error] class ‘B’ does not have any field named ‘n’ 所以越级初始化是不可以的，但是可以“越级赋值”（自造名词哈哈） 123456class B:public A&#123; public: ///B(int temp):n(temp)&#123;&#125; ///改为 B(int temp)&#123;n=temp&#125;;&#125;; 这样就可以完美运行了。 因此，派生类的构造函数必须通过调用基类的构造函数初始化基类成员，不能够在派生类初始化列表直接初始化基类的成员 类模板与模板类的区别 回顾一下基本概念 ——类模板是指： 1234template &lt;class T&gt;class A&#123;...........&#125;; ——类模板实例化:从通用的类模板定义中生成类的过程称为模板实例化，如：所以说题目中D选项就是错误的，类模板实例化出来的是类的实例，而不是对象。 ——模板类是啥？？ 参考一下《C++ Primer Plus》解释： 也就是说： 123Stack&lt;int&gt; obj;//Stack&lt;int&gt;是模板类//而obj是由这个模板类所声明的一个对象 所以说A.C选项是错误的，产生的模板类应该是tanytemp&lt;int&gt; 我认为此答案可能错误，欢迎在评论区批评指正！ 关于this指针的描述这个题看走眼了啊啊啊啊啊啊啊 ——C选项：形参(obj)到实参(this)的拷贝过程中才创建this指针(实参)，由系统自动生成 ——D选项：this指针的显示使用： 12345678class A&#123; private: int num; public: A(int num=0)&#123; this-&gt;num = num;//显示使用了this指针 &#125;&#125; 刚刚在敲上述代码的时候发现了一个问题，如果构造函数这样写： 1A(int num=0):this-&gt;num(num)&#123;&#125; 就会爆出两个错误： 12[Error] expected &#39;&#123;&#39; before &#39;this&#39;[Error] expected identifier before &#39;this&#39; 产生了一个新的问题，“能不能在构造函数的初始化列表使用this指针？” 带着疑问，搜了一下网上的解释： 但是通过刚刚的例子，可以明显的看出，在构造函数的初始化列表中是不能用this指针的。具体原因，等以后重新翻看文档寻找答案（貌似涉及到底层的东西？） 类在什么时候产生对象？ 产生对象的几种情况： 123example x(5);//类名 对象名;example arr[2] = &#123;1,2&#125;;//数组的方式，产生两个x=example(15);//用example(15)生成一个临时对象，再将对象赋给同类对象x 不禁让我想起了另一个题 这里只是定义了三个PAT型的指针，并没有产生任何对象，调用构造函数也就无从谈起了。","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://cnatom.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】期末考备忘录","slug":"【C-】期末考备忘录","date":"2019-12-18T12:45:00.000Z","updated":"2019-12-25T05:04:00.000Z","comments":true,"path":"2019/12/18/【C-】期末考备忘录/","link":"","permalink":"https://cnatom.github.io/2019/12/18/%E3%80%90C-%E3%80%91%E6%9C%9F%E6%9C%AB%E8%80%83%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"有什么补充或质疑欢迎在评论区指出来。","text":"有什么补充或质疑欢迎在评论区指出来。 类 I——若在类体内没有指明访问权限，默认的访问权限为private。——类是一种数据类型，系统并不会为其分配内存空间。——构造函数重载：同名不同参——带有子对象的构造函数的执行顺序：https://blog.csdn.net/qq_15989473/article/details/103215333 拷贝构造函数——拷贝构造函数的定义 12Sample(Sample &amp;S)//名称与类名相同，形参为本类的引用对象。 ——拷贝构造函数的三种调用情况： 12345678// 1&amp;2.同类对象的初始化Sample S2(S1);Sample S2 = S1;// 3.对象作为函数的参数进行传递void f(A a)&#123;a.x = 1;&#125;;A obj; f(obj);//相当于A a = obj;// × 赋值不是初始化，未调用拷贝构造函数S2 = S1; 析构函数——析构函数不能重载 12~A(); //析构函数声明A::~A()&#123;&#125; //析构函数定义 ——析构函数和构造函数的调用顺序相反 静态成员——静态数据成员只能在类体内声明，类体外初始化（假如有一个类Sample） 12static int num; //类体内声明，需要static关键词int Sample::num = 1; //类体外初始化，不需要static关键词 ——静态成员的访问有两种方式：类名::函数名(); 或者 对象名.函数名()； 12Sample::function();obj.function(); 推荐用第一种，因为指明了静态成员是属于整个类的。 ——非静态成员函数可以任意访问静态和非静态成员 ，静态成员函数只能访问静态成员(数据成员或成员函数) 类 II——系统给对象分配的内存只是用来存储数据成员的。成员函数的代码统一放在程序的代码区 this指针——this指针是指向本类对象的指针。——this指针是在用对象引用成员函数时系统自动创建的。——this指针是被隐式定义在非静态成员函数的形参中。——类的静态成员函数没有this指针。因为静态成员函数为类的所有对象所共有，不专属于某一个对象。所以在静态成员函数中不能直接访问非静态数据成员（因为没有this指针） 各种“常”——常数据成员的初始化必须要用构造函数的初始化列表完成。 12Sample(int temp)&#123;const_num = temp;&#125; // ×Sample(int temp):const_num(temp)&#123;&#125; // √ 常成员函数——只能调用const成员函数。——可以使用const与非const数据成员，但不能修改。 12345678int function() const; //声明int Sample::function() const //类体外的定义&#123; num = 0; //错误，不可修改数据成员。 unconst_function();//错误，不可调用非const成员函数 const_function();//只能调用const成员函数 return num;//正确，可以使用数据成员（const非const都可）&#125; 常对象——常对象是指对象的数据成员的值在对象被调用时不能被改变。常对象必须进行初始化，且不能被更新。 12345//定义格式（必须进行初始化）const Sample obj1(1,1);Sample const obj2(0,0);obj1.unconst_set(2,2);//错误，常对象不能调用非const成员函数obj1.const_print();//只能调用const成员函数 指向对象的常指针123456//指向对象的常指针Sample *const pr = &amp;obj1;//pr只能指向对象obj1pr = &amp;obj2;//错误,指针值不可改变//但是可以改变对象obj的值,如:pr-&gt;function(2); 指向常对象的指针变量(指针值可以改变)123//指向常对象的指针变量const Sample *pr = &amp;obj1;//不能通过pr去修改obj1的空间 注意与常指针相区分 总结 各种“常” 含义 成员函数 数据成员 void Sample::function() const function为常成员函数 只能调用const成员函数 常变量都可以使用(包括private)，但不能改变其值 const Sample&amp; s=obj; s是常引用，可以认为把对象obj的属性变成了const 与常对象权限相同 与常对象权限相同 const Sample *pr pr是指向常对象的指针 与常对象权限相同 与常对象权限相同 Sample const obj obj为常对象 只能调用const成员函数 常&amp;变量都可以使用(前提public)，但不能改变其值 Sample *const pr=&obj; pr为常指针(指针值不可以改变) const &amp; 非const 都可调用，形式:pr-&gt;function(); const &amp; 非const 都可调用，形式:pr-&gt;number; 友元友元函数（此处源代码来自菜鸟教程 原链接）——友元函数并不是成员函数，但有权访问私有、保护和公有成员（所有成员）。——友元函数在类内声明，在类外定义——友元函数不能直接访问类的成员，只能访问对象成员。——调用友元函数时，在实际参数中需要指出要访问的对象。如下述printWidth函数中的形参Box box——类与类之间的友元关系不能继承。（也就是说基类的友元函数继承不到派生类中） 123456789101112131415161718192021222324252627class Box&#123; double width;public: double length; //在类内用friend关键词声明友元函数。 //此处只能声明，不能定义，因为Box类还未定义。 friend void printWidth( Box box ); void setWidth( double wid );&#125;;//在类外像定义普通函数一样定义友元函数//不需要使用 类名:: 作用域符号（只有成员函数采用作用域符号）void printWidth( Box box )&#123; /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */ cout &lt;&lt; \"Width of box : \" &lt;&lt; box.width &lt;&lt;endl;&#125;int main()&#123; Box b; // 使用成员函数设置宽度 b.setWidth(10.0); // 使用友元函数输出宽度 // 可以直接调用友元函数，不需要借助对象。 printWidth(b); return 0;&#125; ——特别注意下面这种写法是错误的 1b.printWidth(b); //错误 因为友元函数不属于类对象b的成员函数。 友元类——如果A 是 B的友元类 -&gt; A的成员函数可以访问 B的私有成员——友元类之间的关系不能传递，不能继承(此处来源)如：B 是 A 的友元，C 是 B 的友元，C 不是 A 的友元。A 是 B 的友元，不代表 B 是 A 的友元。 类模板——类模板，可以定义相同的操作，拥有不同数据类型的成员属性。——通常使用template来声明。告诉编译器，碰到T不要报错，表示一种泛型. 如下，一个普通的类模板： 1234567891011121314151617181920212223template &lt;class T&gt;class A&#123; private: T x,y; public: A(T xx,T yy) &#123;x=xx;y=yy;&#125; //在类内定义的函数 T fun_in() &#123;return (x+y);&#125; //在类内声明，在类外定义的函数 T fun_out();&#125;;//fun_out函数在类外定义的格式 template &lt;class T&gt;T A&lt;T&gt;::fun_out()&#123;return (x+y);&#125;int main()&#123; A&lt;int&gt; int_obj(6,8); int_obj.fun_in(); &#125; ——模板的实例化指函数模板（类模板）生成模板函数（模板类）的过程。对于函数模板而言，模板实例化之后，会生成一个真正的函数。而类模板经过实例化之后，只是完成了类的定义，模板类的成员函数需要到调用时才会被初始化。模板的实例化分为隐式实例化和显示实例化。（原文出处） ——隐式实例化和显式实例化和显式具体化统称为具体化 ——类模板的参数也可以是非类型参数，普通值也可以作为模板参数 1234567template&lt;class T,int NUM&gt;class Sample&#123;........&#125;;void main()&#123;Sample&lt;int,20&gt; obj;&#125; 继承与派生三种继承方式的特点图解公有继承 私有继承 保护继承 不同位置的访问权限 派生类成员 派生类中 派生类外部 下层派生类 公用成员 可以 可以 可以 保护成员 可以 不可以 可以 私有成员 可以 不可以 不可以 不可访问成员 不可以 不可以 不可以 直接间接 基类或派生类 构造函数与析构函数的调用顺序构造函数传送门：构造函数的调用顺序 析构函数 析构函数与构造函数的调用顺序刚好相反 多重继承基本概念 声明方法 有关二义性二义性的两种情况 消除二义性的两种方法 举个栗子——我们先定义两个基类A与B，里面包含最简单的公有成员show： 123456789101112class A&#123; public: void show()&#123; cout &lt;&lt; \"基类A的show\"; &#125;&#125;;class B&#123; public: void show()&#123; cout &lt;&lt; \"基类B的show\"; &#125;&#125;; ——然后再用一个类C继承A与B： 12class C:public A,public B&#123;&#125;; ——在主函数中调用公有成员show 123456int main()&#123; C c; c.show(); return 0;&#125; ——结果意料之中的报错了 1[Error] request for member &#39;show&#39; is ambiguous ——因为编译器不知道c.show()中的show到底是A的show还是B的show 解决方案1√——用相应的类名来标识（消除二义性的方法一），在主函数中修改： 123456int main()&#123; C c; c.B::show();//添加B::表示调用B中的show return 0;&#125; 解决方案2√——由派生类提供统一的接口 ——那么我们重新定义一下C中的show成员函数，在派生类成员函数中用类名标识符调用基类同名成员函数： 12345678class C:public A,public B&#123; public: void show()&#123; A::show();//用类名标识来实现调用A的show函数。 cout &lt;&lt; \"与\"; B::show(); &#125; &#125;; ——这样的话就可以在主函数中直接用c.show()来实现用派生类的show函数间接调用A和B的show函数了： 123456int main()&#123; C c; c.show(); return 0;&#125; 解决方案3√——利用同名隐藏 同名隐藏：当基类与派生类有同名成员时，派生类的成员会将基类成员屏蔽。如果在定义派生类对象的模块中通过对象名访问同名的成员，则访问的是派生类的成员。 这里我们可以在派生类C中重载show成员函数，那么调用c.show()的时候就会优先用派生类的show函数，基类的show被屏蔽掉了。 比如给C添加一个同名成员show： 123456class C:public A,public B&#123; public: void show()&#123; cout &lt;&lt; \"派生类C的show\"; &#125; &#125;; 这样的话就可以在主函数中直接调用，而不需要 类名:: 123456int main()&#123; C c; c.show(); return 0;&#125; 虚基类提出一个问题——假设我们有这样组成结构的几个类： ——具体实现： 12345678910111213141516class C&#123; public: int num;&#125;;class A:public C&#123; public: int num1;&#125;;class B:public C&#123; public: int num2;&#125;;class N:public A,public B&#123; public: int num3;&#125;; ——分析：这里C类被A类与B类继承，在A类与B类中分别有两个“不同”的数据成员num(来自C类)。也就是说，C类中的num变成了两份，一份在A中，一份在B中。 ——验证一下分析： 1234567891011int main()&#123; N n; n.A::num = 1; n.B::num = 2; cout &lt;&lt; n.A::num &lt;&lt; \" \"; cout &lt;&lt; n.B::num; return 0;&#125;================输出结果===================1 2 ——问题：但是num是C类里面的，他不应该有两份，这该怎么解决呢？ 权宜之计——使用虚继承的方式=&gt;虚基类 ——只需要让A和B虚继承C类，这样的话C就会只保留一份，比如我们改写一下A与B： 123456789//注意虚继承的格式：virtual 继承方式 基类名class A:virtual public C&#123; public: int num1;&#125;;class B:virtual public C&#123; public: int num2;&#125;; ——再在主函数中验证一下，A中的num与B中的num是否为同一份： 123456789int main()&#123; N n; n.A::num = 1;//我们先改写了A中的num cout &lt;&lt; n.B::num;//看看B中的num是不是与A中的是同一个。 return 0;&#125;=============输出结果===============1 ——可以看出，我们改变了A中的num，B中的num也改变了，说明C在继承过程中只保留了一份 ——同时，因为A与B中的num是同一份，我们还可以用对象名加点的方式直接访问,而不会产生二义性。 1234567int main()&#123; N n; n.A::num = 1; cout &lt;&lt; n.num;//直接访问 return 0;&#125; 虚继承的问题——虚继承的构造函数是很麻烦的。 ——清华大学郑莉老师的解释，传送门(自行跳转8:50)：https://www.bilibili.com/video/av41347930?p=32 多态性多态性概述——多态是指操作系统接口具有表现多种形态的能力，即能根据操作环境的不同采取不同的处理方式。多态性是面向对象系统的主要特征之一，在这样的系统中，一组具有相同基本语义的方法能在同一接口下为不同的对象服务。 ——多态的类型：重载多态、强制多态、包含多态、参数多态。——多态的种类：C++语言支持的多态性可以按其实现时机分为编译时多态和运行时多态两类。——绑定：是指把一个标识符名和一个存储地址联系在一起的过程。——编译时的多态：绑定工作在编译连接阶段完成的情况称为静态绑定。——运行时的多态：绑定工作在程序运行阶段完成的情况称为动态绑定。 运算符的重载复数类为例 说明都在注释中给出 123456789101112131415161718192021222324252627282930313233343536class Complex&#123; private: int a; int b; public: Complex(int aa=0,int bb=0):a(aa),b(bb)&#123;&#125;//构造函数 Complex operator+(const Complex &amp;obj) const;//重载+运算符 Complex&amp; operator++();//前置++运算符 ++obj Complex operator++(int);//后置++运算符 obj++ void show()&#123;cout &lt;&lt; a &lt;&lt; \"+\" &lt;&lt; b &lt;&lt; \"i\";&#125;//显示&#125;;//+运算符重载的定义（重载为成员函数）//obj1 + obj2//相当于obj1.operator+(obj2);Complex Complex::operator+(const Complex &amp;obj) const&#123; //使用Complex()构造函数创建一个临时对象 return Complex(a+obj.a,b+obj.b);&#125;//前置++运算符重载的定义//这里返回引用,是因为++obj，使用的是自增后对象的本身//++obj相当于obj.operator++();Complex&amp; Complex::operator++()&#123; a++;b++;return *this;&#125;//后置++运算符重载的定义//这里返回临时对象，这个临时对象保存的是自增之前的对象。//obj++相当于obj.operator(0);//自动传一个0进去，只是为了跟前置区分而已。Complex Complex::operator++(int)&#123; Complex old(*this); ++(*this);//这里调用已经写好的前置运算符 return old;//返回自增前的对象。&#125; 最好重载为友元比如： 1234567//+运算符重载的定义（重载为成员函数）//obj1 + obj2//相当于obj1.operator+(obj2);Complex Complex::operator+(const Complex &amp;obj) const&#123; //使用Complex()构造函数创建一个临时对象 return Complex(a+obj.a,b+obj.b);&#125; 这里的obj1+obj2相当于obj1.operator(obj2);也就是说第一个操作数必须为这个类的对象因此，如果我用10+obj，显然是不行的。为了解决这个问题，我们要把运算符重载为友元函数。 123456789101112131415161718192021222324252627282930313233class Complex&#123; private: int a; int b; public: Complex(int aa=0,int bb=0):a(aa),b(bb)&#123;&#125;//构造函数不变 friend Complex operator+(const Complex &amp;obj1,const Complex &amp;obj2);//+运算符重载 friend Complex&amp; operator++(Complex &amp;obj);//前置++运算符重载 friend Complex operator++(Complex &amp;obj,int);//后置++运算符重载 void show()&#123;cout &lt;&lt; a &lt;&lt; \"+\" &lt;&lt; b &lt;&lt; \"i\";&#125;&#125;;//这里将const限定符去掉了//因为非成员函数不能用CV限定（在C++中CV限定符指const和volatile）//否则会报错：cannot have cv-qualifier//同时Complex::也去掉了，因为友元函数是非成员函数Complex operator+(const Complex &amp;obj1,const Complex &amp;obj2)&#123; return Complex(obj1.a+obj2.a,obj1.b+obj2.b);&#125;//前置++运算符的重载//++objComplex&amp; operator++(Complex &amp;obj)&#123; obj.a++;obj.b++;return obj;&#125;//后置++运算符的重载//obj++//要用int来与前置区分Complex operator++(Complex &amp;obj,int)&#123; Complex old(obj); ++(obj); return old;&#125; 用cout的方式输出复数普通的数甚至字符串都可以用cout直接输出，那么我们自己定义的类呢？当然可以！先说明一下，通过查阅文档可知 1cout &lt;&lt; a &lt;&lt; b; 相当于： 1operator&lt;&lt;(operator&lt;&lt;(cout,a),b); 那么我们就可以自己重载一个了。方法如下在Complex类的public内声明一个友元函数 12345//这里返回引用是为了下一次嵌套调用。//比如operator&lt;&lt;(operator&lt;&lt;(cout,a),b);//调用里层之后返回一个cout//变成了operator&lt;&lt;(cout,b);friend ostream&amp; operator&lt;&lt;(ostream &amp;out,Complex &amp;obj); 在类外定义： 1234ostream&amp; operator&lt;&lt;(ostream &amp;out,Complex &amp;obj)&#123; out &lt;&lt; \"(\" &lt;&lt; obj.a &lt;&lt; \"+\" &lt;&lt; obj.b &lt;&lt; \"i)\"; return out;&#125; 这样就可以愉快的调用啦！ 12345678int main()&#123; Complex a(1,2),b(2,3); cout &lt;&lt; a &lt;&lt; b; return 0;&#125;============输出结果=============(1+2i)(2+3i)","categories":[{"name":"备忘录","slug":"备忘录","permalink":"https://cnatom.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"P1036 选数——类似全排列递归回溯法","slug":"P1036-选数——类似全排列递归回溯法","date":"2019-12-05T16:11:12.000Z","updated":"2020-01-27T16:31:07.931Z","comments":true,"path":"2019/12/06/P1036-选数——类似全排列递归回溯法/","link":"","permalink":"https://cnatom.github.io/2019/12/06/P1036-%E9%80%89%E6%95%B0%E2%80%94%E2%80%94%E7%B1%BB%E4%BC%BC%E5%85%A8%E6%8E%92%E5%88%97%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E6%B3%95/","excerpt":"","text":"题目链接：https://www.luogu.com.cn/problem/P1036 这个题用到了搜索与回溯的算法，所以先复习一下最简单的搜索与回溯： 搜索与回溯算法的框架：第一种写法： 1234567891011int Search(int k) &#123; for (i=1;i&lt;=算符种数;i++) if (满足条件) &#123; 保存结果 if (到目的地) 输出解; else Search(k+1); 恢复：保存结果之前的状态&#123;回溯一步&#125; &#125; &#125; 第二种写法： 123456789101112int Search(int k) &#123; if (到目的地) 输出解; else for (i=1;i&lt;=算符种数;i++) if (满足条件) &#123; 保存结果; Search(k+1); 恢复：保存结果之前的状态&#123;回溯一步&#125; &#125; &#125; 以一个最简单的搜索回溯题来练一下手： 【题目描述】设有n个整数的集合｛1,2,…,n｝，从中取出任意r个数进行排列（r&lt;n），试列出所有的排列。 解法：主函数外定义全局变量（静态区变量自动初始化为0） 123int n,r;int a[10001]; //存储排列结果bool rec[10001];//记录数值是否使用过，rec[num]==1代表数num已经使用过了 再写一个函数用来输出正确的排列 123456int print()&#123; for (int i=1;i&lt;=r;i++) cout&lt;&lt;setw(3)&lt;&lt;a[i]; cout&lt;&lt;endl; &#125; 最后是重头戏，此题的核心代码 12345678910111213int search(int step)&#123; int i; for (i=1;i&lt;=n;i++) if (rec[i]==0) //判断i是否可用 &#123; a[step]=i; //保存结果 rec[i]=1; if (step==r) print(); else search(step+1); rec[i]=0; &#125;&#125; 最后在主函数内调用 12345int main()&#123; cin&gt;&gt;n&gt;&gt;r; search(1);&#125; P1036选数这个题跟全排列非常类似，不同的是此题全排列的不是1…n，而是所给的每一个整数。而且在排列完成后还要判断排列结果的和是否为素数。 所以先上一个判断素数的函数： 123456789101112int is_prime(long long int num)&#123; int i; for(i=2;i&lt;=sqrt(num);i++) &#123; if(num%i==0) &#123; return 0; &#125; &#125; return 1;&#125; 之后在全局定义变量，免去了赋0的时间 123long long int g[21],sum;//g存储所给的整数，sum用来保存全排列的和int rec[21];//记录元素是否被使用int k,n,ans;//ans用来记录符合条件的全排列 接下来是最关键的函数 123456789101112131415161718192021void search(int step,int temp)&#123; int i; //在这里i从temp开始，而不是从0开始，因为1+2+3与1+3+2是一样的（举个栗子而已） for(i=temp;i&lt;n;i++) &#123; if(rec[i]==0) &#123; rec[i]=1; sum+=g[i]; //保存当前结果 if(step==k) //如果已经排了k个数,就判断sum是否为素数 &#123; if(is_prime(sum)) ans++; &#125; else search(step+1,i+1); //否则就排下一个数 //回溯后记录要归0，sum要减去当前元素 rec[i]=0; sum-=g[i]; &#125; &#125;&#125; 综上所述，最终题解为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;long long int g[21],sum;int rec[21];int k,n,ans;int is_prime(long long int num)&#123; int i; for(i=2;i&lt;=sqrt(num);i++) &#123; if(num%i==0) &#123; return 0; &#125; &#125; return 1;&#125;void search(int step,int temp)&#123; int i; for(i=temp;i&lt;n;i++) &#123; if(rec[i]==0) &#123; rec[i]=1; sum+=g[i]; if(step==k) &#123; if(is_prime(sum)) ans++; &#125; else search(step+1,i+1); rec[i]=0; sum-=g[i]; &#125; &#125;&#125;int main()&#123; int i,j; cin &gt;&gt; n &gt;&gt; k; for(i=0;i&lt;n;i++) scanf(\"%lld\",&amp;g[i]); search(1,0); cout &lt;&lt; ans; return 0;&#125;","categories":[{"name":"萌新自强之路","slug":"萌新自强之路","permalink":"https://cnatom.github.io/categories/%E8%90%8C%E6%96%B0%E8%87%AA%E5%BC%BA%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cnatom.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"P1028 数的计算——萌新的递推公式","slug":"P1028-数的计算——萌新的递推公式","date":"2019-12-04T12:55:47.000Z","updated":"2020-01-27T16:31:01.614Z","comments":true,"path":"2019/12/04/P1028-数的计算——萌新的递推公式/","link":"","permalink":"https://cnatom.github.io/2019/12/04/P1028-%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E8%90%8C%E6%96%B0%E7%9A%84%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F/","excerpt":"","text":"题目描述我们要求找出具有下列性质数的个数(包含输入的自然数n):先输入一个自然数n(n≤1000),然后对此自然数按照如下方法进行处理:1.不作任何处理;2.在它的左边加上一个自然数,但该自然数不能超过原数的一半;3.加上数后,继续按此规则进行处理,直到不能再加自然数为止. 输入格式1个自然数n(n≤1000) 输出格式1个整数，表示具有该性质数的个数。 输入样例16 输出样例16 说明/提示满足条件的数为 6，16，26，126，36，136 这个题找规律$a_1=1$$a_n=a_{n-1}+a_{n/2}(n为偶数,奇数a_{n+1}=a_n)$根据递推公式创建一个数组，答案就是$a_n$ 123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int n,i; int g[1001] = &#123;0,1,2,2&#125;; for(i=4;i&lt;=1001;i+=2) &#123; g[i] = g[i-1]+g[i/2]; g[i+1]=g[i]; &#125; cin &gt;&gt; n; cout &lt;&lt; g[n]; return 0;&#125;","categories":[{"name":"萌新自强之路","slug":"萌新自强之路","permalink":"https://cnatom.github.io/categories/%E8%90%8C%E6%96%B0%E8%87%AA%E5%BC%BA%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cnatom.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"P1914 小书童——密码","slug":"P1914-小书童——密码","date":"2019-12-04T12:19:07.000Z","updated":"2020-01-27T16:31:22.644Z","comments":true,"path":"2019/12/04/P1914-小书童——密码/","link":"","permalink":"https://cnatom.github.io/2019/12/04/P1914-%E5%B0%8F%E4%B9%A6%E7%AB%A5%E2%80%94%E2%80%94%E5%AF%86%E7%A0%81/","excerpt":"","text":"题目背景某蒟蒻迷上了“小书童”，有一天登陆时忘记密码了（他没绑定邮箱or手机），于是便把问题抛给了神犇你。 题目描述蒟蒻虽然忘记密码，但他还记得密码是由一个字符串组成。密码是由原文字符串（由不超过 50 个小写字母组成）中每个字母向后移动 nn 位形成的。z 的下一个字母是 a，如此循环。他现在找到了移动前的原文字符串及 nn，请你求出密码。 输入格式第一行：n。第二行：未移动前的一串字母 输出格式一行，是此蒟蒻的密码 输入样例121qwe 输出样例1rxf 这个题很简单，但是需要注意一点，ascll码值的范围是0-255或-128-+127。在我本人的电脑（devc++）上面的范围是-128-+127，出现了溢出的问题，所以用一个int型的变量temp来存储字符的ASCLL码值，防止溢出。此外，用n%26来缩小n的数值，防止连int也给溢出了。。。。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;void move(char *p,int n)&#123;//将字符串p的每一个字母都移动n个单位 int i,temp; for(i=0;p[i];i++) &#123; temp = (int)p[i];//temp存储ascll码值 temp+=n%26; if(temp&gt;'z') &#123;//溢出的判断 temp-=26; p[i]=temp; &#125; else p[i] = temp; &#125;&#125;int main()&#123; int n; char s[51]; cin &gt;&gt; n; cin &gt;&gt; s; move(s,n); cout &lt;&lt; s; return 0;&#125;","categories":[{"name":"萌新自强之路","slug":"萌新自强之路","permalink":"https://cnatom.github.io/categories/%E8%90%8C%E6%96%B0%E8%87%AA%E5%BC%BA%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cnatom.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"P1598 垂直柱状图","slug":"P1598-垂直柱状图","date":"2019-12-04T11:50:44.000Z","updated":"2020-01-27T16:31:19.317Z","comments":true,"path":"2019/12/04/P1598-垂直柱状图/","link":"","permalink":"https://cnatom.github.io/2019/12/04/P1598-%E5%9E%82%E7%9B%B4%E6%9F%B1%E7%8A%B6%E5%9B%BE/","excerpt":"","text":"题目描述写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过100个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。 输入格式四行字符，由大写字母组成，每行不超过100个字符 输出格式由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。 输入样例1234THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.THIS IS AN EXAMPLE TO TEST FOR YOURHISTOGRAM PROGRAM.HELLO! 输出样例1234567891011 * * * * * * * * * * * ** * * * * ** * * * * * * * * ** * * * * * * * * * * * ** * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * * * * * * * * * * * *A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 用桶的思想来解决这个问题写一个函数，用下标表示每一个字母出现的次数。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int a['Z'+1]=&#123;0&#125;;int maxx;void fun(char *p)&#123; int i; for(i=0;p[i];i++) &#123; if(p[i]&gt;='A' &amp;&amp; p[i]&lt;='Z') &#123; a[p[i]]++; if(a[p[i]]&gt;maxx) maxx=a[p[i]]; &#125; &#125;&#125;int main()&#123; int i; char s[101]; for(i=0;i&lt;4;i++) &#123; gets(s); fun(s); &#125; for(;maxx;maxx--) &#123; for(int j='A';j&lt;='Z';j++) &#123; if(a[j]==maxx) &#123; printf(\"* \"); a[j]--; &#125; else printf(\" \"); &#125; printf(\"\\n\"); &#125; for(int i='A';i&lt;='Z';i++) printf(\"%c \",(char)i); return 0;&#125;","categories":[{"name":"萌新自强之路","slug":"萌新自强之路","permalink":"https://cnatom.github.io/categories/%E8%90%8C%E6%96%B0%E8%87%AA%E5%BC%BA%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cnatom.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【C++】文件输入输出","slug":"C-文件输入输出","date":"2019-12-04T07:45:44.000Z","updated":"2020-01-27T16:30:34.834Z","comments":true,"path":"2019/12/04/C-文件输入输出/","link":"","permalink":"https://cnatom.github.io/2019/12/04/C-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"","text":"大佬的教程C++文件读写详解（ofstream,ifstream,fstream）各种ios::xxx组合在C++文件输入输出中的区别 注意的点1.fstream对象中seek与tell方法的问题因为fstream是ofstream与ifstream的派生类，继承了seekg、seekp、tellg、tellp方法。但是在fstream对象中，seekg&amp;seekp tellg&amp;tellp起到的效果是相同的。 1234567891011121314151617#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; fstream fio(\"file.txt\"); fio.seekg(1); fio.seekp(2); cout &lt;&lt; fio.tellg() &lt;&lt; endl; cout &lt;&lt; fio.tellp() &lt;&lt; endl; return 0;&#125;/********************************输出结果：22*********************************/ 2.关于ios::app与“seek”方法ios::app方式使所有的输出附加在文件的结尾，seekg或者是seekp方法是无法改变输出位置的比如说我们有个txt文件（file.txt）的内容是000456，我们想先用ios::app方式指向文件结尾，然后再用seekp方法修改指针位置为开头，将000替换为123，文本最终变成123456，我们来实现一下： 修改前的文本： 1000456 12345678910#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; fstream fio(\"file.txt\",ios::app|ios::out);//ios::app方式打开 fio.seekp(0,ios::beg);//似乎指向了文件开头 fio &lt;&lt; \"123\";//用123替换000 return 0;&#125; 修改后的文本： 1000456123 可以看到，所有的输出都始终附加在文件的结尾要用正确的方式输出我们想要的结果，全面的教程↓各种ios::xxx组合在C++文件输入输出中的区别 3.fstream对象使用open方法自动创建文件的问题在这里用构造的方式来调用open方法注意fstream默认的方式是ios::in|ios::out，所以第一串与第二串代码等同。源代码： 12345678910#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; fstream fio0(\"file0.txt\");//一 fstream fio1(\"file1.txt\",ios::in|ios::out);//二 fstream fio2(\"file2.txt\",ios::out);//三 return 0;&#125; 运行之前当前文件夹的状态：运行之后： 若包含ios::in，则不会自动创建文件","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://cnatom.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"P1553 数字反转（升级版）——被自己蠢哭了系列","slug":"P1553-数字反转（升级版）——被自己蠢哭了系列","date":"2019-12-03T10:32:33.000Z","updated":"2020-01-27T16:31:15.222Z","comments":true,"path":"2019/12/03/P1553-数字反转（升级版）——被自己蠢哭了系列/","link":"","permalink":"https://cnatom.github.io/2019/12/03/P1553-%E6%95%B0%E5%AD%97%E5%8F%8D%E8%BD%AC%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%EF%BC%89%E2%80%94%E2%80%94%E8%A2%AB%E8%87%AA%E5%B7%B1%E8%A0%A2%E5%93%AD%E4%BA%86%E7%B3%BB%E5%88%97/","excerpt":"","text":"题目描述给定一个数，请将该数各个位上数字反转得到一个新数。 这次与NOIp2011普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为0（除非小数部分除了0没有别的数，那么只保留1个0）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为0），本次没有负数。输入格式一个数s输出格式一个数，即s的反转数 输入样例1：5087462输出样例1：2647805 输入样例2：600.084输出样例2：6.48 输入样例3：700/27输出样例3：7/72 输入样例4：8670%输出样例4：768% 萌新上路，俺不知道啥叫STL，所以就自己动手，丰衣足食，嘿嘿。打算用字符串来收数字，所以先写了一个char数字字符串转int的函数（用了指针的方法，转换从start到end之间的数字） 12345678910111213long long int trans(char* start,char* end)&#123; char* p=end; long long int ans=0,i=1; int len = end-start; while(p&gt;=start) &#123; ans += ((*p)-'0')*i; i*=10; p--; &#125; return ans;&#125; （其实这个题从一开始就做错了，题目要求数值的最大长度20位，然而long long int最大约19位，unsigned long long虽然可以到20位，但是最大是18446744073709551615，很明显不行，不过最后只wa了一个测试点，就当涨经验了吧哈哈，不要在意这些细节，不对，是巨节） 然后再写反转的函数 1234567891011long long int reverse(long long int num)&#123; long long ans=0,i=1,temp; while(num) &#123;//每次都将ans的位数提高，再存入num的个位数部分 temp = num%10; ans = ans*10 + temp; num/=10; &#125; return ans;&#125; 输入数据（现在还是觉得当时有点憨） 12char num[40];gets(num); 之后遍历查找是否有符号，根据结果输出 123456789101112131415161718192021222324for(i=0;num[i];i++)&#123; if(num[i]&lt;'0'||num[i]&gt;'9') &#123; if(num[i]=='.') &#123; printf(\"%lld.%lld\",reverse(trans(num,num+i-1)),reverse(trans(num+i+1,num+strlen(num)-1))); return 0; &#125; else if(num[i]=='/') &#123; printf(\"%lld/%lld\",reverse(trans(num,num+i-1)),reverse(trans(num+i+1,num+strlen(num)-1))); return 0; &#125; else if(num[i]=='%') &#123; printf(\"%lld%%\",reverse(trans(num,num+i-1))); return 0; &#125; &#125;&#125;//全都是数字的情况printf(\"%lld%\",reverse(trans(num,num+strlen(num)-1)));return 0; 解释一下printf后面那一串奇怪的嵌套：假如num为123.456那翻转前三位123就可以写成 1reverse(trans(num,num+2)) 萌新觉得这很可 最后把上面那一堆串到一起 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;long long int trans(char* start,char* end)&#123; char* p=end; long long int ans=0,i=1; int len = end-start; while(p&gt;=start) &#123; ans += ((*p)-'0')*i; i*=10; p--; &#125; return ans;&#125;long long int reverse(long long int num)&#123; long long ans=0,i=1,temp; while(num) &#123; temp = num%10; ans = ans*10 + temp; num/=10; &#125; return ans;&#125;int main()&#123; char num[40]; gets(num); int i; for(i=0;num[i];i++) &#123; if(num[i]&lt;'0'||num[i]&gt;'9') &#123; if(num[i]=='.') &#123; printf(\"%lld.%lld\",reverse(trans(num,num+i-1)),reverse(trans(num+i+1,num+strlen(num)-1))); return 0; &#125; else if(num[i]=='/') &#123; printf(\"%lld/%lld\",reverse(trans(num,num+i-1)),reverse(trans(num+i+1,num+strlen(num)-1))); return 0; &#125; else if(num[i]=='%') &#123; printf(\"%lld%%\",reverse(trans(num,num+i-1))); return 0; &#125; &#125; &#125; printf(\"%lld%\",reverse(trans(num,num+strlen(num)-1))); return 0;&#125; 最后系统判定95分第14个测试点数据是：1234567891011121314020位的数据，我太难了（枯了） 偷瞄一下大佬的思路看到这个，要被自己蠢哭了好吗 未完待续。。。。","categories":[{"name":"萌新自强之路","slug":"萌新自强之路","permalink":"https://cnatom.github.io/categories/%E8%90%8C%E6%96%B0%E8%87%AA%E5%BC%BA%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cnatom.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"P1308 统计单词数——字符串处理","slug":"P1308-统计单词数——字符串处理","date":"2019-12-03T05:31:13.000Z","updated":"2020-01-27T16:31:11.505Z","comments":true,"path":"2019/12/03/P1308-统计单词数——字符串处理/","link":"","permalink":"https://cnatom.github.io/2019/12/03/P1308-%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E6%95%B0%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","excerpt":"","text":"题目描述一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例1 ），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2 ）。 输入格式共2行。 第1行为一个字符串，其中只含字母，表示给定单词； 第2行为一个字符串，其中只可能包含字母和空格，表示给定的文章。 输出格式一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从0 开始）；如果单词在文章中没有出现，则直接输出一个整数-1。 输入样例1To to be or not to be is a question输出样例12 0输入样例2to Did the Ottoman Empire lose its power at that time输出样例2to Did the Ottoman Empire lose its power at that time 我的解法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;void strlower(char* a)&#123; //将字符串转换为小写 //头文件cstring:判断大小写isupper 临时转换为小写tolower int i; for (i = 0; a[i]; i++) &#123; if (isupper(a[i])) a[i] = tolower(a[i]); &#125;&#125;int match(char* aa, char* bb,int* ii)&#123; int i,flag=1; int len = strlen(aa); for(i=0;i&lt;len;i++) &#123; if(aa[i]!=bb[i]) &#123;//中间有不匹配的 *ii += i; return 0; &#125; &#125; if(bb[len]==' '||bb[len]=='\\0') &#123;//匹配到a的结尾，且b[i+1]空格 *ii+=i; return 1; &#125; else &#123;//匹配到单词的结尾，但是文章b[i+1]不是空格 (*ii)++; return 0; &#125;&#125;int main()&#123; int i=0; char a[11]; char g[1000001]; int num = 0, location = -1; //用gets函数读取整行 gets(a); gets(g); int len = strlen(g); //将大写转换为小写 strlower(a); strlower(g); while(i&lt;=len) &#123;//从i=0开始向后遍历文章 if (g[i] == a[0]&amp;&amp;g[i-1]==' ' || g[i]==a[0]&amp;&amp;i==0) &#123;//当 文章空格后的第一个单词 与 给定单词首字母 相同时 //或者 文章的第一个单词 与 给定单词首字母 相同时 if (match(a, g + i,&amp;i)) &#123; if(location==-1)location = i-strlen(a); num++; &#125; &#125; else i++; &#125; if(location==-1) printf(\"-1\"); else printf(\"%d %d\",num,location); return 0;&#125; 用string的做法（作者: Aimyhtixela来自洛谷）123456789101112131415161718192021222324252627282930313233343536373839//定义头文件#include &lt;iostream&gt;#include &lt;string&gt;//命名空间using namespace std;int main()&#123; //定义两个字符串 string a; string b; //用string库，调用getline, 直接读入一整行 getline(cin,a); getline(cin,b); //转换大小写，可以都转换为大写，或者小写 for (int i=0;i&lt;a.length();++i)&#123; a[i]=tolower(a[i]); &#125; for (int i=0;i&lt;b.length();++i)&#123; b[i]=tolower(b[i]); &#125; //因为连起来的不算，所以要在前后加几个空格，一定要是同样多的，同量减同量，等于同量 a=' '+a+' '; b=' '+b+' '; //先看看会不会找不到，用a.find()和string::npos if (b.find(a)==string::npos)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; //如果找得到 else &#123; int alpha=b.find(a); int beta=b.find(a),s=0;//计数器初始化为0 while (beta!=string::npos)&#123; ++s;//计数器 beta=b.find(a,beta+1); &#125; cout&lt;&lt;s&lt;&lt;\" \"&lt;&lt;alpha&lt;&lt;endl;//输出第一个和总共有几个 &#125; //函数返回值为0，结束整个程序 return 0;&#125; 特别注意i++与(i)++的区别，要注意++的优先级要高于取值运算符 123456789void fun(int* ii)&#123; (*ii)++; //实参i也+1 *ii++; //等同于先ii++，将指针后移，然后再取值，实参i不变&#125;.....int i = 0;fun(i);.....","categories":[{"name":"萌新自强之路","slug":"萌新自强之路","permalink":"https://cnatom.github.io/categories/%E8%90%8C%E6%96%B0%E8%87%AA%E5%BC%BA%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://cnatom.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【C++】第13章作业","slug":"【C-】第13章作业","date":"2019-11-30T08:44:12.000Z","updated":"2020-01-27T16:27:15.982Z","comments":true,"path":"2019/11/30/【C-】第13章作业/","link":"","permalink":"https://cnatom.github.io/2019/11/30/%E3%80%90C-%E3%80%91%E7%AC%AC13%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"写数据在txt文件中，并计算数据的和【问题描述】 在当前目录文件“data.txt”中读取整数数据，并计算总和保存在当前目录的“result.txt”文件中。 【输入形式】 文件中的若干数据，格式为按行存储。 【输出形式】 输出保存的文件，和计算之和 【样例输入】 【样例输出】 123456789101112131415161718#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; ifstream fin(\"data.txt\"); ofstream fout(\"result.txt\"); int n,ans=0; while(fin &gt;&gt; n) &#123; ans += n; &#125; fout &lt;&lt; ans; fin.close(); fout.close(); return 0;&#125;","categories":[{"name":"C++理论作业","slug":"C-理论作业","permalink":"https://cnatom.github.io/categories/C-%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验七 继承与派生","slug":"【C-】实验七-继承与派生","date":"2019-11-30T07:54:08.000Z","updated":"2020-01-27T16:28:45.824Z","comments":true,"path":"2019/11/30/【C-】实验七-继承与派生/","link":"","permalink":"https://cnatom.github.io/2019/11/30/%E3%80%90C-%E3%80%91%E5%AE%9E%E9%AA%8C%E4%B8%83-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/","excerpt":"","text":"实验七（第八章）实践题一对本章示范题的用于管理商店商品的实现程序进行完善:完成Wardrobe立柜类的具体定义与使用，并添加“帽子仓库类”以及“立柜仓库类”的定义及使用，以使程序能够对商店的这三种商品（衬衣、帽子、立柜）进行简单的管理与应用。 要对商品实现的操作有:商品的进库（增加某类商品及其库存量），商品的出库（减少某类商品及其库存量），以及某类商品总价格的计算。 【输入形式】 根据提示输入【输出形式】 把处理后的数据输出 【样例】注意：红色为输入部分，黑色为输出部分。 5 * shirt data in: price/place/material =&gt;60 Tianjin Cotton 3 * shirt data in: price/place/material =&gt;80 Beijing Wool 60 Tianjin Cotton 60 Tianjin Cotton 60 Tianjin Cotton 60 Tianjin Cotton 60 Tianjin Cotton 80 Beijing Wool 80 Beijing Wool 80 Beijing Wool shiSto.TotalPrice()=540 60 Tianjin Cotton 60 Tianjin Cotton 60 Tianjin Cotton 60 Tianjin Cotton shiSto.TotalPrice()=240 5 * Cap data in: price/place/material/style =&gt;40 Suzhou Cotton M 3 * Cap data in: price/place/material/style =&gt;30 Wuxi Wool S 40 Suzhou Cotton M 40 Suzhou Cotton M 40 Suzhou Cotton M 40 Suzhou Cotton M 40 Suzhou Cotton M 30 Wuxi Wool S 30 Wuxi Wool S 30 Wuxi Wool S capSto.TotalPrice()=290 40 Suzhou Cotton M 40 Suzhou Cotton M 40 Suzhou Cotton M 40 Suzhou Cotton M capSto.TotalPrice()=160 5 * Wardrobe data in: price/place/material/color =&gt;160 Guangzhou Pine Yellow 3 * Wardrobe data in: price/place/material/color =&gt;200 Suzhou Oak Brown 160 Guangzhou Pine Yellow 160 Guangzhou Pine Yellow 160 Guangzhou Pine Yellow 160 Guangzhou Pine Yellow 160 Guangzhou Pine Yellow 200 Suzhou Oak Brown 200 Suzhou Oak Brown 200 Suzhou Oak Brown WarSto.TotalPrice()=1400 160 Guangzhou Pine Yellow 160 Guangzhou Pine Yellow 160 Guangzhou Pine Yellow 160 Guangzhou Pine Yellow WarSto.TotalPrice()=640 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Base&#123; private: double price; char place[20]; int count; public: Base(double pr,char *pl,int cnt) &#123; price = pr; strcpy(place,pl); count = cnt; &#125; void display() &#123; cout &lt;&lt; price &lt;&lt; \" \" &lt;&lt; place&lt;&lt; \" \"; &#125; void InSomething(int add_cnt) &#123; count +=add_cnt; &#125; void OutSomething(int del_cnt) &#123; count -= del_cnt; &#125; double TotalPrice() &#123; return price; &#125;&#125;;class Shirt:public Base&#123; private: char material[20]; public: Shirt(double pr,char *pl,int cnt,char *mat):Base(pr,pl,cnt) &#123; strcpy(material,mat); &#125; void display() &#123; Base::display(); cout &lt;&lt;material&lt;&lt; \" \"; &#125;&#125;;class Cap:public Shirt&#123; private: char style; public: Cap(double pr,char *pl,int cnt,char *mat,char sty):Shirt(pr,pl,cnt,mat) &#123; style = sty; &#125; void display ()&#123; Shirt::display(); cout &lt;&lt;style; &#125;&#125;;class Wardrobe:public Base&#123; private: char material[20]; char color[20]; public: Wardrobe(double pr,char *pl,int cnt,char *mat,char *col):Base(pr,pl,cnt) &#123; strcpy(material,mat); strcpy(color,col); &#125; void display() &#123; Base::display(); cout &lt;&lt; material &lt;&lt; \" \" &lt;&lt; color; &#125;&#125;;int main()&#123; int price; char place[20]; char material[20]; char style; char color[20]; cout &lt;&lt; \"5 * shirt data in: price/place/material =&gt;\"&lt;&lt;endl; cin &gt;&gt; price &gt;&gt; place &gt;&gt; material; Shirt s1(price,place,5,material); cout &lt;&lt; \"3 * shirt data in: price/place/material =&gt;\"&lt;&lt;endl; cin &gt;&gt; price &gt;&gt; place &gt;&gt; material; Shirt s2(price,place,3,material); for(int i=0;i&lt;5;i++) &#123; s1.display(); cout &lt;&lt; endl; &#125; for(int i=0;i&lt;3;i++) &#123; s2.display(); cout &lt;&lt; endl; &#125; cout &lt;&lt; \"shiSto.TotalPrice()=\" &lt;&lt; (s1.TotalPrice())*5+(s2.TotalPrice())*3 &lt;&lt; endl; for(int i=0;i&lt;4;i++) &#123; s1.display(); cout &lt;&lt; endl; &#125; cout &lt;&lt; \"shiSto.TotalPrice()=\" &lt;&lt; (s1.TotalPrice())*4&lt;&lt;endl; cout &lt;&lt; \"5 * Cap data in: price/place/material/style =&gt;\"&lt;&lt;endl; cin &gt;&gt; price &gt;&gt; place &gt;&gt; material &gt;&gt; style; Cap c1(price,place,5,material,style); cout &lt;&lt; \"3 * Cap data in: price/place/material/style =&gt;\"&lt;&lt;endl; cin &gt;&gt; price &gt;&gt; place &gt;&gt; material &gt;&gt; style; Cap c2(price,place,3,material,style); for(int i=0;i&lt;5;i++) &#123; c1.display(); cout &lt;&lt; endl; &#125; for(int i=0;i&lt;3;i++) &#123; c2.display(); cout &lt;&lt; endl; &#125; cout &lt;&lt; \"capSto.TotalPrice()=\" &lt;&lt;(c1.TotalPrice())*5+(c2.TotalPrice())*3 &lt;&lt; endl; for(int i=0;i&lt;4;i++) &#123; c1.display(); cout &lt;&lt; endl; &#125; cout &lt;&lt; \"capSto.TotalPrice()=\" &lt;&lt;(c1.TotalPrice())*4&lt;&lt;endl; cout &lt;&lt; \"5 * Wardrobe data in: price/place/material/color =&gt;\"&lt;&lt;endl; cin &gt;&gt; price &gt;&gt; place &gt;&gt; material&gt;&gt;color; Wardrobe w1(price,place,5,material,color); cout &lt;&lt; \"3 * Wardrobe data in: price/place/material/color =&gt;\"&lt;&lt;endl; cin &gt;&gt; price &gt;&gt; place &gt;&gt; material&gt;&gt;color; Wardrobe w2(price,place,3,material,color); for(int i=0;i&lt;5;i++) &#123; w1.display(); cout &lt;&lt; endl; &#125; for(int i=0;i&lt;3;i++) &#123; w2.display(); cout &lt;&lt; endl; &#125; cout &lt;&lt; \"WarSto.TotalPrice()=\"&lt;&lt; (w1.TotalPrice())*5+(w2.TotalPrice())*3 &lt;&lt;endl; for(int i=0;i&lt;4;i++) &#123; w1.display(); cout &lt;&lt; endl; &#125; cout &lt;&lt;\"WarSto.TotalPrice()=\" &lt;&lt; (w1.TotalPrice())*4; return 0;&#125; 实验七（第八章） 实践题二【问题描述】 利用继承性与派生类来管理学生教师档案:由Person（人员）类出发（作为基类），派生出Student（学生）及Teacher（教师）类；而后又由Student（学生）类出发（作为基类），派生出GraduateStudent（研究生）类。可假定这几个类各自具有的数据成员为: Person（人员）类: 姓名、性别、年龄； Student（学生）类: 姓名、性别、年龄、学号、系别； Teacher（教师）类: 姓名、性别、年龄、职称、担任课程； GraduateStudent（研究生）类: 姓名、性别、年龄、学号、系别、导师。 为简化起见，每个类可只设立构造函数以及显示类对象数据的成员函数Print。而后编制简单的主函数，说明上述有关的类对象，并对其类成员函数进行简单使用（调用）。 【输入形式】【输出形式】【样例输入】 无【样例输出】 == per1.Display() =&gt; name,age,sex sun 42 M == stu1.Display() =&gt; name,age,sex,Reg_Number,department guo 22 F 1001 comp == teach1.Display() =&gt; name,age,sex,course,post fang 38 M english professor == gStu.Display() =&gt; name,age,sex,Reg_Number,department,advisor wu 25 M 1021 comp wei 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person&#123; protected: string name; int age; string sex; public: Person()&#123;&#125; Person(string n,int a,string s):name(n),age(a),sex(s)&#123;&#125; void Display() &#123; cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; age &lt;&lt; \" \" &lt;&lt; sex; &#125;&#125;;class Student:public Person&#123; protected: int regnum; string department; public: Student()&#123;&#125; Student(string n,int a,string s,int r,string d) &#123; name=n;age=a;sex=s;regnum=r;department=d; &#125; void Display() &#123; Person::Display(); cout &lt;&lt; \" \" &lt;&lt; regnum &lt;&lt; \" \" &lt;&lt; department; &#125;&#125;;class GraduateStudent:public Student&#123; protected: string advisor; public: GraduateStudent()&#123;&#125;; GraduateStudent(string n,int a,string s,int r,string d,string ad):Student(n,a,s,r,d),advisor(ad)&#123;&#125; void Display() &#123; Student::Display(); cout &lt;&lt; \" \" &lt;&lt; advisor; &#125;&#125;;class Teacher:public Person&#123; protected: string course; string post; public: Teacher(string n,int a,string s,string c,string p):Person(n,a,s),course(c),post(p)&#123;&#125; void Display() &#123; Person::Display(); cout &lt;&lt; \" \" &lt;&lt; course &lt;&lt; \" \" &lt;&lt; post; &#125;&#125;;int main()&#123; cout &lt;&lt; \"== per1.Display() =&gt; name,age,sex\" &lt;&lt; endl; Person per1(\"sun\",42,\"M\"); per1.Display();cout &lt;&lt; endl; cout &lt;&lt; \"== stu1.Display() =&gt; name,age,sex,Reg_Number,department\" &lt;&lt; endl; Student stu1(\"guo\",22,\"F\",1001,\"comp\"); stu1.Display();cout &lt;&lt; endl; cout &lt;&lt; \"== teach1.Display() =&gt; name,age,sex,course,post\" &lt;&lt; endl; Teacher teach1(\"fang\",38,\"M\",\"english\",\"professor\"); teach1.Display();cout &lt;&lt; endl; cout &lt;&lt; \"== gStu.Display() =&gt; name,age,sex,Reg_Number,department,advisor\" &lt;&lt; endl; GraduateStudent gStu(\"wu\",25,\"M\",1021,\"comp\",\"wei\"); gStu.Display(); return 0;&#125; 实验七（第八章） 实践题三自定义一个日期时间类DateTimeType，它含有类DateType与类TimeType的类对象作为其数据成员，并具有所列的其他几个成员函数。而后编制主函数，说明DateTimeType的类对象，并对其成员函数以及二对象成员所属类的公有成员函数进行使用。 class DateTimeType { //自定义的日期时间类 DateTimeType DateType date; //类 DateType 的类对象 date 作为其数据成员 TimeType time; //类 TimeType 的类对象 time 作为其另一个数据成员 public: DateTimeType(int y0=1, int m0=1, int d0=1, int hr0=0, int mi0=0, int se0=0); //构造函数，设定 DateTimeType 类对象的日期时间，并为各参数设置了默认值 DateType&amp; GetDate(){ return date; } //返回本类的私有数据对象 data TimeType&amp; GetTime(){ return time; } //返回本类的私有数据对象 time void IncrementSecond(int s); //增加若干秒，注意“进位”问题 void PrintDateTime(); //屏幕输出日期时间对象的有关数据 }; 注意，每一个DateTimeType类对象中总包含有一个DateType类对象（对象成员）以及一个TimeType类对象（对象成员），编制与实现本程序时，也必须包含DateType与TimeType自定义类（类型）。 之所以设置了公有的类成员函数GetDate与GetTime，是为类外如主函数处使用该类的私有数据成员date与time提供方便（否则的话，类外无法直接访问该类的私有数据成员）。另外，两成员函数返回的都为引用，为的是可将返回对象当作一个独立变量来使用（如可以继续作左值等）。例如，假设编制了如下形式的主函数: void main() { DateTimeType dttm1(1999,12,31,23,59,59), dttm2; (dttm1.GetDate()).PrintDate(); //调用对象成员所属类的公有成员函数 cout&lt;&lt;endl; dttm1.PrintDateTime(); //调用本派生类的成员函数 PrintDateTime dttm2.PrintDateTime(); dttm1.IncrementSecond(30) ; //调用本派生类成员函数 dttm1.PrintDateTime(); }【样例输出】 1999-12-31 1999-12-31 23:59:59 1-1-1 0:0:0 2000-1-1 0:0:29 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;using namespace std;class DateType&#123; protected: int y; int m; int d; public: DateType(int yy=0,int mm=0,int dd=0):y(yy),m(mm),d(dd)&#123;&#125; void PrintDate() &#123; cout &lt;&lt; y &lt;&lt; \"-\" &lt;&lt; m &lt;&lt; \"-\" &lt;&lt; d; &#125; void up() &#123; int g[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; if(y%4==0&amp;&amp;y%100!=0||y%400==0) g[2] = 29; d++; if(d&gt;g[m]) &#123; d-=g[m]; m++; if(m&gt;12) &#123; m-=12; y++; &#125; &#125; &#125;&#125;;class TimeType&#123; protected: int h; int m; int s; public: TimeType(int hh=0,int mm=0,int ss=0):h(hh),m(mm),s(ss)&#123;&#125; void PrintTime() &#123; cout &lt;&lt; h &lt;&lt; \":\" &lt;&lt; m &lt;&lt; \":\" &lt;&lt; s; &#125; int up(int ss) &#123; s+=ss; int temp = s/60; if(temp) &#123; m+=temp; s-=60*temp; temp=m/60; if(temp) &#123; h+=temp; m-=60*temp; temp=h/24; if(temp) &#123; h-=24*temp; return temp; &#125; &#125; &#125; return 0; &#125;&#125;;class DateTimeType &#123; DateType date; TimeType time; public: DateTimeType(int y0=1, int m0=1, int d0=1, int hr0=0, int mi0=0, int se0=0):date(y0,m0,d0),time(hr0,mi0,se0)&#123;&#125; DateType&amp; GetDate()&#123; return date; &#125; TimeType&amp; GetTime()&#123; return time; &#125; void IncrementSecond(int s) &#123; //如果大于24小时 if(time.up(s)) &#123; date.up();//日期增加一天 &#125; &#125; void PrintDateTime() &#123; date.PrintDate(); cout &lt;&lt; \" \"; time.PrintTime(); cout &lt;&lt; endl; &#125;&#125;;int main()&#123; DateTimeType dttm1(1999,12,31,23,59,59), dttm2; (dttm1.GetDate()).PrintDate(); cout&lt;&lt;endl; dttm1.PrintDateTime(); dttm2.PrintDateTime(); dttm1.IncrementSecond(30); dttm1.PrintDateTime(); return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验八 输入输出流","slug":"【C-】实验八-输入输出流","date":"2019-11-30T07:24:02.000Z","updated":"2020-01-27T16:38:41.717Z","comments":true,"path":"2019/11/30/【C-】实验八-输入输出流/","link":"","permalink":"https://cnatom.github.io/2019/11/30/%E3%80%90C-%E3%80%91%E5%AE%9E%E9%AA%8C%E5%85%AB-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/","excerpt":"","text":"实验八（第十一章）实践题一【问题描述】 编程序，对 k=1，2，3，…，14，15，按下式分别计算出 15 组（i，d，c）：整数 i=2k-1；实数 d=kk+k-9.8；字符 c=’H’+k。并通过使用运算符“&lt;&lt;”将这15组数据保存到当前目录下自定义的text型磁盘文件ft.txt之中。【输入形式】 无【输出形式】 文件内容要求：每组占一行，每行中的输出项用一个空格进行分割。【样例输入】 无【样例输出】 文件内容格式如下： 1 -7.8 I 3 -3.8 J 5 2.2 K 7 10.2 L ….以下省略…. 123456789101112131415#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; ofstream fout; fout.open(\"ft.txt\"); int k; for(k=1;k&lt;=15;k++) &#123; fout &lt;&lt; 2*k-1 &lt;&lt; \" \" &lt;&lt; k*k+k-9.8 &lt;&lt; \" \" &lt;&lt; (char)('H'+k) &lt;&lt; endl; &#125; fout.close(); return 0;&#125; 实验八（第十一章） 实践题二【问题描述】 通过使用运算符“&gt;&gt;”和“&lt;&lt;”，对自定义的text型磁盘文件进行如下的指定操作。 （1）对i=1，2，3，…，15，计算d=i*i+0.5，并将15个结果写出到自定义的text型磁盘文件f1.txt中（注意，f1文件中的数据从小到大有序）； （2）对i=1，2，3，…，10，计算d=10*i+0.5，并将10个结果写出到自定义的text型磁盘文件f2.txt中，而后再写出第11个数：357.9（注意，f2文件中的数据也从小到大有序）； （3）读出文件f1.txt以及f2.txt中的数据，用来形成text型磁盘文件f3.txt，但要求存放于f3.txt中的数据仍然是有序的（按照从小到大的顺序）；【输入形式】 无【输出形式】 输出到f3.txt文件中（一行，数据间间隔为一个空格）【样例输入】 无【样例输出】 1.5 4.5 9.5 10.5 16.5…（以下略） 1234567891011121314151617181920212223242526272829303132333435#include&lt;fstream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; ofstream fout(\"f1.txt\"); int i; for(i=1;i&lt;=15;i++) &#123; fout &lt;&lt; i*i+0.5 &lt;&lt; \" \"; &#125; fout.close(); fout.open(\"f2.txt\"); for(i=1;i&lt;=10;i++) &#123; fout &lt;&lt; 10*i+0.5 &lt;&lt; \" \"; &#125; fout &lt;&lt; 357.9; fout.close(); ifstream fin1(\"f1.txt\"); ifstream fin2(\"f2.txt\"); float g[30]; for(i=0;i&lt;15;i++) fin1 &gt;&gt; g[i]; for(i=15;i&lt;26;i++) fin2 &gt;&gt; g[i]; sort(g,g+26); fout.open(\"f3.txt\"); for(i=0;i&lt;26;i++) &#123; fout &lt;&lt; g[i] &lt;&lt; \" \"; &#125; fout.close(); fin1.close(); fin2.close(); return 0;&#125; 实验八（第十一章） 实践题三【问题描述】 使用 getline 成员函数读入某个text文件（f5.txt）中的“一篇文章”（如可以是一个C++源程序，文件名由用户从键盘输入），而后将该文件的各空行以及各程序行中的注解均删除掉（认为该行中从第一个双撇符号“//”开始直至行末的所有符号为注解），并将删除注解后的结果行写出到另一个文件（f6.txt）中。 【输入形式】 逐行读入文件f5.txt的内容。 【输出形式】【样例输入】 文件f5.txt的内容如下： 123456789101112131415161718//This is test#include &lt;iostream&gt;int main()&#123;cout&lt;&lt;\"Hello World\"&lt;&lt;endl;return 0;&#125; 【样例输出】 文件f6.txt的内容如下： 123456#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;\"Hello World\"&lt;&lt;endl; return 0;&#125; 题解： 12345678910111213141516171819#include&lt;fstream&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; ifstream fin(\"f5.txt\"); ofstream fout(\"f6.txt\"); char s[100];int i; while(fin.getline(s,100)) &#123; if(s[0]=='\\0'||s[0]=='/') continue; for(i=0;s[i]!='\\0';i++) if(s[i]=='/') s[i]='\\0'; fout &lt;&lt; s; fout &lt;&lt; endl; &#125; fin.close(); fout.close(); return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验六 类与对象","slug":"【C-】实验六-类与对象","date":"2019-11-24T14:22:13.000Z","updated":"2020-01-27T16:28:42.104Z","comments":true,"path":"2019/11/24/【C-】实验六-类与对象/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E5%AE%9E%E9%AA%8C%E5%85%AD-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"复数类【问题描述】自定义一个复数类型Complex，其中含有若干成员函数，使用该类可以完成复数的加法以及对复数的输出。请完成类定义，并编制主函数，说明Complex类对象，对定义的各成员函数进行调用。 123456789class Complex &#123; double real; //复数实部 double imag; //复数虚部public: Complex (); //无参构造函数，将复数对象的实部和虚部均置为0 Complex (double r, double i); //有参构造函数，设置对象的实部和虚部 Complex AddCom(Complex c2); //调用者对象与对象c2相加，返回Complex类对象 void OutCom () ; //输出调用者对象的有关数据（各分量）&#125;; 具体 要求如下： 1、实现有参构造函数 Complex (double r, double i); 2、实现 Complex AddCom(Complex c2); 调用者对象与对象c2相加，返回Complex类对象 3、实现void OutCom () ;实现输出调用者对象的有关数据分量（一定要输出虚部的符号i），如果该数为纯虚数时,不需要输出实部，当虚部为0时，不需要输出实部。 4．编制主函数main，作用有参函数说明类对象cx,cy，使用 Complex 调用AddCom实现复数加法，并将相加的结果调用 OutCom方法以复数的形式输出。 【输入形式】输入包括a,b,c,d四个整数，第一个复数为a+bi，第二个复数为c+di 【输出形式】 【样例输入】1 2 3 4 【样例输出】4+6i 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class Complex&#123; double real; double imag;public: Complex():real(0),imag(0)&#123;&#125; Complex(double r,double i):real(r),imag(i)&#123;&#125; Complex AddCom(Complex c2); void OutCom();&#125;;Complex Complex::AddCom(Complex c2)&#123; Complex temp(this-&gt;real+c2.real,this-&gt;imag+c2.imag); return temp; &#125;void Complex::OutCom()&#123; if(real==0&amp;&amp;imag!=0) cout &lt;&lt; imag &lt;&lt; \"i\"; else if(imag==0) cout &lt;&lt; real; else cout &lt;&lt; real &lt;&lt; \"+\" &lt;&lt; imag &lt;&lt; \"i\";&#125;int main()&#123; int a,b,c,d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; Complex x(a,b),y(c,d); x=x.AddCom(y); x.OutCom(); return 0;&#125; 学生类【问题描述】设计一个学生类（CStudent），其私有数据成员：注册号、姓名、数学、外语、计算机课程的成绩。公有成员函数是：求三门课总成绩的函数 Sum；求三门课平均成绩的函数 Average；显示学生数据信息的函数 Display；设置学生数据信息的函数 SetData。 1．可按如下样式设计 CStudent类的各数据成员以及成员函数class CStudent { //学生类 CStudent unsigned long reg_num; //数据成员：注册号 char name[30]; //数据成员：姓名 float math, eng, comp; //数据成员：数学、英语、计算机成绩public: //公有成员函数 float Sum(); //求三门课总成绩的函数 Sum float Average(); //求三门课平均成绩的函数 Average Display(); //显示学生数据信息的函数 Display SetData (unsigned long r, char* n, float m, float e, float c) ; //设置学生数据信息的函数 SetData}; 在主函数，通过使用“CStudent stu[150];”的语句，来说明一个CStudent类对象的数组stu，而后通过各对象stu[i]来处理并求取每一学生的总成绩、平均成绩等。 （1）输入本次欲处理的学生人数 TOTAL（小于等于 150 的正整数）；（2）输入全班 TOTAL 个学生的有关信息，依次放入对象数组的各元素 stu[i]中（通过使用“stu[i].SetData(…);”形式的语句来实现）；（3）对全班TOTAL个学生，依次通过对象stu[i]来求出其总成绩、平均成绩等（其中要使用形如“stu[i].Sum()”以及“stu[i].Average()”式样的对成员函数进行调用的语句），并同时求出全班学生总成绩最高者处于 stu 数组的下标位置idx_max，而后通过使用“stu[idx_max].Display();”来输出该学生有关的全部数据信息。 3．程序执行后的输入输出界面样式可设计为：TOTAL=3CStudent 1 : 100001 ma 78 86 90（注意空格）CStudent 2 : 100002 li 85 91 88CStudent 3 : 100003 hu 82 89 88CStudent1.Sum=254,CStudent1.average=84.6667CStudent2.Sum=264,CStudent2.average=88CStudent3.Sum=259,CStudent3.average=86.3333class_Sum_max=264The infomation of the CStudent with class_Sum_max : 100002 li 85 91 88【输入形式】TOTAL=3CStudent 1 : 100001 ma 78 86 90（注意空格）CStudent 2 : 100002 li 85 91 88CStudent 3 : 100003 hu 82 89 88【输出形式】CStudent1.Sum=254,CStudent1.average=84.6667CStudent2.Sum=264,CStudent2.average=88CStudent3.Sum=259,CStudent3.average=86.3333class_Sum_max=264The infomation of the CStudent with class_Sum_max : 100002 li 85 91 88 【样例输入】3100001 ma 78 86 90100002 li 85 91 88100003 hu 82 89 88【样例输出】TOTAL=3CStudent 1 : 100001 ma 78 86 90（注意空格）CStudent 2 : 100002 li 85 91 88CStudent 3 : 100003 hu 82 89 88CStudent1.Sum=254,CStudent1.average=84.6667CStudent2.Sum=264,CStudent2.average=88CStudent3.Sum=259,CStudent3.average=86.3333class_Sum_max=264The infomation of the CStudent with class_Sum_max : 100002 li 85 91 88 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class Cstudent&#123; unsigned reg_num; char name[30]; float math,eng,comp; public: float Sum(); float Average(); void Display(); void setData(unsigned long r, char* n, float m, float e, float c);&#125;;void Cstudent::Display()&#123; cout&lt;&lt;reg_num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;math&lt;&lt;\" \"&lt;&lt;eng&lt;&lt;\" \"&lt;&lt;comp&lt;&lt;endl;&#125;float Cstudent::Sum()&#123; return (math+eng+comp);&#125;float Cstudent::Average()&#123; return (math+eng+comp)/3;&#125;void Cstudent::setData(unsigned long r,char* n,float m,float e,float c)&#123; reg_num=r;strcpy(name,n);math=m;eng=e,comp=c;&#125;int main()&#123; int n; unsigned long num; char name[30]; float math,eng,comp; float max=0; int max_stu=0; cin&gt;&gt;n; Cstudent *cp=new Cstudent[n]; int i,temp; for(i=0;i&lt;n;i++) &#123; cin &gt;&gt; num &gt;&gt; name &gt;&gt; math &gt;&gt; eng &gt;&gt; comp; cp[i].setData(num,name,math,eng,comp); temp=cp[i].Sum(); if(temp &gt; max) &#123; max=temp; max_stu=i; &#125; &#125; cout&lt;&lt;\"TOTAL=\"&lt;&lt;n&lt;&lt;endl; for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;\"CStudent \"&lt;&lt;i+1&lt;&lt;\" : \"; cp[i].Display(); &#125; for(int i=0;i&lt;n;i++) &#123; cout&lt;&lt;\"CStudent\"&lt;&lt;i+1&lt;&lt;\".Sum=\"&lt;&lt;cp[i].Sum(); cout&lt;&lt;\",CStudent\"&lt;&lt;i+1&lt;&lt;\".average=\"&lt;&lt;cp[i].Average()&lt;&lt;endl; &#125; cout&lt;&lt;\"class_Sum_max=\"&lt;&lt;max&lt;&lt;endl; cout&lt;&lt;\"The infomation of the CStudent with class_Sum_max : \"; cp[max_stu].Display();delete [] cp;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验五 指针","slug":"【C-】实验五-指针","date":"2019-11-24T14:18:59.000Z","updated":"2020-01-27T16:28:56.485Z","comments":true,"path":"2019/11/24/【C-】实验五-指针/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E5%AE%9E%E9%AA%8C%E4%BA%94-%E6%8C%87%E9%92%88/","excerpt":"","text":"字符串统计【问题描述】 在进行文章重复度检查时，经常需要统计一段英文中的单词数量，并找出长度最长的单词。 设有如下定义：char str[500]; 编写程序，通过利用cin.getline(str,500);实现从键盘输入一小段英文（其中可以包含空格，但在同一行），利用函数统计该段英文中包含几个单词，输出统计出的单词数量、最长单词的长度以及长度最长的单词，空格隔开。 注意：函数声明使用void split(char *str);如果有最长的单词不只一个，输出最先找到的那个。 【输入形式】一小段英文，不要超过500个字符 【输出形式】单词数量、最长单词的长度以及长度最长的单词，空格隔开。 【样例输入】welcome to china university of mining and technology 【样例输出】8 10 university 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;void split(char *str)&#123; int num_word=0; int temp=0,maxlen=0,maxwhere=0; for(int i=0;str[i]!='\\0';i++) &#123; if(str[i+1]=='\\0'&amp;&amp;str[i]&gt;='a'&amp;&amp;str[i]&lt;='z') str[i+1]=' '; if(str[i]==' ') &#123; num_word++; if(temp&gt;maxlen) &#123; maxlen=temp; maxwhere=i-temp; temp=0; &#125; else temp=0; &#125; else &#123; temp++; &#125; &#125; cout &lt;&lt; num_word &lt;&lt; \" \" &lt;&lt; maxlen &lt;&lt; \" \"; while(str[maxwhere]!=' ') cout &lt;&lt; str[maxwhere++];&#125;int main()&#123; char str[500]; cin.getline(str,500); split(str); return 0;&#125; 复数提取【问题描述】 编写如下原型的函数： void split(double x,intiPart,doublefPart); 提取出数据x的整数部分与小数部分，分别放于iPart与fPart处，由于形参iPart与fPart都是指针，从而可实现将这两个结果“带回”到主函数中。 在主函数中 输入一个数 输出它的整数部分和小数部分，用空格隔开。 提示：一个double类型数，强制类型转换后就是int，也就是整数部分，差为小数部分。这两个值用指针iPart和指针fPart带回（通过修改指针的目标变量值。） 【输入形式】一个数 【输出形式】整数部分 小数部分，用空格隔开 【样例输入】12.3【样例输出】12 0.3 12345678910111213141516#include&lt;iostream&gt;using namespace std;void split(double x,int *iPart,double *fPart)&#123; *fPart = x-(int)x; *iPart=(int)x;&#125;int main()&#123; int zhengshu; double xiaoshu,x; cin &gt;&gt; x; split(x,&amp;zhengshu,&amp;xiaoshu); cout &lt;&lt; zhengshu &lt;&lt; \" \" &lt;&lt; xiaoshu; return 0;&#125; 找子串最后一次出现的头字符位置【问题描述】 编制具有如下原型的函数findLast： charfindLast(charsourceStr,char*subStr); findLast函数则要返回源串sourceStr中最后一次出现subStr子字符串的头字符位置。 而后编制主函数，输入两个字符串，将它们用作实参来调用这两个函数，如果返回NULL输出-1，否则输出子字符串出现时头字符在原字符串的下标，每个结果占一行。 要求实现程序中不可使用“string.h”头文件内有关寻找子串的标准库函数。 【输入形式】输入源串sourceStr，子字符串subStr。 【输出形式】子字符串subStr最后一次在源串sourceStr中出现的位置 【样例输入】 welcometochinauniversityofminingandtechnology in 【样例输出】29 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;char*findLast(char*sourcestr,char*substr)&#123; char *ans=NULL; char *temp1,*temp2; for(int i=0;sourcestr[i]!='\\0';i++) &#123; if(sourcestr[i]==*substr) &#123; int flag=1; temp1=sourcestr+i; temp2=substr; while(*temp2!='\\0') &#123; if(*temp1!=*temp2) flag=0; temp1++;temp2++; &#125; if(flag) ans=sourcestr+i; &#125; &#125; return ans;&#125;int main()&#123; char sourcestr[500],substr[500]; char *ans; cin &gt;&gt; sourcestr &gt;&gt; substr; ans=findLast(sourcestr,substr); if(ans) cout &lt;&lt; ans-sourcestr; else cout &lt;&lt; -1; return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验四 数组","slug":"【C-】实验四-数组","date":"2019-11-24T14:15:43.000Z","updated":"2020-01-27T16:28:53.058Z","comments":true,"path":"2019/11/24/【C-】实验四-数组/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E6%95%B0%E7%BB%84/","excerpt":"数组的复制 | 围圈报数问题 | 求日期间隔(考虑闰年) | 统计单词的个数","text":"数组的复制 | 围圈报数问题 | 求日期间隔(考虑闰年) | 统计单词的个数 实践题1【问题描述】编程序，实现如下功能： （1）定义两个一维数组x，y，不超过50个元素。 （2）从键盘输入k个整数到数组x中。 （3）计算x中数据的平均值ave及大于平均值的元素个数n并输出。 （4）将数组x中数据复制到数组y中，重复的数据只存储一次，最后输出y中的数据。 【输入形式】输入两行，第一行为输入的数据个数，第二行若干整数，每个整数后面有一个空格用于分隔；【输出形式】第一行若干整数，每个整数后面有一个空格，最后一个空格后换行；第二行若干整数，每个整数后面有一个空格，最后一个空格后不需要换行； 【样例输入】 6 6 3 4 3 2 9 【样例输出】 4.5 26 3 4 2 9 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123;// freopen(\"1.in\",\"r\",stdin);// freopen(\"1.out\",\"w\",stdout); int x[51]; x[0]=0; int k,i,j,cnt=0; float ave; cin &gt;&gt; k; for(i=1;i&lt;=k;i++) &#123; cin &gt;&gt; x[i]; x[0]+=x[i]; &#125; ave=(float)x[0]/k; cout &lt;&lt; ave &lt;&lt; \" \"; for(i=1;i&lt;=k;i++) if(x[i]&gt;ave)cnt++; cout &lt;&lt; cnt &lt;&lt; endl; for(i=1;i&lt;=k;i++) &#123; int flag=1; for(j=1;j&lt;i;j++) if(x[j]==x[i]) flag=0; if(flag) cout &lt;&lt; x[i] &lt;&lt; \" \"; else continue; &#125;// fclose(stdin);// fclose(stdout); return 0;&#125; 实践题2【问题描述】有 12 人围坐成一圈玩报数游戏，从1号人员开始顺时针报数，报到k的人员被淘汰出局；接着仍沿顺时针方向从被淘汰出局者的下一人员又重新从 1 开始报数，报到 k的人被淘汰；如此继续，直到最后只剩下一个人时停止。请编写程序输出最后所剩那个人的编号。 注意：（1）假设参加游戏的人的编号沿顺时针方向依次为 1 到 12，可以使用数组来存放各数据； （2）k&gt;1，由用户通过 cin 输入指定。 【输入形式】输入一个整数，代表报数值；【输出形式】输出一个整数，即最后剩下的人的编号；【样例输入】3【样例输出】10 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;const int MAX = 12;int main()&#123;// freopen(\"1.in\",\"r\",stdin);// freopen(\"1.out\",\"w\",stdout); int k,a[MAX+1]=&#123;0&#125;; cin &gt;&gt; k; int now=1; for(int i=1;i&lt;=MAX-1;i++) &#123; for(int j=1;j&lt;=k;) &#123; if(now&gt;MAX) now-=MAX; if(j==k&amp;&amp;a[now]!=1)break; if(j==k&amp;&amp;a[now]==1) &#123; now++; continue; &#125; if(a[now]==0) &#123; j++; now++; continue; &#125; if(a[now]==1)now++; &#125; a[now]=1; now++; &#125;// for(int i=1;i&lt;=MAX;i++) cout &lt;&lt; a[i] &lt;&lt; \" \";// cout &lt;&lt; endl; for(int i=1;i&lt;=MAX;i++) &#123; if(a[i]==0) cout &lt;&lt; i; &#125;// fclose(stdin);// fclose(stdout); return 0;&#125; 实践题3【问题描述】小宗想知道两个日期之间所间隔的天数，他希望有一个日期计算器，输入两个日期后能够自动计算之间的天数。要求：设计相应的函数完成天数的计算，在主函数中验证正确性。 【输入形式】按照年月日的顺序输入两个日期，年月日之间用一个空格分隔；【输出形式】输出两个日期之间的天数，即一个整数，整数后不需要换行；【样例输入】 2016 3 6 2017 1 1 【样例输出】301【样例说明】输入输出中不要有中文提示，最后的输出不需要换行。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;int is_run(int year)&#123; if(year%4==0&amp;&amp;year%100!=0) return 1; if(year%100==0&amp;&amp;year%400==0) return 1; return 0;&#125;int main()&#123;// freopen(\"1.in\",\"r\",stdin);// freopen(\"1.out\",\"w\",stdout); int g[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; int nian1,yue1,ri1; int nian2,yue2,ri2; int ans=0; cin &gt;&gt; nian1 &gt;&gt; yue1 &gt;&gt; ri1; cin &gt;&gt; nian2 &gt;&gt; yue2 &gt;&gt; ri2; for(int i=nian1;i&lt;nian2;i++) &#123; if(is_run(i)) ans+=366; else ans+=365; &#125; //计算后一个年份的天数 if(is_run(nian2))g[2]=29; for(int i=0;i&lt;yue2;i++) ans+=g[i]; ans+=ri2; g[2]=28; //减去最初年份的天数 if(is_run(nian1))g[2]=29; for(int i=0;i&lt;yue1;i++) ans-=g[i]; ans-=ri1; cout &lt;&lt; ans;// fclose(stdin);// fclose(stdout); return 0;&#125; 实践题4【问题描述】对于整型数组a[10]和b[10]，编制程序完成下列任务: （1）由用户从键盘为两个数组输入值； （2）求出两个数组的最大值和最小值； （3）把数组a和b中的整数分别从小到大和从大到小排序； （4）把两个有序的数组a和b组成一个长度为20的有序数组c[20]，使数组c的顺序为从小到大。 【输入形式】输入两行整数，每行10个，第一行是数组a里的数组，第二行是数组b里的数值；【输出形式】输出五行，第一行有两个整数，分别是数组a的最大值和最小值，两个整数之间用一个空格分隔；第二行有两个整数，分别是数组b的最大值和最小值，两个整数之间用一个空格分隔；第三行按照从小到大的顺序输出数组a里的数值，每个数字后面有一个空格，最后一个数字后面也有空格；第四行按照从大到小的顺序输出数组b里的数值，每个数字后面有一个空格，最后一个数字后面也有空格；第五行按照从小到大的顺序输出合并后数组c里的数值，每个数字后面有一个空格，最后一个数字后面也有空格。 【样例输入】 2 5 9 1 3 4 0 6 7 8 10 5 25 9 6 3 7 1 2 13【样例输出】 9 0 25 1 0 1 2 3 4 5 6 7 8 9 25 13 10 9 7 6 5 3 2 1 0 1 1 2 2 3 3 4 5 5 6 6 7 7 8 9 9 10 13 25【样例说明】请严格按照输入输出形式的规定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;void sort(int g[],int n)&#123; int temp; for(int i=1;i&lt;n;i++) &#123; int min=g[i]; int min_where=i; for(int j=i+1;j&lt;=n;j++) &#123; if(min&gt;g[j]) &#123; min=g[j]; min_where=j; &#125; &#125; temp = g[i]; g[i] = g[min_where]; g[min_where]=temp; &#125;&#125;int main()&#123;// freopen(\"1.in\",\"r\",stdin);// freopen(\"1.out\",\"w\",stdout); int a[11],b[11],c[21]; int amax=0,amin=0x7fffffff,bmax=0,bmin=0x7fffffff; for(int i=1;i&lt;=10;i++) &#123; cin &gt;&gt; a[i]; if(a[i]&gt;amax)amax=a[i]; if(a[i]&lt;amin)amin=a[i]; &#125; for(int i=1;i&lt;=10;i++) &#123; cin &gt;&gt; b[i]; if(b[i]&gt;bmax)bmax=b[i]; if(b[i]&lt;bmin)bmin=b[i]; &#125; cout &lt;&lt; amax &lt;&lt; \" \" &lt;&lt; amin &lt;&lt; endl; cout &lt;&lt; bmax &lt;&lt; \" \" &lt;&lt; bmin &lt;&lt; endl; sort(a,10); sort(b,10); for(int i=1;i&lt;=10;i++) cout &lt;&lt; a[i] &lt;&lt; \" \";cout &lt;&lt; endl; for(int i=10;i&gt;=1;i--) cout &lt;&lt; b[i] &lt;&lt; \" \";cout &lt;&lt; endl; for(int i=1;i&lt;=10;i++) c[i]=a[i]; for(int i=11;i&lt;=20;i++) c[i]=b[i-10]; sort(c,20); for(int i=1;i&lt;=20;i++) cout &lt;&lt; c[i] &lt;&lt; \" \";// fclose(stdin);// fclose(stdout); return 0;&#125; 实践题5【问题描述】利用cin.getline()函数从键盘录入一句英文，其中每个单词之间用一个空格隔开，最后用’.’结束。统计该句话中单词的个数，并依次输出每个单词。输出个数后换行，输出每个单词后也换行。注意：在本平台下，cin.getline()函数的使用方式如下： char s[50]; cin.getline(s,50); //最多存储49个字符 【输入形式】输入一句英文，其中每个单词之间用一个空格隔开，最后一个单词后面用英文的’.’作为结束；【输出形式】输出每个单词后换行，最后一行输出单词的数量。【样例输入】I like juice.【样例输出】 I like juice 3【样例说明】请严格按照规定的格式输入和输出。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int main()&#123;// freopen(\"1.in\",\"r\",stdin);// freopen(\"1.out\",\"w\",stdout); char s[50]; int cnt=0; cin.getline(s,50); for(int i=0;s[i]!='\\0';i++) &#123; if(s[i]==' '||s[i]=='.') &#123; cout &lt;&lt; endl; cnt++; &#125; else &#123; cout &lt;&lt; s[i]; &#125; &#125; cout &lt;&lt; cnt;// fclose(stdin);// fclose(stdout); return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验三 函数","slug":"【C-】实验三-函数","date":"2019-11-24T14:10:29.000Z","updated":"2020-01-27T16:28:49.278Z","comments":true,"path":"2019/11/24/【C-】实验三-函数/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E5%AE%9E%E9%AA%8C%E4%B8%89-%E5%87%BD%E6%95%B0/","excerpt":"","text":"实践题1【问题描述】编写具有如下原型的函数：bool f(long x);其功能为：若整数 x 仅由偶数字（0、2、4、6、8）组成时（如 x=26480），函数返回 true，否则返回 false（如当 x=22034 时）。并编制主函数对它进行调用。 【输入形式】只能是一个整数数字，中间不能有空格等其他字符；【输出形式】只输出true或者false，后面不要换行。【样例输入】26480【样例输出】true【样例说明】输入输出时不要带有其他说明文字或符号 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;bool f(long x)&#123; while(x) &#123; if(x%10%2!=0) return false; x/=10; &#125; return true;&#125;int main()&#123; long a; cin &gt;&gt; a; if(f(a)) cout &lt;&lt; \"true\"; else cout &lt;&lt; \"false\"; return 0;&#125; 实践题2【问题描述】编写具有如下原型的函数：void find(int i, int n); 实现从 i 开始找起，连续找出 n 个素数并显示在屏幕上。如：实参为10 和 8 后，输出的 8 个素数应为：11，13，17，19，23，29，31，37。 【输入形式】输入两个整数，前一个是查找的起始数字，后一个是指定查找几个素数；【输出形式】输出指定数量的素数，每个素数后面加一个空格作为分隔符，最后一个数字后面可以有一个空格，但不需要换行。【样例输入】13 4【样例输出】13 17 19 23【样例说明】输出结果中除了题目中说明的空格，不要加其他文字和符号。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int is_prime(int n)&#123; int j = 0; for (j = 2; j &lt;=sqrt (n); j++) &#123; if (n%j == 0) &#123; return 0; &#125; &#125; return 1;&#125;void find(int i,int n)&#123; while(n) &#123; if(is_prime(i)) &#123; cout &lt;&lt; i &lt;&lt; \" \"; n--; i++; &#125; else i++; &#125;&#125;int main()&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; find(a,b); return 0;&#125; 实践题3【问题描述】输入正整数start和end，找出从start到end这一区间段内哪一个数n的因子和最大，并将该n及其因子和maxSum作为结果输出。例如，当start=10，end=15时，所求的n应该为12，而maxSum应该为16。 要求：设计函数计算n的因子和，其中因子和为包括1但不包括n本身的所有因子之和。 【输入形式】两个整数，用来指定查找的起始数字和结束数字；【输出形式】两个整数，中间用一个空格隔开，前一个是因子和最大的数字，后一个是因子和，最后一个数字后面不要有空格和换行。【样例输入】10 15【样例输出】12 16【样例说明】输出不要有多余的空格和换行。 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;int yin_sum(int n)&#123; int sum=0; for(int i=1;i&lt;n;i++) if(n%i==0) sum+=i; return sum;&#125;int main()&#123; int start,end,maxsum=-1,temp,aim=0; cin &gt;&gt; start &gt;&gt; end; for(int i=start;i&lt;=end;i++) &#123; temp=yin_sum(i); if(temp &gt; maxsum) &#123; maxsum=temp; aim=i; &#125; &#125; cout &lt;&lt; aim &lt;&lt; \" \" &lt;&lt; maxsum; return 0;&#125; 实践题4 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;bool is_hui(long n)&#123; int copy=0; int num=n; while(num&gt;0) &#123; copy=copy*10+num%10; num/=10; &#125; return (n==copy?1:0);&#125;int main()&#123; int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) if(is_hui(i)&amp;&amp;is_hui(i*7)&amp;&amp;is_hui(i*i*3))cout &lt;&lt; i &lt;&lt; \" \"; return 0;&#125; 实践题5【问题描述】键盘输入正整数 n，求出n与其反序数x之和并输出。例如，输入2038，n+x = 2038 +8302 =10340，输出应为10340。要求：编写函数实现数据转换成反序数值。 【输入形式】输入一个整数；【输出形式】输出一个整数；【样例输入】2038【样例输出】10340【样例说明】不要任何输入输出的文字提示。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int fun(int n)&#123; int ans=0; while(n&gt;0) &#123; ans=ans*10+n%10; n/=10; &#125; return ans;&#125; int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; fun(n)+n; return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验二 程序控制","slug":"【C-】实验二-程序控制","date":"2019-11-24T14:06:04.000Z","updated":"2020-01-27T16:38:42.423Z","comments":true,"path":"2019/11/24/【C-】实验二-程序控制/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6/","excerpt":"","text":"实践题1【问题描述】 利用循环结构，编制程序显示出如下“图形”。 1 131 13531 1357531 135797531 【输入形式】打印图形的行数 【输出形式】打印图形 【样例输入】3 【样例输出】 1 131 13531 【样例说明】每行输出顶格，不需要中间的空格。 1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) cout &lt;&lt; j*2-1; for(int j=i-1;j&gt;=1;j--) cout &lt;&lt; j*2-1; cout &lt;&lt; endl; &#125; return 0;&#125; 实践题2【问题描述】 某商店出售四种商品: A商品每公斤2.75元；B商品每个12.5 元；C商品每米26.8 元；D商品每台512元，超过3台优惠10%，超过8台优惠15%。设计一个计算价格的程序，通过输入购买四种商品的数量，计算并显示每种商品应付金额以及总金额。 【输入形式】 输入每种商品的数量。 【输出形式】 输出每种商品的应付金额和总金额。 【样例输入】 1 2 3 2 【样例输出】 A:2.75 B:25 C:80.4 D:1024 total:1132.15 【样例说明】输出每种数据占一行。 123456789101112131415161718#include&lt;iostream&gt;#include&lt;iomanip&gt; using namespace std;int main()&#123; int a,b,c,d; double a_sum,b_sum,c_sum,d_sum; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; cout &lt;&lt; \"A:\" &lt;&lt; (a_sum=a*2.75) &lt;&lt; endl; cout &lt;&lt; \"B:\" &lt;&lt; (b_sum=b*12.5)&lt;&lt; endl; cout &lt;&lt; \"C:\" &lt;&lt; (c_sum=c*26.8)&lt;&lt; endl; if(d&gt;=0&amp;&amp;d&lt;=3) d_sum=d*512; else if(d&gt;3&amp;&amp;d&lt;=8) d_sum=d*512*0.9; else d_sum=d*512*0.85; cout &lt;&lt; \"D:\" &lt;&lt; d_sum &lt;&lt; endl; cout &lt;&lt; \"total:\" &lt;&lt; (a_sum+b_sum+c_sum+d_sum); return 0;&#125; 实践题3【问题描述】 求n以内被3除余1且个位数为6的所有整数（如16、46、…、286等）并显示在屏幕上。 【输入形式】 输入某个数 【输出形式】 输出所有结果，空格隔开 【样例输入】 300 【样例输出】 16 46 76 106 136 166 196 226 256 286 【样例说明】不要有多余字符。 123456789#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) if(i%3==1&amp;&amp;i%10==6) cout &lt;&lt; i &lt;&lt; \" \"; return 0;&#125; 实践题4【问题描述】 编写一程序统计参赛选手的得分，计分标准为去掉一个最高分和一个最低分后，对剩余得分求平均值。要求首先从键盘输入评委的个数num，然后输入num个分数（分数为小于等于10的一个正实数），输出最终得分。 【输入形式】 输入评委个数和各自分数。 【输出形式】 输出得分。 【样例输入】 59.2 9.6 9.5 9.7 9.7 【样例输出】 9.6 【样例说明】只输出计算最终得分。 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int n; double min=10,max=0,sum=0,num; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) &#123; cin &gt;&gt; num; if(min&gt;num) min=num; if(max&lt;num) max=num; sum+=num; &#125; cout &lt;&lt; (sum-min-max)/(n-2); return 0;&#125; 实践题5【问题描述】 设计一个程序，对于用户输入的任意正整数a（a≥1）和b（b≥2），求出满足bn≤a的最大整数n。 【输入形式】 两个数。 【输出形式】 一个数据。 【样例输入】 30 5 【样例输出】 2 1234567891011#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int a,b,ans; cin &gt;&gt; a &gt;&gt; b; ans = log(a)/log(b); cout &lt;&lt; ans; return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】实验一 基本数据类型与运算符","slug":"【C-】实验一-基本数据类型与运算符","date":"2019-11-24T13:59:40.000Z","updated":"2020-01-27T16:29:00.177Z","comments":true,"path":"2019/11/24/【C-】实验一-基本数据类型与运算符/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E5%AE%9E%E9%AA%8C%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"实践题3【问题描述】 编程序，任意输入5个数据（其中第一个和第三个为整型数据，第二个和第四个为实型数据，第五个为一个字符型数据），求出它们的累加和sum，并将结果显示在屏幕上。 【输入形式】 10 2.3 5 3.3 A【输出形式】 85.6【样例输入】 10 2.3 5 3.3 A 【样例输出】 85.6【样例说明】只输出结果即可，不需要有其他的字符。 123456789101112#include&lt;iostream&gt;using namespace std;int main (void)&#123; int a,c; double b,d,ans = 0; char e; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; ans = a+b+c+d+e; cout &lt;&lt; ans; return 0;&#125; 实践题4【问题描述】 编程序，从键盘输入整数x、y，计算出x2+x–y以及w=2πx+πy2，并将结果显示在屏幕上。 【输入形式】3 4 【输出形式】8 69.115 【样例输入】3 4 【样例输出】8 69.115 【样例说明】数据输出将两式结果输出即可，中间使用空格。 123456789#include&lt;iostream&gt;using namespace std;int main (void)&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; (x*x + x - y) &lt;&lt; \" \" &lt;&lt; (2*3.1415926*x + 3.1415926*y*y); return 0;&#125; 实践题5【问题描述】 编写一个程序，当用户按照“时、分、秒”格式输入两个时刻后，求出这两个时刻的时间差（按秒计算）并打印到屏幕上。 【输入形式】 12 20 30 13 30 30【输出形式】 4200【样例输入】 12 20 30 13 30 30 【样例输出】 4200【样例说明】输入顺序为第一个时刻的时分秒（之间用空格），空格，第二个时刻的时分秒。输出相差秒数为正数。 12345678910#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main (void)&#123; int a1,b1,c1,a2,b2,c2; cin &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; c1 &gt;&gt; a2 &gt;&gt; b2 &gt;&gt; c2; cout &lt;&lt; abs((a1*3600+b1*60+c1)-(a2*3600+b2*60+c2)); return 0;&#125;","categories":[{"name":"C++实践作业","slug":"C-实践作业","permalink":"https://cnatom.github.io/categories/C-%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】第11章作业","slug":"【C-】第11章作业","date":"2019-11-24T13:47:51.000Z","updated":"2020-01-27T16:27:21.894Z","comments":true,"path":"2019/11/24/【C-】第11章作业/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E7%AC%AC11%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"三个选择题 Shape类的继承【问题描述】定义一个Shape基类，在此基础上派生出Rectangle和Circle类，二者都有GetArea（）函数计算对象的面积,使用Rectangle类创建一个派生类Square。并应用相应类的对象测试。【注意：π取3.14】 【输入形式】三种形状基本数据。 【输出形式】对应每种形状的面积。【样例说明】第一行的数据为基本数据（四个），分别为圆形半径，长方形长和宽，正方形边长。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;using namespace std;class Shape &#123; public: Shape()&#123;&#125; ~Shape()&#123;&#125; virtual float GetArea() &#123;return -1;&#125; &#125;; class Circle :public Shape &#123;private: float r;public: Circle(float rr):r(rr)&#123;&#125; virtual float GetArea() &#123; return (3.14*r*r); &#125; &#125;;class Rectangle:public Shape &#123;protected: float l,h;public: Rectangle(float ll,float hh):l(ll),h(hh)&#123;&#125; virtual float GetArea() &#123; return (l*h); &#125;&#125;;class Square: public Rectangle&#123;public: Square(float ss):Rectangle(ss,ss)&#123;&#125; virtual float GetArea() &#123; return (h*l); &#125;&#125;;int main() &#123; Shape *sp; int radium,length,hight,side;cin&gt;&gt;radium&gt;&gt;length&gt;&gt;hight&gt;&gt;side;sp=new Circle(radium); cout&lt;&lt;\"The area of the circle is \"&lt;&lt;sp-&gt;GetArea()&lt;&lt;endl; sp=new Rectangle(length,hight); cout&lt;&lt;\"The area of the rectangle is \"&lt;&lt;sp-&gt;GetArea()&lt;&lt;endl; sp=new Square(side); cout&lt;&lt;\"The area of the Square is \"&lt;&lt;sp-&gt;GetArea()&lt;&lt;endl;delete sp;return 0;&#125;","categories":[{"name":"C++理论作业","slug":"C-理论作业","permalink":"https://cnatom.github.io/categories/C-%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】第9章作业","slug":"【C-】第9章作业","date":"2019-11-24T13:39:18.000Z","updated":"2020-01-27T16:27:27.810Z","comments":true,"path":"2019/11/24/【C-】第9章作业/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E7%AC%AC9%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"三角形类【问题描述】 先定义一个能描述平面上一条线段的类Beeline，包含私有数据成员为线段两个端点的坐标(X1，Y1，X2，Y2)，在类中定义形参默认值为0的构造函数，计算线段长度的公有成员函数Length()，显示线段两个端点坐标的公有成员函数show()。然后再定义一个能描述平面上三角形的类Triangle，其数据成员为用Beeline定义的对象line1，line2，line3。在类中定义的构造函数要能对对象成员进行初始化。再定义计算三角形面积的函数Area()及显示三条边端点坐标及面积的函数Print()，Print()函数中可调用show()函数显示三条边两端点坐标。 【输入形式】 输入三角形三个顶点的坐标(x1,y1)、(x2,y2)、(x3,y3)。 其中 -100 &lt;= x1,x2,x3,y1,y2,y3 &lt;= 100，且为整数。 在主函数中创建类对象tri(x1,y1,x2,y2,x3,y3)，对应line1(x1, y1, x2, y2),line2(x2,y2,x3,y3),line3(x3,y3,x1,y1)。 【输出形式】 调用Print()函数，将三角形三条边的端点坐标及面积。面积保留两位小数。 具体格式见样例。 【样例输入】 0 0 0 4 3 0 【样例输出】 Three edges’ points are listed as follows: (0, 0),(0, 4) (0, 4),(3, 0) (3, 0),(0, 0) The area of this triangle is: 6.00. 【提示】 1.严格按照输出样例输出，建议复制。 2.计算面积建议用海伦公式。 3.严格控制保留2位小数。 4.如果没有严格使用类，得分为0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt; class Beeline&#123;private: int x1; int x2; int y1; int y2;public: Beeline(int xx1=0,int yy1=0,int xx2=0,int yy2=0):x1(xx1),y1(yy1),x2(xx2),y2(yy2)&#123;&#125;; float length(); void show();&#125;;float Beeline::length()&#123;return (sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));&#125;void Beeline::show()&#123;std::cout &lt;&lt; \"(\" &lt;&lt; x1 &lt;&lt; \", \" &lt;&lt; y1 &lt;&lt; \"),(\" &lt;&lt; x2 &lt;&lt;\", \" &lt;&lt; y2 &lt;&lt;\")\" &lt;&lt; std::endl;&#125;class Triangle&#123;private: Beeline line1,line2,line3;public: Triangle(int x1,int y1,int x2,int y2,int x3,int y3):line1(x1,y1,x2,y2),line2(x2,y2,x3,y3),line3(x3,y3,x1,y1)&#123;&#125;; float area(); void print();&#125;;float Triangle::area()&#123;float a=line1.length();float b=line2.length();float c=line3.length();float p=(a+b+c)/2;return (sqrt(p*(p-a)*(p-b)*(p-c)));&#125;void Triangle::print()&#123;line1.show();line2.show();line3.show();&#125;int main()&#123;int x1,y1,x2,y2,x3,y3;std::cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;Triangle t(x1,y1,x2,y2,x3,y3);std::cout &lt;&lt; \"Three edges' points are listed as follows:\" &lt;&lt; std::endl;t.print();std::cout &lt;&lt; \"The area of this triangle is: \";std::cout.setf(std::ios::fixed);std::cout &lt;&lt; std::setprecision(2)&lt;&lt; t.area() &lt;&lt; \".\";return 0;&#125; 学生成绩类【问题描述】设计学生成绩类Score。在主函数中定义学生成绩对象数组s[]。用Sum()计算每个学生的总成绩、用Show()显示每个学生的成绩。增加静态成员函数getAvg()，用于返回学生的总平均分。通过增加合适的成员、修改成员函数等完成这一功能。 【输入形式】 包含一组测试数据。第一行输入一个整数n（1&lt;=n&lt;=100）。 接下来n行。每行先输入一个整数op： 当op==1时，输入x, y, z。代表输入一位新同学i(i从1开始编号)的语文、数学、英语成绩，无需输出。 当op==2时，输入i，输出第i同学的总成绩。数据保证这位同学的成绩已经录入。 当op==3时，输入i，依次输出第i同学的语文数学英语成绩，成绩之间用空格隔开。 当op==4时，输出当前已经录入学生的总平均分，结果保留两位小数。 (1&lt;=n&lt;=100, 1&lt;=id&lt;=10, 1&lt;=op&lt;=3, 0&lt;=x,y,z&lt;=100,全部输入都为整型数) 【输出形式】 注意输入之间会有一些输出，但测试只看cout结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iomanip&gt;using namespace std;class Score &#123;private: int Chinese, Math, English; static int TotalScore; static int TotalStudent;public: Score() &#123;&#125; void setScore (int c, int m, int e) &#123; Chinese=c; Math = m; English = e; TotalStudent++; TotalScore = TotalScore + Chinese + Math + English; &#125; int Sum() &#123; return Chinese+Math+English; &#125; void Show() &#123; cout&lt;&lt;Chinese&lt;&lt;\" \"&lt;&lt;Math&lt;&lt;\" \"&lt;&lt;English&lt;&lt;endl; &#125; double static getAve() &#123; return double(TotalScore)/double(TotalStudent); &#125;&#125;;int Score::TotalScore=0;int Score::TotalStudent=0;int main() &#123; int n, op, i, c, m, e; cin &gt;&gt; n; int id = 1; Score sco[11]; while(n--) &#123; cin &gt;&gt; op; if(op == 1) &#123; cin &gt;&gt; c &gt;&gt; m &gt;&gt; e; sco[id].setScore(c,m,e);id++; &#125; else if(op == 2) &#123; cin &gt;&gt; i; cout&lt;&lt;sco[i].Sum()&lt;&lt;endl; &#125; else if(op == 3) &#123; cin &gt;&gt; i; sco[i].Show(); &#125; else &#123;cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;Score::getAve()&lt;&lt;endl; &#125; &#125; return 0;&#125; 电视类【问题描述】 补全设计一个TV类和一个Remote类。Remote类的成员函数是TV类的友元， 电视类有状态、频道和音量基本属性，默认初始频道为5，默认初始音量为20。状态有开和关（-1表示关机状态，其他为开机状态）。 在主函数根据输入的op值进行不同操作。补全代码使程序满足如下要求。 【输入形式】 当op==1时， 输入电视操作命令如下： OFF_ON（切换电视开关机状态） VOL_UP（电视音量+1） VOL_DOWN（电视音量-1） CHA_NEXT（电视频道+1） CHA_PRE(电视频道-1) CHA_TO x（0&lt;=x&lt;=100，将电视频道切到x） VOL_TO x（0&lt;=x&lt;=100，将电视音量切到x） 其中CHA_TO与VOL_TO通过调用友元类实现。 当op==2时，输出当前电视状态。 当op==3时，结束程序。 【输出形式】 当op==2时，输出当前电视状态，具体格式见样例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;using namespace std;class TV;class Remote&#123;public: Remote() &#123;&#125;; void volume_to(TV &amp;tv, int x); void channel_to(TV &amp;tv, int x);&#125;;class TV&#123;private: int state; int channel; int volume;public: friend void Remote::volume_to(TV &amp;tv, int x); friend void Remote::channel_to(TV &amp;tv, int x); TV() &#123;&#125;; TV(int st) :state(st),volume(20),channel(5)&#123;&#125; void onoff() &#123; state = -state; &#125; void cha_next() &#123; channel++; &#125; void cha_pre() &#123; channel--; &#125; void vol_up() &#123; volume++; &#125; void vol_down() &#123; volume--; &#125; void print() &#123; if(state == -1) &#123; cout &lt;&lt; \"The TV is OFF\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"The TV is ON\" &lt;&lt; endl; cout &lt;&lt; \"The channel is \" &lt;&lt; channel &lt;&lt; endl; cout &lt;&lt; \"The volume is \" &lt;&lt; volume &lt;&lt; endl; &#125; &#125;&#125;;void Remote::volume_to(TV &amp;tv, int x) &#123; tv.volume = x;&#125;void Remote::channel_to(TV &amp;tv, int x) &#123; tv.channel = x;&#125;int main()&#123; int x, op; string s; TV tv(-1); Remote rem; while(1) &#123; cin &gt;&gt; op; if(op == 1) &#123; cin &gt;&gt; s; if(s == \"OFF_ON\") tv.onoff(); else if(s == \"VOL_UP\") tv.vol_up(); else if(s == \"VOL_DOWN\") tv.vol_down(); else if(s == \"CHA_NEXT\") tv.cha_next(); else if(s == \"CHA_PRE\") tv.cha_pre(); else if(s == \"CHA_TO\") &#123; cin &gt;&gt; x; rem.channel_to(tv, x); &#125; else if(s == \"VOL_TO\") &#123; cin &gt;&gt; x; rem.volume_to(tv, x); &#125; &#125; else if(op == 2)&#123; tv.print(); &#125; else &#123; break; &#125; &#125; return 0;&#125;","categories":[{"name":"C++理论作业","slug":"C-理论作业","permalink":"https://cnatom.github.io/categories/C-%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】第6章作业","slug":"【C-】第6章作业","date":"2019-11-24T13:33:10.000Z","updated":"2020-01-27T16:27:34.879Z","comments":true,"path":"2019/11/24/【C-】第6章作业/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E7%AC%AC6%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"插入字符串【问题描述】从键盘输入一个字符串，并在串中的第一次出现的最大元素后边插入字符串”ab”。 【输入形式】任意输入一个字符串 【输出形式】在串中的最大元素后边插入字符串”ab” 【样例输入】123csCUMT【样例输出】123csabCUMT 【样例说明】为了保证输入的字符串有空格，请使用cin.getline(char* , int); 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123;int maxnum=0,maxwhere=0,i;char str[500];cin.getline(str,500);for(i=0;str[i]!='\\0';i++)&#123; if((int)str[i]&gt;maxnum) &#123; maxnum=(int)str[i]; maxwhere=i; &#125;&#125;for(i=0;i&lt;=maxwhere;i++) cout &lt;&lt; str[i];cout &lt;&lt; \"ab\";for(i=maxwhere+1;str[i]!='\\0';i++) cout &lt;&lt; str[i];return 0;&#125; 统计整数个数【问题描述】输入一个字符串，其包括数字和非数字字符，如：a123x456 17935? 098tab，将其中连续的数字作为一个整数，依次存放到数组a中，统计共有多少个整数，并输出这些数。 【输入形式】数字和非数字字符的字符串 【输出形式】1)整数个数2）分别输出整数【样例输入】a123x456 17935? 098tab583【注意需要保留带有空格的字符串，请不要使用gets，cin，练习使用cin.getline(char *str, int maxnum)】 【样例输出】 5 123 456 17935 98 583【样例说明】第一个输出项为整数的个数，后面的分别为具体的整数。注意，不需要输出提示类文字，如：“整数为”，“分别为”等字样。直接输出结果。有一个数字的也要输出。测试用例中没有超过整数范围连续数字。当遇到0开头的数字应舍去0。 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;const int MAX=200;int is_num(char c) &#123;return (c&gt;='0'&amp;&amp;c&lt;='9')?1:0;&#125;int main()&#123; char str[MAX]; int total=0; cin.getline(str,MAX); if(is_num(str[0]))total++; for(int i=1;str[i]!='\\0';i++) if(is_num(str[i])&amp;&amp;!is_num(str[i-1])) total++; cout &lt;&lt; total &lt;&lt; endl; for(int i=0;str[i]!='\\0';i++) &#123; if(!is_num(str[i])||(str[i]=='0'&amp;&amp;!is_num(str[i-1])&amp;&amp;is_num(str[i+1])))continue; while(is_num(str[i])) cout &lt;&lt; str[i++]; cout &lt;&lt; endl; &#125; &#125; 字符串排序【问题描述】有5个字符串，首先将它们按照字符串中字符个数由小到大排序，再分别取出每个字符串的第三个字母合并成一个新的字符串输出（若少于三个字符的输出空格）。要求：利用字符串指针和指针数组实现。 【输入形式】5个字符串，用回车分隔【输出形式】输出一个字符串：按5个字符串中字符个数由小到大排序，再分别取出每个字符串的第三个字母合并成一个新的字符串输出，若少于三个字符的输出空格 【样例输入】 test1234 123test cumt think apples【样例输出】 cumt think apples 123test test1234 concatenate string:mip3s【样例说明】输出每个字符串之间用一个空格。字符数量相等的串相对顺序不变。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123;// freopen(\"1.in\",\"r\",stdin);// freopen(\"1.out\",\"w\",stdout); char *ch[5]; for(int i=0;i&lt;5;i++) &#123; ch[i]=new char[10]; cin &gt;&gt; ch[i]; &#125; for(int i=0;i&lt;4;i++) for(int j=0;j&lt;5-i-1;j++) &#123; if(strlen(ch[j])&gt;strlen(ch[j+1])) &#123; char *temp=ch[j]; ch[j]=ch[j+1]; ch[j+1]=temp; &#125; &#125; for(int i=0;i&lt;5;i++)cout &lt;&lt; ch[i] &lt;&lt; \" \"; cout &lt;&lt; endl &lt;&lt; \"concatenate string:\"; for(int i=0;i&lt;5;i++) &#123; if(strlen(ch[i])&lt;3)cout &lt;&lt; \" \"; else cout &lt;&lt; ch[i][2]; delete ch[i]; &#125;// fclose(stdin);// fclose(stdout); return 0;&#125;","categories":[{"name":"C++理论作业","slug":"C-理论作业","permalink":"https://cnatom.github.io/categories/C-%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】第5章作业","slug":"【C-】第5章作业","date":"2019-11-24T13:27:09.000Z","updated":"2020-01-27T16:27:40.966Z","comments":true,"path":"2019/11/24/【C-】第5章作业/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E7%AC%AC5%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"学生成绩统计【问题描述】定义数组存储5位学生的姓名和4科考试的成绩，计算并输出每个学生的总成绩和平均成绩，找出平均成绩最高的学生姓名。 【输入形式】依次输入每位学生的姓名和4科考试的成绩。 【输出形式】1)输出每个学生的总成绩和平均成绩；2）输出平均成绩最高的学生姓名。 【样例输入】说明：下列输入的字符及数字间的空格数为一个空格，如“zhangsan 87 76 91 79”中，“zhangsan”与“87”间为一个空格 zhangsan 87 76 91 79 lisi 90 89 78 69 wangwu 80 88 91 85 zhaoqian 77 79 78 75 sunli 89 87 88 87【样例输出】 说明：下列输出内容格式如下：cout&lt;&lt;setiosflags(ios::left)&lt;&lt;setw(10)&lt;&lt;Name&lt;&lt;setw(9)&lt;&lt;TotalScore&lt;&lt;AverageScore&lt;&lt;endl。 “Name”、”TotalScore”、”AverageScore”用具体的数值替代，如下例： Name TotalScore AverageScore zhangsan 333 83 lisi 326 81 wangwu 344 86 zhaoqian 309 77 sunli 351 87 Student with the highest AverageScore is sunli,AverageScore is 871234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;iomanip&gt; using namespace std;int main()&#123; string name[6]; int score[6][5]=&#123;0&#125;; int ave,max=0,no; for(int i=1;i&lt;=5;i++) &#123; cin &gt;&gt; name[i]; for(int j=1;j&lt;=4;j++) &#123; cin &gt;&gt; score[i][j]; score[i][0]+=score[i][j]; &#125; if(score[i][0]&gt;max) &#123; max=score[i][0]; no=i; &#125; &#125; ave=score[no][0]/4; cout &lt;&lt; \"Name TotalScore AverageScore\" &lt;&lt; endl; for(int i=1;i&lt;=5;i++) cout&lt;&lt;setiosflags(ios::left)&lt;&lt;setw(10)&lt;&lt;name[i]&lt;&lt;setw(9)&lt;&lt;score[i][0]&lt;&lt;score[i][0]/4&lt;&lt;endl; cout &lt;&lt;\"Student with the highest AverageScore is \" &lt;&lt; name[no] &lt;&lt;\",AverageScore is \" &lt;&lt; ave; return 0;&#125; 求二维数组的鞍点【问题描述】 找出一个二维数组（以三行四列的数组为例）中的鞍点，即该位置上的元素在该行上值最大，在该列上值最小（也可能没有鞍点） 【输入形式】 标准输入：二维数组（以三行四列的数组为例） 【输出形式】 标准输出：如果有鞍点，输出鞍点的值及所在行列（例如[1][2]=96 is Saddle Point），如果没有，输出没有鞍点（例如 No Saddle Point） 【样例输入】 9 80 205 40 90 60 96 1 210 3 101 89 【样例输出】 [1][2]=96 is Saddle Point 【样例说明】 请正确输入二维数组,并按照【样例输出】的要求输出结果。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;int main()&#123;// freopen(\"1.in\",\"r\",stdin);// freopen(\"1.out\",\"w\",stdout); int i,j; int n[6][6]=&#123;0&#125;; for(i=1;i&lt;=4;i++)n[i][0]=-0x7ffffff; for(i=1;i&lt;=3;i++)n[0][i]=0x7ffffff; for(i=1;i&lt;=3;i++) &#123; for(j=1;j&lt;=4;j++) &#123; cin &gt;&gt; n[i][j]; if(n[i][j]&gt;n[i][0])n[i][0]=n[i][j]; if(n[i][j]&lt;n[0][j])n[0][j]=n[i][j]; &#125; &#125; int flag=0; for(i=1;i&lt;=3;i++) for(j=1;j&lt;=4;j++) if(n[i][j]==n[i][0]&amp;&amp;n[i][j]==n[0][j]) &#123; cout &lt;&lt;\"[\"&lt;&lt;i-1&lt;&lt;\"]\"&lt;&lt;\"[\"&lt;&lt;j-1&lt;&lt;\"]=\"&lt;&lt;n[i][j]&lt;&lt;\" is Saddle Point\"&lt;&lt;endl; flag=1; &#125; if(flag==1)return 0; else cout &lt;&lt;\"No Saddle Point\"&lt;&lt;endl;// fclose(stdin);// fclose(stdout); return 0;&#125; 字符统计【问题描述】 输入字符串s，编程统计出s中共出现了多少个数字字符。进一步考虑，如何统计出10个数字字符各自出现的次数。 【输入形式】 输入带数字字符的字符串 【输出形式】 1）输出字符串中数字字符的总个数； 2）一次逐行输出从数字字符‘0’到数字字符‘9’的个数 【样例输入】 abcdefk12345 【样例输出】 Number’s amount is:5 ‘0…9’ amount is:0 1 1 1 1 1 0 0 0 0 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123;// freopen(\"1.in\",\"r\",stdin);// freopen(\"1.out\",\"w\",stdout); char ch; int sum=0,n[10]=&#123;0&#125;; while(cin &gt;&gt; ch) &#123; if(ch-'0'&gt;=0&amp;&amp;ch-'0'&lt;=9) &#123; sum++; n[ch-'0']++; &#125; &#125; cout &lt;&lt; \"Number's amount is:\" &lt;&lt; sum &lt;&lt;endl; cout &lt;&lt; \"'0...9' amount is:\"; for(int i=0;i&lt;=9;i++)cout&lt;&lt;n[i]&lt;&lt;\" \";// fclose(stdin);// fclose(stdout); return 0;&#125;","categories":[{"name":"C++理论作业","slug":"C-理论作业","permalink":"https://cnatom.github.io/categories/C-%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】第4章作业","slug":"【C-】第4章作业","date":"2019-11-24T13:20:59.000Z","updated":"2020-01-27T16:27:47.256Z","comments":true,"path":"2019/11/24/【C-】第4章作业/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E7%AC%AC4%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"不同进制间的转换【问题描述】设计一个函数toOcr(int n)，实现把输入的一个十进制数转换为八进制数 【输入形式】十进制数。 【输出形式】与之对应的八进制数。【样例输入】126 【样例输出】176 【样例说明】直接输出数据，不要有其他输出语句，如需测试请使用cerr。【评分标准】给出一个十进制数，正确输出八进制对应的数 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int toOcr(int num)&#123; int temp,ii=1,ans=0; while(num) &#123; temp = num%8; ans+=ii*temp; num/=8; ii*=10; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; toOcr(n); return 0;&#125; 找出亲密对数【问题描述】求数n之内的亲密对数。所谓“亲密对数”，即A的所有因子（包含1但不包含其本身）之和等于B，而B的所有因子之和等于A。 【输入形式】某个数字n。【输出形式】此数字n之内的亲密对数。 【样例输入】400 【样例输出】220 284【样例说明】输出结果每行输出一对亲密数，剔除重复的，按每行第一个数的大小排序。【评分标准】 根据输入的N值，正确列举出N值内的亲密对数 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int yinzi(int num)&#123; int sum=0; for(int i=1;i&lt;num;i++) &#123; if(num%i==0)sum+=i; &#125; return sum;&#125;int main()&#123; int n,a,b; cin &gt;&gt; n; for(int i=1;i&lt;=n;i++) &#123; a=i; b=yinzi(a); if(a==yinzi(b)&amp;&amp;a&lt;b) cout &lt;&lt; a &lt;&lt; \" \"&lt;&lt; b &lt;&lt; endl; &#125; return 0;&#125; 在给定的数中从右边查找第K位数字【问题描述】设计一个函数int digit(long n,int k)，它返回整数n从右边开始第k个数字的值，若不存在第k个数字则返回-1。 【输入形式】输入两个实参【输出形式】对应位的数值 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int digit(long n,int k)&#123; for(int i=1;i&lt;=k-1;i++) &#123; n/=10; if(n==0)return -1; &#125; return n%10;&#125;int main()&#123; long a; int b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; digit(a,b); return 0;&#125;","categories":[{"name":"C++理论作业","slug":"C-理论作业","permalink":"https://cnatom.github.io/categories/C-%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++】第3章作业","slug":"【C-】第3章作业","date":"2019-11-24T13:15:26.000Z","updated":"2020-01-27T16:28:11.212Z","comments":true,"path":"2019/11/24/【C-】第3章作业/","link":"","permalink":"https://cnatom.github.io/2019/11/24/%E3%80%90C-%E3%80%91%E7%AC%AC3%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"猴子吃桃问题【问题描述】猴子吃桃问题。猴子第1天摘了若干个桃子，当即吃了一半，还不解馋，又多吃了一个；第2天，吃剩下的桃子的一半，还不过瘾，又多吃了一个；以后每天都吃前一天剩下的一半多一个，到第n天想再吃时，只剩下一个桃子了。问第一天共摘了多少个桃子？【输入形式】标准输入，剩下一个桃子的天数n。【输出形式】标准输出，第一天共摘的桃子个数。【样例输入】10【样例输出】1534【样例说明】只需输入和输出数据，不要有多余字符出现，有测试输出时请使用cerr。【评分标准】 给出天数，正确输出第一天摘桃子个数 1234567891011121314#include&lt;iostream&gt;using namespace std;int main(void)&#123; int n,ans=1; int i; cin &gt;&gt; n; for(i=1;i&lt;=n-1;i++) &#123; ans=(ans+1)*2; &#125; cout &lt;&lt; ans; return 0;&#125; 百鸡问题【问题描述】n元买100只鸡，大鸡5元每只，小鸡3元每只，还有1/3元每只的小鸡，分别记为x只，y只，z只，求所有解【输入形式】标准输入，总钱数n【输出形式】标准输出，输出x y z 的值，按照x,y,z依次增大顺序输出 【样例输入】100【样例输出】 x=0,y=25,z=75 x=4,y=18,z=78 x=8,y=11,z=81 x=12,y=4,z=84【样例说明】每行一个解，注意逗号为英文字符，每行数据顶格输出。【评分标准】给出n，正确得出所有求解结果 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main(void)&#123; int i,j,k,n; cin &gt;&gt; n; for(i=0;i&lt;100;i++) &#123; for(j=0;j&lt;100;j++) &#123; k = 100-j-i; if((15*i+9*j+k)==3*n &amp;&amp; i+j+k==100 &amp;&amp; k&gt;=0) cout &lt;&lt; \"x=\" &lt;&lt; i &lt;&lt; \",y=\" &lt;&lt; j &lt;&lt; \",z=\" &lt;&lt; k &lt;&lt; endl; &#125; &#125; return 0;&#125; 数字逆序问题描述】输入一个int型的整数num，逆向输出其各位数字，同时求出其位数以及各位数字之和。 【输入形式】输入流（标准）输入，输入一个整数。【输出形式】输出流（标准）输出。结果为三行，第一行为逆向数字，第二行为各位数字之和，第三行为数字位数。【样例输入】1000【样例输出】 0001 1 4【样例说明】注意输出位置在每行开始，不要有其他输出语句，不要有其他多余符号。如有测试必要请使用cerr。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main(void)&#123; int num,i,temp; int num3=0,num2 = 0; cin &gt;&gt; num; temp = num; while(temp)&#123; temp/=10; num3++; &#125; for(i=1;i&lt;=num3;i++) &#123; temp = pow(10,i); cout &lt;&lt; (num%temp)/(temp/10); num2+=(num%temp)/(temp/10); &#125; cout &lt;&lt; endl &lt;&lt; num2 &lt;&lt; endl &lt;&lt; num3 &lt;&lt; endl; return 0;&#125; 比赛对阵策略【问题描述】两个乒乓球队进行比赛，各出三人。甲队为A,B,C三人，乙队为X,Y,Z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。A说他不和X比，C说他不和X,Z比，请编程找出三对赛手间的对阵情况。 【输入形式】无【输出形式】标准输出，三对赛手对阵对阵情况，每对内部用“–”隔开，每对间使用空格隔开。 【样例输入】【样例输出】A–Z B–X C–Y 【样例说明】注意输出格式，空格和回车不要出现混乱。【评分标准】正确输出结果。 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; char i,j,k; for (i='X';i&lt;='Z';i++) for (j='X';j&lt;='Z';j++) for (k='X';k&lt;='Z';k++) &#123; if(i!='X' &amp;&amp; k!='X' &amp;&amp; k!='Z' &amp;&amp; i!=j &amp;&amp; j!=k &amp;&amp; i!=k) cout &lt;&lt; \"A--\" &lt;&lt; i &lt;&lt; \" B--\" &lt;&lt; j &lt;&lt; \" C--\" &lt;&lt; k; &#125; return 0; &#125;","categories":[{"name":"C++理论作业","slug":"C-理论作业","permalink":"https://cnatom.github.io/categories/C-%E7%90%86%E8%AE%BA%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"【C++继承与派生】构造函数的执行顺序","slug":"【C-继承与派生】构造函数的执行顺序","date":"2019-11-23T08:36:27.000Z","updated":"2020-01-27T16:29:16.278Z","comments":true,"path":"2019/11/23/【C-继承与派生】构造函数的执行顺序/","link":"","permalink":"https://cnatom.github.io/2019/11/23/%E3%80%90C-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F%E3%80%91%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"派生类对象构造函数的执行顺序： 先调用基类的构造函数 再执行“初始化列表”中所列出的数据成员的构造函数 最后执行派生类构造函数的函数体（指的是派生类构造函数的花括号内部的代码） 举个栗子：1.先创建一个名为A的简单基类，里面包含一个构造函数和一个数据成员 123456class A &#123;private: int a;public: A(int v) :a(v) &#123;&#125;&#125;; 2.然后再用A类派生出一个B类，为了区分，我们将初始化列表分行表示 12345678910111213141516171819class B :public A &#123;private: int b1; A obj1; A obj2; int b2; int b3;public: B(int v) : b1(v),//1号 obj2(v),//2号 obj1(v),//3号 b2(v),//4号 A(v)//5号 &#123; b3 = v;//6号 &#125;&#125;; 3.在主函数中定义一个B类对象，来调用派生类B的构造函数 12345int main()&#123; B obj(5); return 0;&#125; 3.先用理论分析一波：步骤一中“先调用基类的构造函数”：那么毋庸置疑，先执行5号代码A(v)调用基类的构造函数； 步骤二“再执行“初始化列表”中所列出的数据成员的“构造函数”。 这里需要特别注意，初始化列表中的执行顺序，是按照“数据成员的声明顺序”来赋值，而不是按照初始化列表的语句（1号→2号→3号→4号）来依次赋值的。 所以此步的赋值顺序是：1号(b1) → 3号(obj1) → 2号(obj2) → 4号(b2) 步骤三最后执行派生类构造函数的函数体：最后执行6号语句 4.建议复制代码，在编辑器上调试一下，看看执行顺序是怎样的 说了这么多，其实最主要的是步骤二，C++把子对象和基本类型的数据同等看待了","categories":[{"name":"踩过的坑","slug":"踩过的坑","permalink":"https://cnatom.github.io/categories/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cnatom.github.io/tags/C/"}]},{"title":"各种算法的Python写法(更新ing)","slug":"各种算法的Python写法-更新ing","date":"2019-11-23T07:49:58.000Z","updated":"2020-01-27T16:31:40.648Z","comments":true,"path":"2019/11/23/各种算法的Python写法-更新ing/","link":"","permalink":"https://cnatom.github.io/2019/11/23/%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84Python%E5%86%99%E6%B3%95-%E6%9B%B4%E6%96%B0ing/","excerpt":"","text":"冒泡排序123456def sort_mao(arr): '''冒泡排序（从高到低)''' for i in range(0,len(arr)-1): for j in range(0,len(arr)-i-1): if arr[j]&gt;arr[j+1]: arr[j],arr[j+1] = arr[j+1],arr[j] 选择排序12345678910def sort_xuan(arr): '''选择排序''' for i in range(0,len(arr)-1): min = arr[i] min_where = i for j in range(i+1,len(arr)): if arr[j] &lt; min: min = arr[j] min_where = j arr[i],arr[min_where] = arr[min_where],arr[i] 二分查找1).不用递归的方法12345678910111213141516def search_no(arr,aim): '''非递归的二分查找''' start=0 end=len(arr) while start&lt;=end: #这里的(start+end)/2要用int限定，否则自动为float型，会报错哦 mid=int((start+end)/2) if(arr[mid] == aim): return mid elif(arr[mid]&gt;aim): end = mid-1 continue else: start = mid+1 continue return False #如果start&gt;end说明没找到，就返回False 2).用递归的方法特别注意：在python中函数调用函数的时候，被调用的函数前面要加return，否则只会返回None，python中的递归过程参考:python 递归函数返回值 123456789101112def search_yes(arr,aim,start,end): '''递归的二分查找''' mid = int((start+end)/2) if(start&gt;end): return -1 elif(arr[mid]==aim): return mid elif(arr[mid]&gt;aim): #此处必须写return 否则总会返回None（血的教训o(╥﹏╥)o） return search_yes(arr,aim,start,mid-1) else: return search_yes(arr,aim,mid+1,end)","categories":[{"name":"备忘录","slug":"备忘录","permalink":"https://cnatom.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://cnatom.github.io/tags/python/"}]},{"title":"《Python从入门到实践》笔记","slug":"《Python从入门到实践》笔记","date":"2019-11-21T05:28:42.000Z","updated":"2020-04-23T11:39:21.912Z","comments":true,"path":"2019/11/21/《Python从入门到实践》笔记/","link":"","permalink":"https://cnatom.github.io/2019/11/21/%E3%80%8APython%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第二章 变量和简单数据类型2.1 输出一个hello world12print(\"hello world\")#用#进行注释 2.2 变量的定义12345num1 = 1 #整型num2 = 1.0 #浮点型str1 = 'abcd' #字符串型str2 = \"abcd\" #字符串型bool1 = True #布尔型 直接用 变量名=变量值 来定义，系统自动检测变量的类型 2.3.1 使用方法修改字符串的大小写（title,upper,lower）1234name = \"i loVe pYthon\"print(name.upper()) #临时转为大写print(name.lower()) #临时转为小写print(name.title()) #临时首字母大写 2.3.2 合并字符串（str + str）1234567first_name = \"abc\"last_name = \"def\"name = first_name + last_nameprint(name) ================ 运行结果 ================abcdef&gt;&gt;&gt; 2.3.4 删除空白（str.strip() str.lstrip() str.rstrip() )123456789c = \" python \"print(\".\"+c.rstrip()+\".\") #删除右边的空白print(\".\"+c.lstrip()+\".\") #删除左边的空白print(\".\"+c.strip()+\".\") #删除两边的空格================ 运行结果 ================. python..python ..python.&gt;&gt;&gt; 第三章 列表简介3.1 建立并访问列表123arr = ['a','b','c']print(arr[0]) #类似于C，用下标的方式寻找print(arr[-2]) #访问倒数第二个元素 3.2 修改添加和删除元素1.修改元素 123s = [\"abc\",\"def\"]s[0] = \"ghi\" # 修改&gt;&gt;&gt; 2.添加元素（添加append、插入insert） 12345678s = [\"a\",\"b\",\"c\",\"d\"]s.append(\"添加了e\")s.insert(1,\"插入了python\")print(s)============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============['a', '插入了python', 'b', 'c', 'd', '添加了e']&gt;&gt;&gt; 3.删除元素 12345s = [\"a\",\"b\",\"c\",\"d\"]del s[0] #无返回值删除temp1 = s.pop() #删除最后一个元素 并返回temp2 = s.pop(1) #删除index=1的元素 并返回s.remove('b') #根据值删除元素 3.3 组织列表（永久排序，临时排序，永久反转，确定长度）123456arr = [2,1,3,4,5]arr.sort() #顺序永久排序arr.sort(reverse=True) #倒序永久排序print(arr.sorted) #临时顺序排序arr.reverse() #永久反转lenth=len(arr) #获取列表的长度 第四章 操作列表4.1 遍历列表（for语句）123456789101112131415ss = ['ab','cd','ef']for s in ss: print('进入循环') print(s) print(\"Thanks\")============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============进入循环ab进入循环cd进入循环efThanks&gt;&gt;&gt; 1.第二行代码让python从列表ss中依次取出一个元素，并将其储存在s变量中2.在代码行for s in ss:后面缩进的代码行都是循环的一部分 4.3 创建数字列表1.使用range()函数 12345678for value in range(1,5): print(value) ============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============1234&gt;&gt;&gt; 实际上range()函数返回一个临时的列表 2.用list()将range()的结果转换为列表 12345numbers = list(range(1,5))print(numbers)============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============[1, 2, 3, 4]&gt;&gt;&gt; 3.创建一个包含前10个整数平方的列表 1234567arr = []for value in range(1,11): arr.append(value**2)print(arr)============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]&gt;&gt;&gt; value2表示value的平方，同理value\\n代表value的n次方 4.对数字进行简单的统计计算（min，max，sum函数） 1234567&gt;&gt;&gt; digits = [1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; min(digits)1&gt;&gt;&gt; max(digits)10&gt;&gt;&gt; sum(digits)55 5.列表解析（一行代码生成 前10个整数平方的 列表) 1arr = [value**2 for value in range(1,11)] for value in range(1,11)语句依次对value赋值 4.4 使用列表的一部分(切片)1.切片 123456789&gt;&gt;&gt; ss = ['a','b','c','d','e','f']&gt;&gt;&gt; print(ss[1:3]) #输出下标 1-2 的元素['b', 'c']&gt;&gt;&gt; print(ss[:3]) #输出前三个元素['a', 'b', 'c']&gt;&gt;&gt; print(ss[1:]) #输出下标 1 之后的元素['b', 'c', 'd', 'e', 'f']&gt;&gt;&gt; print(ss[-2:]) #输出倒数2个元素['e', 'f'] 2.遍历切片 123456&gt;&gt;&gt; ss = ['a','b','c','d','e','f']&gt;&gt;&gt; for temp in ss[1:4]:&gt;&gt;&gt; print(temp)bcd 3.复制列表 123ss = ['a','b','c','d','e','f']temp1 = ss[:]temp2 = ss temp1 = ss[:]为值的复制，若修改temp1，ss不会受到影响temp2 = ss为地址的复制，相当于C++中的创建引用。若修改temp2，那么ss也会被修改 4.5 元组（不可变的列表）12345678910#定义元组（用括号）arr = (1,2,3,4)print(arr[0])#遍历元组的值for temp in arr: print(temp)#修改元组的值（不能修改元组的元素，但是可以给存储元组的变量赋值arr1 = (1,2)arr1[0] = 2 ×arr1 = (3,4) √ 第五章 if语句5.1 基本句法1234567891011old = 18if old&lt;2: print(\"婴儿\")elif old&gt;=2 and old&lt;4: print(\"蹒跚学步\")elif old&gt;=4 and old&lt;13: print(\"儿童\")elif old&gt;=13 and old&lt;18: print(\"青少年\")else: print(\"成年人\") 5.2 用if检查列表中是否有某一个元素12345ss = ['a','b','c']if 'a' in ss: print(\"YES\")else: print(\"NO\") ‘a’ in ss 如果a能在ss列表中找到，那么就返回True 5.3 确定列表不是空的123456&gt;&gt;&gt; ss = []&gt;&gt;&gt; if ss:&gt;&gt;&gt; print(\"不是空的\")&gt;&gt;&gt; else:&gt;&gt;&gt; print(\"是空的\")是空的 第六章 字典6.2 使用字典1.字典的定义 1dic = &#123;'name':'Amy','age':18&#125; 2.访问字典中的值（以1的定义为例） 1print(dic['name']) 字典是一系列 键-值对 ，与键相关联的可以是 数字、字符串、列表甚至字典（任何python对象都可以与其相关联） 3.添加 键-值对 12dic = &#123;'name':'Amy','age':18&#125;dic['score'] = 100 添加’score’-100键-值对到字典的最后面 4.修改字典中的值 12dic = &#123;'name':'Amy','age':18&#125;dic['name'] = 'Tom' 5.删除键-值对 123456dic = &#123;'name':'Amy','age':18&#125;del dic['name']print(dic)============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============&#123;'age': 18&#125;&gt;&gt;&gt; 6.3 遍历字典1.遍历所有的键-值对（用items()方法） 12345678910111213dic = &#123; 'name':'Amy', 'age':18, 'score':100 &#125;for key,value in dic.items(): print(key + ':' + str(value))============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============name:Amyage:18score:100&gt;&gt;&gt; 1.dic.items() 分别将键与值赋值给key与value2.str(value)将数值强制转换为字符型，才可以用+运算符 2.遍历字典中所有的键（keys()方法）与值（values()方法） 12for key in dic.keys():######for value in dic.values():###### 遍历键也可以不用keys，直接for key in dic:，但是用keys方法更容易被理解 3.按顺序遍历字典中所有的键 1for key in sorted(dic.keys()):##### 使用sorted函数将dic的键列表暂时排序 4.用set()函数去重 1234567dic = &#123;1:'a',2:'b',3:'a'&#125;for value in set(dic.values()): print(value)============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============ab&gt;&gt;&gt; 6.4 嵌套P93:有时候，需要将一系列字典存储在列表里，或将列表作为值存储在字典里，这称为嵌套（略） 第七章 用户输入和while循环7.1 用函数input()进行用户输入1234567name = input(\"Enter your name: \")name = 'Hello ' + nameprint(name)============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============Enter your name: TomHello Tom&gt;&gt;&gt; 7.2 while循环简介1234i = 1while i&lt;=5: print(i) i+=1 while语句内部也可以用continue和break，规则与C++相同 第八章 函数8.1 定义函数python莫得数据类型（好吧，是弱化了），所以不需要 1234def show(): '''文档字符串，可以用来描述函数功能''' print('Hello World')show() 8.2 传递实参12345678910def add(a=-1,b=-1): '''返回两数之和''' return str(a+b)#使用默认值参数print(add()) #输出-2#按顺序传参 print(add(1,1)) #输出2#顺序随意的关键字实参print(add(b=2,a=2)) #输出4 8.4 传递列表123456def fun(lists): lists[0] = 666 # 修改列表的值 for list in lists: print(list)a = [1,2,3,4]fun(a) # 传递列表 如果要禁止函数修改列表的话，可以用function_name(list_name[:]的方式进行调用 123456def fun(lists): lists[0] = 666 # 修改列表的值a = [1,2,3,4]fun(a[:]) # 传入列表副本for temp in a: print(temp) # 原列表a不会改变 8.5 传递任意数量的实参形参名*names中的星号让python创建一个名为name的空元组 1234567def fun(*names): '''打印若干名字''' print(names)fun(\"张三\",\"李四\",\"王五\")============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============('张三', '李四', '王五') *name必须放在形参的最后位置程序会先处理位置实参与关键字实参，余下的实参都被收集到*name中 12345678def fun(school,department,*names): print(school+\" \"+department) print(names)fun(\"家里蹲大学\",\"计算机学院\",\"张三\",\"李四\",\"王五\")============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============家里蹲大学 计算机学院('张三', '李四', '王五') 加两个星号**还可以让python创建一个空字典 12345678def fun(name,age,**others): '''将名字和年龄对应''' map = &#123;&#125; map[name] = age for key,value in others.items(): map[key] = value print(map)fun(\"张三\",19,李四=18,王五=20) 8.6 将函数存储在模块中 (python中的”头文件”)python模块类似于C++的头文件比如： C:\\Flying\\module.py 123456def fun1(): print(\"fun1\")def fun2(): print(\"fun2\")def fun3(): print(\"fun3\") 在同目录下有另一个py文件用import module的方式导入module.py的函数用模块名.函数名()的方式进行调用 123456789import modulemodule.fun1()module.fun2()module.fun3()============= RESTART: C:\\Users\\Administrator\\Desktop\\python.py =============fun1fun2fun3 还可以导入模块中特定的函数from 模块名 import 函数名 12from module import fun1fun1() # 可直接用函数名进行调用 也可以取别名from 模块名 import 函数名 as 函数别名 12from module import fun1 as ff() 给模块指定别名import 模块名 as 模块别名 12import module as mm.fun1() 甚至可以直接导入模块中的所有函数from 模块名 import * 1234from module import *fun1()fun2()fun3()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://cnatom.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python","slug":"python","permalink":"https://cnatom.github.io/tags/python/"}]},{"title":"《UE4蓝图完全学习》笔记","slug":"《UE4蓝图完全学习》笔记","date":"2019-11-08T15:14:09.000Z","updated":"2020-01-27T16:25:22.129Z","comments":true,"path":"2019/11/08/《UE4蓝图完全学习》笔记/","link":"","permalink":"https://cnatom.github.io/2019/11/08/%E3%80%8AUE4%E8%93%9D%E5%9B%BE%E5%AE%8C%E5%85%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"UE4蓝图完全学习教程笔记Chapter 1 &amp; 21. 打印字符串：print（printstring） 2. 创建各种类型的文本:make literal + 各种类型名（make+类型名更方便）) 3. 加减乘除运算：+ - * /（以+为例） 4. 添加数学表达式：在右击图标的最下方，选择“添加数学表达式”) 5. 设置变量：蓝图编辑器左边“我的蓝图”界面直接创建 6.创建数组：在原有普通变量的基础上进行细节修改 7.在流程中修改数组的值：set array elem（图示是将第1个元素修改为100） 8.从数组中取值：get（图示获取第0个元素并输出） 9.在数组末尾添加元素：add 10.删除数组元素：remove index（图示删除第0个元素，后面的都会向前补位） 11.在流程中动态创建数组：make array Chapter 3（掌握流程控制）1.创建分支：branch（或中文输入“分支”）（Condition复选框为勾选状态时，执行“真”处理，否则执行“假”处理） 2.值的比较：= &gt;= &lt;=（符合条件，则返回1，否则返回0） 3.判断变量是否为偶数（分支基本练习）（1）用数学表达式来判断（2）用equal的方式判断 4.蓝图中的switch：switch on string（开启字符串） （拥有多项判断能力的分支，以猜拳为例） （1）创建switch on string节点（2）创建转移（2）创建“猜拳”变量并初始化，由switch判断“猜拳”变量中的值是哪一个元素 5.ForLoop循环：loop(forloop) （利用计数器的循环) 上述输出结果为“1 2 3 4 5 循环体结束后执行completed节点”其中，index返回每一层循环的index值 6.连接文本：append 输出结果为“1time 2time 3time 4time 5time 循环体结束” 7.专门处理数组的循环：ForEachLoop 8.简单的循环：WhileLoop 示例为判断num是否是素数，counter初始值为2","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://cnatom.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"虚幻引擎","slug":"虚幻引擎","permalink":"https://cnatom.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"}]}]}